{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TerraME: Multiparadigm Modeling Toolkit TerraME is a programming environment for spatial dynamical modelling. It supports cellular automata, agent-based models, and network models running in 2D cell spaces. TerraME provides an interface to TerraLib geographical database, allowing models direct access to geospatial data. Its modelling language has in-built functions that makes it easier to develop multi-scale and multi-paradigm models for environmental applications. Two important innovations in TerraME are its use of anisotropic spaces and of hybrid automata models. Anisotropic spaces arise when modeling natural and human-related phenomena. For example, land settlers in a new area do not occupy all places at the same time. They follow roads and rivers, leading to an anisotropic pattern. Anisotropic spaces are implemented in TerraME using Generalized Proximity Matrices (GPM). The GPM is an extension of the usual definition of the spatial relations and include a combination of neighborhood measures in the absolute space and in the relative space. A hybrid automaton is an abstract model for a system whose behavior has discrete and continuous parts. It extends the idea of finite automata to allow continuous change to take place between transitions. Adopting hybrid automata in spatial dynamical models allows complex models which include critical transitions. A vision of research motivations and directions of Environmental Modelling in INPE is available in this presentation . An early presentation of our vision is How can GIScience contribute to Land Change Modelling? , the keynote speech at GIScience 2006. The rationale for the TerraME software is presented in the lecture Modelling human-environment interactions , presented in the Vespucci Summer School 2010. Download The latest version of TerraME is 2.0.1 (Released on 20 August 2020). It has installers for Windows and Mac and there is a compiled version for Linux. Download TerraME 2.0.1 In Windows, you can run TerraME by clicking in the icon on Desktop. In Mac and Linux, it is possible to run it by calling $> terrame using the command prompt. The graphical interface has options to run examples, configure and run models, see documentation, as well as download and install additional packages. There are links to the source code of the models as well as the examples in the documentation. Editor You can implement models in TerraME using any text file editor of your preference, such as Notepad++ , Vim or Emacs . We currently suggest that you use ZeroBraneStudio as your programming environment to develop models in TerraME. It is free and open source (but it is possible to donate to the project). After downloading and installing ZeroBraneStudio (ZBS), please execute the steps in the tutorial available here . Documentation Tutorials Lua for TerraME: A Short Introduction An Introduction to TerraME Modeling Paradigms in TerraME Creating and Filling Cellular Spaces Multiple Simulations Publishing Geospatial Data Packages You can execute a Google search in TerraME packages here . The two basic packages of TerraME that comes with its installation are: base : A package with the basic modelling concepts, such as Cell, CellularSpace, Agent, Timer, and Model. gis : A package to handle geospatial data. It has types to manage TerraView projects as well as functions to create and fill cellular layers. Using the graphical interface, it is possible to download and install packages from TerraME's repository. They are are: ca : Some cellular automata models. logo : Basic spatial agent-based models. sci : A small package with interpolation functions. sysdyn : Examples using system dynamics models. calibration : Functions to run a given model several times, as well as metrics to compute goodness-of-fit and to calibrate models using genetic algorithms. publish : Create webmap tools using the input as well as output of models. gpm : Create geospatial data as well as neighbourhood files using connectivity networks such as roads. You can run examples directly in the graphical interface of TerraME. Click in the Desktop icon to open it in Windows or run \u201cterrame\u201d in the command line to open the graphical interface. From the graphical interface it is possible to see the documentation of each installed package. Courses We use TerraME on our courses on Enviromental Modelling. We give regular graduate courses in the research programs in Earth System Science at INPE and Computer Science at UFOP. FAQ Frequently asked questions are answered here . Papers and reports Bezerra et al. New land-use change scenarios for Brazil: Refining global SSPs with a regional spatially-explicit allocation model . Plos one 17.4, 2022: e0256052. Aguiar et al. Land use change emission scenarios: anticipating a forest transition process in the Brazilian Amazon . Global change biology, v. 22, n. 5, p. 1821-1840, 2016. Aguiar et al. Modeling the spatial and temporal heterogeneity of deforestation\u2010driven carbon emissions: the INPE\u2010EM framework applied to the Brazilian Amazon . Global Change Biology, v. 18, n. 11, p. 3346-3366, 2012. Carneiro, T. G. S. ; Andrade, P. R. ; C\u00e2mara, G. ; Monteiro, A. M. V. ; Pereira, R. R. . An extensible toolbox for modeling nature-society interactions . Environmental Modelling & Software , 2013. DOI:10.1016/j.envsoft.2013.03.002. Silva, S. H. C. ; Carneiro, T. G. S. ; Lima, J.. TerraME HPA: Parallel Simulation of Multi-Agent Systems over SMP. ACM SIGSIM Conference on Principles of Advanced Discrete Simulation , 2013, Montreal. Rodrigues, A. J. C., Carneiro, T. G. S., Andrade, P. R.. TerraME Observer: An extensible real-time visualization pipeline for dynamic spatial models . XVIII Brazilian Symposium on Geoinformatics , Campos do Jord\u00e3o, 2012. Moreira, Costa, Aguiar, Camara, Carneiro. Dynamical coupling of multiscale land change models , Landscape Ecology , 24(9), p. 1183-1194, 2009. Andrade, Monteiro, C\u00e2mara, Sandri. Games on Cellular Spaces: How Mobility Affects Equilibrium . Journal of Artificial Societies and Social Simulation (JASSS) , 12(1), p. 4, 2009. Carneiro, C\u00e2mara, Maretto. Irregular Cellular Spaces: Supporting Realistic Spatial Dynamic Modeling using Geographical Databases . X Brazilian Symposium on Geoinformatics , GeoInfo'08, Rio de Janeiro, 2008. Carneiro. Nested-CA: a foundation for multiscale modeling of land use and land change. PhD Thesis , INPE, 2006. Extensions LUCCME , an extension for top-down land change modeling. INPE-EM , a framework to compute greenhouse gases emission estimates from land cover change About TerraME has been developed as a joint effort between INPE and TerraLab (Laboratory for Modelling and Simulation of Earth Systems), at Federal University of Ouro Preto. The chief developers of TerraME are Pedro R. Andrade, from INPE, and Tiago Garcia de Senna Carneiro , from Federal University of Ouro Preto (UFOP). INPE's researchers involved in developing models using TerraME include Dr. Gilberto Camara , Dr. Antonio Miguel Monteiro , and Dr. Ana Paula Aguiar . Past contributors to TerraME include: Rodrigo Avancini Ant\u00f4nio Oliveira Jr. Heitor Guerra Jo\u00e3o Chagas Pedro Henrique Costa Raphael Costa Rodrigo Reis Pereira Ant\u00f4nio Jos\u00e9 da Cunha Rodrigues Breno de Almeida Pereira Frederico Gadelha Guimar\u00e3es Henrique Cota Camello Rafael Lage Moreira Barbosa Raian Vargas Maretto Rodolfo Ayala Lopes Costa Rodolfo Maduro Almeida Sergio Souza Costa Saulo Henrique Cabral Silva Tiago Franca de Melo Lima Washington Sena de Fran\u00e7a Acknowledgements Supporting Software The TerraME modelling language is an extension of the Lua programming language and interfaces to TerraLib GIS library for archival and retrieval of geospatial data. Many thanks to the Lua and TerraLib teams for providing such good environments to build upon! Funding Statistics","title":"TerraME: Multiparadigm Modeling Toolkit"},{"location":"#terrame-multiparadigm-modeling-toolkit","text":"TerraME is a programming environment for spatial dynamical modelling. It supports cellular automata, agent-based models, and network models running in 2D cell spaces. TerraME provides an interface to TerraLib geographical database, allowing models direct access to geospatial data. Its modelling language has in-built functions that makes it easier to develop multi-scale and multi-paradigm models for environmental applications. Two important innovations in TerraME are its use of anisotropic spaces and of hybrid automata models. Anisotropic spaces arise when modeling natural and human-related phenomena. For example, land settlers in a new area do not occupy all places at the same time. They follow roads and rivers, leading to an anisotropic pattern. Anisotropic spaces are implemented in TerraME using Generalized Proximity Matrices (GPM). The GPM is an extension of the usual definition of the spatial relations and include a combination of neighborhood measures in the absolute space and in the relative space. A hybrid automaton is an abstract model for a system whose behavior has discrete and continuous parts. It extends the idea of finite automata to allow continuous change to take place between transitions. Adopting hybrid automata in spatial dynamical models allows complex models which include critical transitions. A vision of research motivations and directions of Environmental Modelling in INPE is available in this presentation . An early presentation of our vision is How can GIScience contribute to Land Change Modelling? , the keynote speech at GIScience 2006. The rationale for the TerraME software is presented in the lecture Modelling human-environment interactions , presented in the Vespucci Summer School 2010.","title":"TerraME: Multiparadigm Modeling Toolkit"},{"location":"#download","text":"The latest version of TerraME is 2.0.1 (Released on 20 August 2020). It has installers for Windows and Mac and there is a compiled version for Linux. Download TerraME 2.0.1 In Windows, you can run TerraME by clicking in the icon on Desktop. In Mac and Linux, it is possible to run it by calling $> terrame using the command prompt. The graphical interface has options to run examples, configure and run models, see documentation, as well as download and install additional packages. There are links to the source code of the models as well as the examples in the documentation.","title":"Download"},{"location":"#editor","text":"You can implement models in TerraME using any text file editor of your preference, such as Notepad++ , Vim or Emacs . We currently suggest that you use ZeroBraneStudio as your programming environment to develop models in TerraME. It is free and open source (but it is possible to donate to the project). After downloading and installing ZeroBraneStudio (ZBS), please execute the steps in the tutorial available here .","title":"Editor"},{"location":"#documentation","text":"","title":"Documentation"},{"location":"#tutorials","text":"Lua for TerraME: A Short Introduction An Introduction to TerraME Modeling Paradigms in TerraME Creating and Filling Cellular Spaces Multiple Simulations Publishing Geospatial Data","title":"Tutorials"},{"location":"#packages","text":"You can execute a Google search in TerraME packages here . The two basic packages of TerraME that comes with its installation are: base : A package with the basic modelling concepts, such as Cell, CellularSpace, Agent, Timer, and Model. gis : A package to handle geospatial data. It has types to manage TerraView projects as well as functions to create and fill cellular layers. Using the graphical interface, it is possible to download and install packages from TerraME's repository. They are are: ca : Some cellular automata models. logo : Basic spatial agent-based models. sci : A small package with interpolation functions. sysdyn : Examples using system dynamics models. calibration : Functions to run a given model several times, as well as metrics to compute goodness-of-fit and to calibrate models using genetic algorithms. publish : Create webmap tools using the input as well as output of models. gpm : Create geospatial data as well as neighbourhood files using connectivity networks such as roads. You can run examples directly in the graphical interface of TerraME. Click in the Desktop icon to open it in Windows or run \u201cterrame\u201d in the command line to open the graphical interface. From the graphical interface it is possible to see the documentation of each installed package.","title":"Packages"},{"location":"#courses","text":"We use TerraME on our courses on Enviromental Modelling. We give regular graduate courses in the research programs in Earth System Science at INPE and Computer Science at UFOP.","title":"Courses"},{"location":"#faq","text":"Frequently asked questions are answered here .","title":"FAQ"},{"location":"#papers-and-reports","text":"Bezerra et al. New land-use change scenarios for Brazil: Refining global SSPs with a regional spatially-explicit allocation model . Plos one 17.4, 2022: e0256052. Aguiar et al. Land use change emission scenarios: anticipating a forest transition process in the Brazilian Amazon . Global change biology, v. 22, n. 5, p. 1821-1840, 2016. Aguiar et al. Modeling the spatial and temporal heterogeneity of deforestation\u2010driven carbon emissions: the INPE\u2010EM framework applied to the Brazilian Amazon . Global Change Biology, v. 18, n. 11, p. 3346-3366, 2012. Carneiro, T. G. S. ; Andrade, P. R. ; C\u00e2mara, G. ; Monteiro, A. M. V. ; Pereira, R. R. . An extensible toolbox for modeling nature-society interactions . Environmental Modelling & Software , 2013. DOI:10.1016/j.envsoft.2013.03.002. Silva, S. H. C. ; Carneiro, T. G. S. ; Lima, J.. TerraME HPA: Parallel Simulation of Multi-Agent Systems over SMP. ACM SIGSIM Conference on Principles of Advanced Discrete Simulation , 2013, Montreal. Rodrigues, A. J. C., Carneiro, T. G. S., Andrade, P. R.. TerraME Observer: An extensible real-time visualization pipeline for dynamic spatial models . XVIII Brazilian Symposium on Geoinformatics , Campos do Jord\u00e3o, 2012. Moreira, Costa, Aguiar, Camara, Carneiro. Dynamical coupling of multiscale land change models , Landscape Ecology , 24(9), p. 1183-1194, 2009. Andrade, Monteiro, C\u00e2mara, Sandri. Games on Cellular Spaces: How Mobility Affects Equilibrium . Journal of Artificial Societies and Social Simulation (JASSS) , 12(1), p. 4, 2009. Carneiro, C\u00e2mara, Maretto. Irregular Cellular Spaces: Supporting Realistic Spatial Dynamic Modeling using Geographical Databases . X Brazilian Symposium on Geoinformatics , GeoInfo'08, Rio de Janeiro, 2008. Carneiro. Nested-CA: a foundation for multiscale modeling of land use and land change. PhD Thesis , INPE, 2006.","title":"Papers and reports"},{"location":"#extensions","text":"LUCCME , an extension for top-down land change modeling. INPE-EM , a framework to compute greenhouse gases emission estimates from land cover change","title":"Extensions"},{"location":"#about","text":"TerraME has been developed as a joint effort between INPE and TerraLab (Laboratory for Modelling and Simulation of Earth Systems), at Federal University of Ouro Preto. The chief developers of TerraME are Pedro R. Andrade, from INPE, and Tiago Garcia de Senna Carneiro , from Federal University of Ouro Preto (UFOP). INPE's researchers involved in developing models using TerraME include Dr. Gilberto Camara , Dr. Antonio Miguel Monteiro , and Dr. Ana Paula Aguiar . Past contributors to TerraME include: Rodrigo Avancini Ant\u00f4nio Oliveira Jr. Heitor Guerra Jo\u00e3o Chagas Pedro Henrique Costa Raphael Costa Rodrigo Reis Pereira Ant\u00f4nio Jos\u00e9 da Cunha Rodrigues Breno de Almeida Pereira Frederico Gadelha Guimar\u00e3es Henrique Cota Camello Rafael Lage Moreira Barbosa Raian Vargas Maretto Rodolfo Ayala Lopes Costa Rodolfo Maduro Almeida Sergio Souza Costa Saulo Henrique Cabral Silva Tiago Franca de Melo Lima Washington Sena de Fran\u00e7a","title":"About"},{"location":"#acknowledgements","text":"","title":"Acknowledgements"},{"location":"#supporting-software","text":"The TerraME modelling language is an extension of the Lua programming language and interfaces to TerraLib GIS library for archival and retrieval of geospatial data. Many thanks to the Lua and TerraLib teams for providing such good environments to build upon!","title":"Supporting Software"},{"location":"#funding","text":"","title":"Funding"},{"location":"#statistics","text":"","title":"Statistics"},{"location":"base/","text":"TerraME Types and Functions Version: 2.0.1 License: LGPL-3 Release: 08/19/2020 Authors: INPE and TerraLAB/UFOP URL: www.terrame.org This document presents a detailed description of each type and function of TerraME, ordered alphabetically by its types. TerraME adopts American English (e.g., neighbor instead of neighbo u r), with the following syntax convention: Names of types follow the upper CamelCase style, starting with a capital letter, followed by other words starting with capitalized letters (e.g., Agent, Trajectory, CellularSpace). Functions and parameters names use the lower CamelCase style, with names starting with lower case letters, followed by other words starting with capitalized letters (e.g., load, database, forEachCell, createNeighborhood). There are two signatures for functions in TerraME. The first one is for functions with non-named arguments, with a structure lik \"function(v1, v2, ...)\", where v1 is the 1st argument, v2 is the 2nd, and so forth. The arguments of a call to a function that has this signature must follow the specified order. It is possible to use fewer arguments than the function signature, with missing arguments taking their default values. Parameters of functions following this format are described as #1, #2, etc. in this document. Every parameter that does not have a default value is mandatory. The second signature is for functions with named arguments, with a structure like \"function{arg1 = v1, arg2 = v2, ...}\", where v1 is the value of named argument arg1, v2 is the value of named argument arg2, and so on. These arguments can be used in any order, but the function call needs to use braces. Every type constructor of TerraME and some of its functions have this kind of signature. In this document, such arguments are described with their names. Types Agent An autonomous entity that is capable of performing actions as well as interacting with other Agents and the spatial representation of the model. Automaton A hybrid state machine that needs to be located on a CellularSpace , and is replicated over each Cell of the space. Cell A spatial location with homogeneous internal content. CellularSpace A multivalued set of Cells . Chart Create a line chart showing the variation of one or more attributes (y axis) of an object. Choice Type to define options to be used by the modeler. Clock Create a display with the current time and Event queue of a given Timer . DataFrame A two dimensional table. Directory An abstract representation of a directory. Environment A container that encapsulates space, time, behavior, and other Environments . Event An Event represents a time instant when the simulation engine must execute some computation. File An abstract representation of a file. Flow A Flow describes the behavior of an automaton or Agent in a given State . Group Type that defines an ordered selection over a Society . InternetSender An Internet connection to send attribute values of an object through a TCP or UDP protocol. Jump Control a discrete transition between States . Log A log file to save attributes of an object. Mandatory Type to define a mandatory argument for a given Model . Map Create a map with the spatial distribution of a given CellularSpace , Agent , or Society . Model Type that defines a model. Neighborhood A Neighborhood is a set of pairs (cell, weight), where cell is a neighbor Cell and weight is a number storing the relation's strength. Profiler The type Profiler is used to measure the simulation/execution time of a model or the time to execute small blocks of a model. Random Type to generate random numbers. SocialNetwork SocialNetwork represents relations between A gents. Society Type to create and manipulate a set of Agents . State A container of Jumps and Flows . TextScreen A window with a table to show the attributes of an object along the simulation. Timer A Timer is an event-based scheduler that runs the simulation. Trajectory Type that defines an ordered selection over a CellularSpace . UnitTest Type for testing packages. VisualTable A window with a table to show the current attributes of an object along the simulation. Functions ErrorHandling Some basic and useful functions to handle errors and error messages. OS Functions to handle files and directories. Package Functions to work with packages in TerraME. Utils Some basic and useful functions for modeling. Examples barros Implementation of Barros urban dynamics model. beer Implementation of beer economic chain model. continuous-rain A simple continuous rain model. deforestation Amazonia deforestation models. discrete-rain A simple discrete rain model. drainage A simple drainage model. el-farol Implementation of El Farol model. fire-spread A simple spread model that uses geospatial data. game-of-life Implementation of Conway's Game of Life. growing-moving-society A model with 100 moving and growing Agents . growing-society A model with static Agents that can reproduce to neighbor Cells . ipd Iterated Prisoner's dilemma model. leontief Implementation of a model to study scenarios for the economy of Southeast Para state. predator-prey Implementation of a spatial predator-prey model. runoff Implementation of a simple runoff model using geospatial data. schelling Implementation of Schelling's segregation model. single-agent A simple example with one Agent that moves randomly in space. single-agents-society Simulation of a Society with 30 moving Agents . sir-abm SIR model implemented with agents. sir-basic A simple Susceptible-Infected-Recovered (SIR) model. sir-campaign A Susceptible-Infected-Recovered (SIR) model with a public campaign. sir-improved A Susceptible-Infected-Recovered (SIR) model. spatial-game Implementation of the model proposed by Nowak and Sigmund. tube-discrete A model that describes water flowing out of a tube. tube-inflow-outflow A model that describes water flowing in and out of a tube. tube A simple model that describes water flowing out of a tube. Data agents.csv A simple set of four Agents. amazonia.dbf Cellular data representing the Amazonia region, in Brazil. brazilstates.dbf A shapefile describing the 27 Brazilian states. cabecadeboi-neigh.gpm Neighborhood files to be used with cabecadeboi database. cabecadeboi.dbf Topography data from Cabeca de Boi mountain, Minas Gerais, Brazil, with 100x100m of resolution. cabecadeboi800.dbf Topography data from Cabeca de Boi mountain, Minas Gerais, Brazil, with 800x800m of resolution. emas.dbf Cellular data representing Emas National Park, Brazil. gpmlinesDbEmas.gpm Neighborhood files to be used with emas database. river.dbf A line describing a river within Emas National Park, in Goias, Brazil. simple.pgm A simple CellularSpace with one attribute for sugarscape model. Font Chess Chess icons. Grissom Free Intellecta Design makes research and development of fonts with historical and artistical relevant forms. JLS Smiles Sampler Font by Michael Adkins & James Stirling. LL Faces Head faces of different sizes and internal content. Pet Animals Pet animals by Zdravko Andreev, aka Z-Designs. Pregnancy Pregnancy icons. Science Some science objects and symbols. Freaky Face Some faces with different number of eyes. Ubuntu The Ubuntu Font Family are a set of matching new libre/open fonts.","title":"Index"},{"location":"base/#terrame-types-and-functions","text":"Version: 2.0.1 License: LGPL-3 Release: 08/19/2020 Authors: INPE and TerraLAB/UFOP URL: www.terrame.org This document presents a detailed description of each type and function of TerraME, ordered alphabetically by its types. TerraME adopts American English (e.g., neighbor instead of neighbo u r), with the following syntax convention: Names of types follow the upper CamelCase style, starting with a capital letter, followed by other words starting with capitalized letters (e.g., Agent, Trajectory, CellularSpace). Functions and parameters names use the lower CamelCase style, with names starting with lower case letters, followed by other words starting with capitalized letters (e.g., load, database, forEachCell, createNeighborhood). There are two signatures for functions in TerraME. The first one is for functions with non-named arguments, with a structure lik \"function(v1, v2, ...)\", where v1 is the 1st argument, v2 is the 2nd, and so forth. The arguments of a call to a function that has this signature must follow the specified order. It is possible to use fewer arguments than the function signature, with missing arguments taking their default values. Parameters of functions following this format are described as #1, #2, etc. in this document. Every parameter that does not have a default value is mandatory. The second signature is for functions with named arguments, with a structure like \"function{arg1 = v1, arg2 = v2, ...}\", where v1 is the value of named argument arg1, v2 is the value of named argument arg2, and so on. These arguments can be used in any order, but the function call needs to use braces. Every type constructor of TerraME and some of its functions have this kind of signature. In this document, such arguments are described with their names.","title":"TerraME Types and Functions"},{"location":"base/#types","text":"Agent An autonomous entity that is capable of performing actions as well as interacting with other Agents and the spatial representation of the model. Automaton A hybrid state machine that needs to be located on a CellularSpace , and is replicated over each Cell of the space. Cell A spatial location with homogeneous internal content. CellularSpace A multivalued set of Cells . Chart Create a line chart showing the variation of one or more attributes (y axis) of an object. Choice Type to define options to be used by the modeler. Clock Create a display with the current time and Event queue of a given Timer . DataFrame A two dimensional table. Directory An abstract representation of a directory. Environment A container that encapsulates space, time, behavior, and other Environments . Event An Event represents a time instant when the simulation engine must execute some computation. File An abstract representation of a file. Flow A Flow describes the behavior of an automaton or Agent in a given State . Group Type that defines an ordered selection over a Society . InternetSender An Internet connection to send attribute values of an object through a TCP or UDP protocol. Jump Control a discrete transition between States . Log A log file to save attributes of an object. Mandatory Type to define a mandatory argument for a given Model . Map Create a map with the spatial distribution of a given CellularSpace , Agent , or Society . Model Type that defines a model. Neighborhood A Neighborhood is a set of pairs (cell, weight), where cell is a neighbor Cell and weight is a number storing the relation's strength. Profiler The type Profiler is used to measure the simulation/execution time of a model or the time to execute small blocks of a model. Random Type to generate random numbers. SocialNetwork SocialNetwork represents relations between A gents. Society Type to create and manipulate a set of Agents . State A container of Jumps and Flows . TextScreen A window with a table to show the attributes of an object along the simulation. Timer A Timer is an event-based scheduler that runs the simulation. Trajectory Type that defines an ordered selection over a CellularSpace . UnitTest Type for testing packages. VisualTable A window with a table to show the current attributes of an object along the simulation.","title":"Types"},{"location":"base/#functions","text":"ErrorHandling Some basic and useful functions to handle errors and error messages. OS Functions to handle files and directories. Package Functions to work with packages in TerraME. Utils Some basic and useful functions for modeling.","title":"Functions"},{"location":"base/#examples","text":"barros Implementation of Barros urban dynamics model. beer Implementation of beer economic chain model. continuous-rain A simple continuous rain model. deforestation Amazonia deforestation models. discrete-rain A simple discrete rain model. drainage A simple drainage model. el-farol Implementation of El Farol model. fire-spread A simple spread model that uses geospatial data. game-of-life Implementation of Conway's Game of Life. growing-moving-society A model with 100 moving and growing Agents . growing-society A model with static Agents that can reproduce to neighbor Cells . ipd Iterated Prisoner's dilemma model. leontief Implementation of a model to study scenarios for the economy of Southeast Para state. predator-prey Implementation of a spatial predator-prey model. runoff Implementation of a simple runoff model using geospatial data. schelling Implementation of Schelling's segregation model. single-agent A simple example with one Agent that moves randomly in space. single-agents-society Simulation of a Society with 30 moving Agents . sir-abm SIR model implemented with agents. sir-basic A simple Susceptible-Infected-Recovered (SIR) model. sir-campaign A Susceptible-Infected-Recovered (SIR) model with a public campaign. sir-improved A Susceptible-Infected-Recovered (SIR) model. spatial-game Implementation of the model proposed by Nowak and Sigmund. tube-discrete A model that describes water flowing out of a tube. tube-inflow-outflow A model that describes water flowing in and out of a tube. tube A simple model that describes water flowing out of a tube.","title":"Examples"},{"location":"base/#data","text":"agents.csv A simple set of four Agents. amazonia.dbf Cellular data representing the Amazonia region, in Brazil. brazilstates.dbf A shapefile describing the 27 Brazilian states. cabecadeboi-neigh.gpm Neighborhood files to be used with cabecadeboi database. cabecadeboi.dbf Topography data from Cabeca de Boi mountain, Minas Gerais, Brazil, with 100x100m of resolution. cabecadeboi800.dbf Topography data from Cabeca de Boi mountain, Minas Gerais, Brazil, with 800x800m of resolution. emas.dbf Cellular data representing Emas National Park, Brazil. gpmlinesDbEmas.gpm Neighborhood files to be used with emas database. river.dbf A line describing a river within Emas National Park, in Goias, Brazil. simple.pgm A simple CellularSpace with one attribute for sugarscape model.","title":"Data"},{"location":"base/#font","text":"Chess Chess icons. Grissom Free Intellecta Design makes research and development of fonts with historical and artistical relevant forms. JLS Smiles Sampler Font by Michael Adkins & James Stirling. LL Faces Head faces of different sizes and internal content. Pet Animals Pet animals by Zdravko Andreev, aka Z-Designs. Pregnancy Pregnancy icons. Science Some science objects and symbols. Freaky Face Some faces with different number of eyes. Ubuntu The Ubuntu Font Family are a set of matching new libre/open fonts.","title":"Font"},{"location":"base/data/","text":"Data agents.csv A simple set of four Agents. amazonia.shp Cellular data representing the Amazonia region, in Brazil. brazilstates.shp A shapefile describing the 27 Brazilian states. cabecadeboi-neigh.gpm Neighborhood files to be used with cabecadeboi database. cabecadeboi.shp Topography data from Cabeca de Boi mountain, Minas Gerais, Brazil, with 100x100m of resolution. cabecadeboi800.shp Topography data from Cabeca de Boi mountain, Minas Gerais, Brazil, with 800x800m of resolution. emas.shp Cellular data representing Emas National Park, Brazil. gpmlinesDbEmas.gpm Neighborhood files to be used with emas database. river.shp A line describing a river within Emas National Park, in Goias, Brazil. simple.pgm A simple CellularSpace with one attribute for sugarscape model. Directory test Directory with files used only for internal tests. agents.csv A simple set of four Agents. File: agents.csv Quantity: 5 Separator: \",\" Source: TerraME team Attribute Type Description age number Age of the agent. immune string Whether the agent is immune. metabolism number Energy consumed by time step. name string Name of the agents. vision number Distance in cells the agent can see. wealth number Amount of sugar the agent starts with. amazonia.shp Cellular data representing the Amazonia region, in Brazil. It has 50x50km of resolution. Files: amazonia.dbf , amazonia.prj , amazonia.shp , amazonia.shx Representation: polygon Quantity: 2229 Projection: 'USER:900914', with EPSG: 900914 (PROJ4: '+proj=lcc +lat_0=29.6666666666667 +lon_0=-100.333333333333 +lat_1=31.8833333333333 +lat_2=30.1166666666667 +x_0=2296583.333333 +y_0=9842500 +datum=NAD83 +units=m +no_defs') Source: This data is a copy of the file with the same name created by terralib package. Attribute Type Description col number Cell's column. distports number Distance to ports. distroads number Distance to roads. id string Unique identifier (internal value). prodes_10 number Percentage of clear-cut area. prodes_208 number Percentage of forest area. protected number Percentage of indigenous area. row number Cell's row. brazilstates.shp A shapefile describing the 27 Brazilian states. Files: brazilstates.dbf , brazilstates.shp , brazilstates.shx Representation: polygon Quantity: 27 Projection: Undefined, with EPSG: 0 (PROJ4: Undefined) Source: IBGE ( http://www.ibge.gov.br ) Attribute Type Description CAPITAL string Name of the state's capital. NOME_UF string Name of the state. POPUL number Population of the state. SIGLA string State's initials. cabecadeboi-neigh.gpm Neighborhood files to be used with cabecadeboi database. File: cabecadeboi-neigh.gpm Connected file/layer: cabecadeboi900.shp Number of origins: 121 Number of connections: 1236 Source: TerraME team cabecadeboi.shp Topography data from Cabeca de Boi mountain, Minas Gerais, Brazil, with 100x100m of resolution. Files: cabecadeboi.dbf , cabecadeboi.prj , cabecadeboi.shp , cabecadeboi.shx Representation: polygon Quantity: 8100 Projection: 'WGS 84 / TM 6 NE', with EPSG: 2311 (PROJ4: '+proj=tmerc +lat_0=0 +lon_0=6 +k=0.9996 +x_0=500000 +y_0=0 +datum=WGS84 +units=m +no_defs') Source: This data is a copy of the file with the same name created by terralib package. Attribute Type Description col number Cell's column. height number Height of the Cell, measured in values between 0 and 255. id string Unique identifier (internal value). row number Cell's row. cabecadeboi800.shp Topography data from Cabeca de Boi mountain, Minas Gerais, Brazil, with 800x800m of resolution. Files: cabecadeboi800.dbf , cabecadeboi800.prj , cabecadeboi800.shp , cabecadeboi800.shx Representation: polygon Quantity: 144 Projection: 'NAD83', with EPSG: 4269 (PROJ4: '+proj=longlat +datum=NAD83 +no_defs') Source: This data is a copy of cabecadeboi created by terralib package, using a resolution of 800m. Attribute Type Description col number Cell's column. height number Height of the Cell, measured in values between 0 and 255. id string Unique identifier (internal value). row number Cell's row. emas.shp Cellular data representing Emas National Park, Brazil. It has 500x500m of resolution. Files: emas.dbf , emas.prj , emas.shp , emas.shx Representation: polygon Quantity: 5514 Projection: 'USER:900915', with EPSG: 900915 (PROJ4: '+proj=utm +zone=22 +south +ellps=aust_SA +units=m +no_defs') Source: This data is a copy of the file with the same name created by terralib package. Reference: Almeida, Rodolfo M., et al. 'Simulando padroes de incendios no Parque Nacional das Emas, Estado de Goias, Brasil.' X Simposio Brasileiro de Geoinformatica (2008) Attribute Type Description col number Cell's column. firebreak number Cell has a firebreak (1) or not (0). id string Unique identifier (internal value). maxcover number A value between 1 and 5 with the maximum value for the forest cover according to the original data with lower resolution. mincover number A value between 1 and 5 with the minimum value for the forest cover according to the original data with lower resolution. river number Cell has a river (1) or not (0). row number Cell's row. gpmlinesDbEmas.gpm Neighborhood files to be used with emas database. File: gpmlinesDbEmas.gpm Connected files/layers: emas.shp and river.shp Number of origins: 1435 Number of connections: 623 Source: TerraME team river.shp A line describing a river within Emas National Park, in Goias, Brazil. Files: river.dbf , river.shp , river.shx Representation: line Quantity: 208 Projection: Undefined, with EPSG: 0 (PROJ4: Undefined) Source: Rodolfo Almeida simple.pgm A simple CellularSpace with one attribute for sugarscape model. File: simple.pgm Source: TerraME team test Directory with files used only for internal tests. This directory is not available within TerraME installer, but it can be downloaded from GitHub. Files: 36 Extensions: csv, dbf, gal, gpm, gwt, prj, qix, shp, shx Source: TerraME team","title":"Data"},{"location":"base/data/#data","text":"agents.csv A simple set of four Agents. amazonia.shp Cellular data representing the Amazonia region, in Brazil. brazilstates.shp A shapefile describing the 27 Brazilian states. cabecadeboi-neigh.gpm Neighborhood files to be used with cabecadeboi database. cabecadeboi.shp Topography data from Cabeca de Boi mountain, Minas Gerais, Brazil, with 100x100m of resolution. cabecadeboi800.shp Topography data from Cabeca de Boi mountain, Minas Gerais, Brazil, with 800x800m of resolution. emas.shp Cellular data representing Emas National Park, Brazil. gpmlinesDbEmas.gpm Neighborhood files to be used with emas database. river.shp A line describing a river within Emas National Park, in Goias, Brazil. simple.pgm A simple CellularSpace with one attribute for sugarscape model.","title":"Data"},{"location":"base/data/#directory","text":"test Directory with files used only for internal tests.","title":"Directory"},{"location":"base/data/#agentscsv","text":"A simple set of four Agents. File: agents.csv Quantity: 5 Separator: \",\" Source: TerraME team Attribute Type Description age number Age of the agent. immune string Whether the agent is immune. metabolism number Energy consumed by time step. name string Name of the agents. vision number Distance in cells the agent can see. wealth number Amount of sugar the agent starts with.","title":"agents.csv"},{"location":"base/data/#amazoniashp","text":"Cellular data representing the Amazonia region, in Brazil. It has 50x50km of resolution. Files: amazonia.dbf , amazonia.prj , amazonia.shp , amazonia.shx Representation: polygon Quantity: 2229 Projection: 'USER:900914', with EPSG: 900914 (PROJ4: '+proj=lcc +lat_0=29.6666666666667 +lon_0=-100.333333333333 +lat_1=31.8833333333333 +lat_2=30.1166666666667 +x_0=2296583.333333 +y_0=9842500 +datum=NAD83 +units=m +no_defs') Source: This data is a copy of the file with the same name created by terralib package. Attribute Type Description col number Cell's column. distports number Distance to ports. distroads number Distance to roads. id string Unique identifier (internal value). prodes_10 number Percentage of clear-cut area. prodes_208 number Percentage of forest area. protected number Percentage of indigenous area. row number Cell's row.","title":"amazonia.shp"},{"location":"base/data/#brazilstatesshp","text":"A shapefile describing the 27 Brazilian states. Files: brazilstates.dbf , brazilstates.shp , brazilstates.shx Representation: polygon Quantity: 27 Projection: Undefined, with EPSG: 0 (PROJ4: Undefined) Source: IBGE ( http://www.ibge.gov.br ) Attribute Type Description CAPITAL string Name of the state's capital. NOME_UF string Name of the state. POPUL number Population of the state. SIGLA string State's initials.","title":"brazilstates.shp"},{"location":"base/data/#cabecadeboi-neighgpm","text":"Neighborhood files to be used with cabecadeboi database. File: cabecadeboi-neigh.gpm Connected file/layer: cabecadeboi900.shp Number of origins: 121 Number of connections: 1236 Source: TerraME team","title":"cabecadeboi-neigh.gpm"},{"location":"base/data/#cabecadeboishp","text":"Topography data from Cabeca de Boi mountain, Minas Gerais, Brazil, with 100x100m of resolution. Files: cabecadeboi.dbf , cabecadeboi.prj , cabecadeboi.shp , cabecadeboi.shx Representation: polygon Quantity: 8100 Projection: 'WGS 84 / TM 6 NE', with EPSG: 2311 (PROJ4: '+proj=tmerc +lat_0=0 +lon_0=6 +k=0.9996 +x_0=500000 +y_0=0 +datum=WGS84 +units=m +no_defs') Source: This data is a copy of the file with the same name created by terralib package. Attribute Type Description col number Cell's column. height number Height of the Cell, measured in values between 0 and 255. id string Unique identifier (internal value). row number Cell's row.","title":"cabecadeboi.shp"},{"location":"base/data/#cabecadeboi800shp","text":"Topography data from Cabeca de Boi mountain, Minas Gerais, Brazil, with 800x800m of resolution. Files: cabecadeboi800.dbf , cabecadeboi800.prj , cabecadeboi800.shp , cabecadeboi800.shx Representation: polygon Quantity: 144 Projection: 'NAD83', with EPSG: 4269 (PROJ4: '+proj=longlat +datum=NAD83 +no_defs') Source: This data is a copy of cabecadeboi created by terralib package, using a resolution of 800m. Attribute Type Description col number Cell's column. height number Height of the Cell, measured in values between 0 and 255. id string Unique identifier (internal value). row number Cell's row.","title":"cabecadeboi800.shp"},{"location":"base/data/#emasshp","text":"Cellular data representing Emas National Park, Brazil. It has 500x500m of resolution. Files: emas.dbf , emas.prj , emas.shp , emas.shx Representation: polygon Quantity: 5514 Projection: 'USER:900915', with EPSG: 900915 (PROJ4: '+proj=utm +zone=22 +south +ellps=aust_SA +units=m +no_defs') Source: This data is a copy of the file with the same name created by terralib package. Reference: Almeida, Rodolfo M., et al. 'Simulando padroes de incendios no Parque Nacional das Emas, Estado de Goias, Brasil.' X Simposio Brasileiro de Geoinformatica (2008) Attribute Type Description col number Cell's column. firebreak number Cell has a firebreak (1) or not (0). id string Unique identifier (internal value). maxcover number A value between 1 and 5 with the maximum value for the forest cover according to the original data with lower resolution. mincover number A value between 1 and 5 with the minimum value for the forest cover according to the original data with lower resolution. river number Cell has a river (1) or not (0). row number Cell's row.","title":"emas.shp"},{"location":"base/data/#gpmlinesdbemasgpm","text":"Neighborhood files to be used with emas database. File: gpmlinesDbEmas.gpm Connected files/layers: emas.shp and river.shp Number of origins: 1435 Number of connections: 623 Source: TerraME team","title":"gpmlinesDbEmas.gpm"},{"location":"base/data/#rivershp","text":"A line describing a river within Emas National Park, in Goias, Brazil. Files: river.dbf , river.shp , river.shx Representation: line Quantity: 208 Projection: Undefined, with EPSG: 0 (PROJ4: Undefined) Source: Rodolfo Almeida","title":"river.shp"},{"location":"base/data/#simplepgm","text":"A simple CellularSpace with one attribute for sugarscape model. File: simple.pgm Source: TerraME team","title":"simple.pgm"},{"location":"base/data/#test","text":"Directory with files used only for internal tests. This directory is not available within TerraME installer, but it can be downloaded from GitHub. Files: 36 Extensions: csv, dbf, gal, gpm, gwt, prj, qix, shp, shx Source: TerraME team","title":"test"},{"location":"base/examples/","text":"Examples barros Implementation of Barros urban dynamics model. beer Implementation of beer economic chain model. continuous-rain A simple continuous rain model. deforestation Amazonia deforestation models. discrete-rain A simple discrete rain model. drainage A simple drainage model. el-farol Implementation of El Farol model. fire-spread A simple spread model that uses geospatial data. game-of-life Implementation of Conway's Game of Life. growing-moving-society A model with 100 moving and growing Agents. growing-society A model with static Agents that can reproduce to neighbor Cells. ipd Iterated Prisoner's dilemma model. leontief Implementation of a model to study scenarios for the economy of Southeast Para state. predator-prey Implementation of a spatial predator-prey model. runoff Implementation of a simple runoff model using geospatial data. schelling Implementation of Schelling's segregation model. single-agent A simple example with one Agent that moves randomly in space. single-agents-society Simulation of a Society with 30 moving Agents. sir-abm SIR model implemented with agents. sir-basic A simple Susceptible-Infected-Recovered (SIR) model. sir-campaign A Susceptible-Infected-Recovered (SIR) model with a public campaign. sir-improved A Susceptible-Infected-Recovered (SIR) model. spatial-game Implementation of the model proposed by Nowak and Sigmund. tube-discrete A model that describes water flowing out of a tube. tube-inflow-outflow A model that describes water flowing in and out of a tube. tube A simple model that describes water flowing out of a tube. barros Implementation of Barros urban dynamics model. It simulates a virtual city composed by poor, middle class, and rich people. The simulation starts with the city having only one inhabitant in the center of space. At each time step, a new inhabitant arrives in the center. As it is not possible to have more than one inhabitant in the same cell, the arriving inhabitants with higher income can replace those with lower income, which in turn need to search for a new cell to leave, moving randomly. Empty cells can be occupied by any kind of agent. Reference: Barros, J. \"Simulating urban dynamics in Latin American cities.\" GeoDynamics (2005): 313-328. Arguments (global variables) P_POOR : Percentage of poor agents. P_MIDDLE : Percentage of middle class agents. P_RICH : Percentage of rich agents. Note that the sum of the three percentages must be one. DIM : The x and y dimensions of space. AGENTS : The number of agents in the simulation. beer Implementation of beer economic chain model. This model represents an economic chain with a manufacturer, some intermediate nodes (such as a distributor and a supplier), and a retailer. The agents in the economic chain need to fill their demand by requesting beer to the previous agent of the chain. The retailer has a random demand, while the others have a demand requested by the next agent of the chain. Each requested beer takes three time steps to be delivered from one agent to the next one (as long as there is some stock to fulfil the demand). The objective of the game is to minimize expenditure from back orders and inventory. For more information, see https://en.wikipedia.org/wiki/Beer_distribution_game. Arguments (global variables) NUMBER_OF_AGENTS : Number of agents in the chain, excluding the manufacturer and the retailer. The default value is three. continuous-rain A simple continuous rain model. It uses three differential equations to simulate rain, soil water, and drainage dynamics. Arguments (global variables) C : The amount of rain per unit of time. The default value is 2. K : The flow coefficient. The default value is 0.4. dt : The step used in the numerical integration. The default value is 0.01. deforestation Amazonia deforestation models. It uses a top-down approach with three strategies to compute deforestation potential. The first strategy compute the deforestation potential based on the deforestation of neighbor cells. The second one uses the result of a statistical regression using distance to urban areas, connection to markets, and coverage of protected areas as parameters. The last strategies mixes the other two. It adds the average deforestation of the neighborhood to the statistical regression. discrete-rain A simple discrete rain model. It simply computes the amount of water according to the rain and a flow coefficient. Arguments (global variables) C : The amount of rain per unit of time. The default value is 2. K : The flow coefficient. The default value is 0.4. drainage A simple drainage model. It uses a Chart to show the output of the simulation. el-farol Implementation of El Farol model. It is based on Brian Arthur's paper available at http://www.santafe.edu/~wbarthur/Papers/El_Farol. In this model, there is a city with a given population. Everybody wants to go to an entertainment offered once a week by a bar called El Farol. However, if the bar is too crowded, it is not enjoyable. Each agent decides on whether to go to the bar based on its expectations on how much people the bar will have. Decisions are taken independently from each other. Agents can have different ways of thinking, based on the amount of people that went to the bar in the last weeks. Arguments (global variables) N : Number of people in the city. The default value is 100. K : number of strategies each individual has (if only one then the agent will never change its strategy). The default value is 3. MAX : Maximum number of people in the bar. The default value is 60. fire-spread A simple spread model that uses geospatial data. It simulates a fire in Parque Nacional das Emas, in Goias state, Brazil. It has probabilities for fire spread according to the biomass stored in each cell. This model was proposed by Almeida, Rodolfo M., et al. (in portuguese) 'Simulando padroes de incendios no Parque Nacional das Emas, Estado de Goias, Brasil.' X Simposio Brasileiro de Geoinfoamatica (2008). Arguments (global variables) STEPS : The final simulation time. The default value is 35. game-of-life Implementation of Conway's Game of Life. It is a classical Cellular Automata model that simulates changes in a society using very simple rules. Each cell represents an individual that can have two states: alive or dead. Using its own state and the state of its neighbors, each individual decides its next state. The model has four rules. First, an alive cell with fewer than two alive neighbors dies by loneliness. Second, an alive cell with two or three alive neighbors stays alive. Third, an alive cell with more than three alive neighbors dies by over-population. Fourth, a dead cell with three alive neighbors becomes alive by reproduction. This implementation creates the initial distribution of alive cells randomly. For more information, see https://en.wikipedia.org/wiki/Conway 's_Game_of_Life. Arguments (global variables) PROBABILITY : The probability of a Cell to be alive in the beginning of the simulation. The default value is 0.15. TURNS : The number of simulation steps. The default value is 20. growing-moving-society A model with 100 moving and growing Agents. An Agent moves to an empty random cell in each time step and reproduces if it finds another empty random cell, given a probability. Arguments (global variables) GROWTH_PROB : The probability of an agent to reproduce in an empty neighbor cell. The default value is 0.3. growing-society A model with static Agents that can reproduce to neighbor Cells. An Agent reproduces if it finds another empty random cell, given a probability. Arguments (global variables) GROWTH_PROB : The probability of an agent to reproduce in an empty neighbor cell. The default value is 0.3. ipd Iterated Prisoner's dilemma model. It implements a championship with a set of Agents where they play with each other a non-cooperative game repeatedly. Some of the available strategies are Pavlov and Tit-for-tat. In the end, the model shows the results for each strategy. For more information, see Axelrod, R. (1984) The Evolution of Cooperation. Basic Books. See also Nowak, M., and Sigmund, K. (1993) A strategy of win-stay, lose-shift that outperforms tit-for-tat in the Prisoner's Dilemma game. Nature 364.6432: 56-58. Arguments (global variables) TURNS : The number of times an Agent plays with each opponent. CHAMPIONSHIP : A vector with the strategies used in the championship. leontief Implementation of a model to study scenarios for the economy of Southeast Para state. This model solves the inversion of an input-output matrix using an agent-based model. It implements a set of investment scenarios for the region and simulates the impacts over salaries, employment, and carbon emissions. For more information, see Andrade et al. (2010) From input-output matrixes to agent-based models: A case study on carbon credits in a local economy. BWSS 2010. Arguments (global variables) scenario : Number of the scenario. It can be an integer value between 1 and 5. The default value is 1. predator-prey Implementation of a spatial predator-prey model. This model has two Societies. One composed by preys that feed grass and the other composed by predators that feed preys. Agents move randomly in space and can reproduce. The output is similar to Lotka-Volterra equations. runoff Implementation of a simple runoff model using geospatial data. There is an initial rain in the highest cells. The Neighborhood of a Cell is composed by its Moore neighbors that have lower height. Each cell then sends its water equally to all neighbors. schelling Implementation of Schelling's segregation model. In this model, a Society is composed by two types of Agents, reds and blacks, which live in Cells. Each Agent is happy if its neighborhood has at least a given number of Agents sharing its type. Otherwise, it will try to move to another place where it is satisfied. Using this model, Thomas Schelling showed that a small preference for one's neighbors to be of the same color could lead to total segregation. For more information, see Schelling, T. (1971) Dynamic models of seggregation, Journal of Mathematical Sociology 1:143-186. Arguments (global variables) NDIM : Space dimensions in x and y axis. PREFERENCE : Agent contentedness, indicating the minimum number of neighbors of the same color to make the agent satisfied. It should be an integer number between 3 and 5. NAGTS : The proportion of agents in space. MAX_TURNS : Maximum number of simulation steps. single-agent A simple example with one Agent that moves randomly in space. single-agents-society Simulation of a Society with 30 moving Agents. sir-abm SIR model implemented with agents. This model needs to have more implementation decisions if compared to one implemented using system dynamics. The social network of an agent is fixed? In a system dynamics model it supposes that the network is not fixed as disease is propagated to the whole population using probabilities. Another question: an agent that has got sick in a given time step can infect other agents? This implementation supposes it can only infect in the next time step. sir-basic A simple Susceptible-Infected-Recovered (SIR) model. This model represents a given disease that propagates over a population. It starts with a small number of infected that passes the disease to the susceptible ones. After some time, infected become recovered, which cannot be infected again. For mode details visit http://en.wikipedia.org/wiki/Epidemic_model. sir-campaign A Susceptible-Infected-Recovered (SIR) model with a public campaign. The campaign asks the population to stop leaving home, which reduces the number of contacts by half. It is activated whenever there are more than 1000 infected individuous in the population. sir-improved A Susceptible-Infected-Recovered (SIR) model. In this model the disease has a duration of 8 weeks. We can see that the maximum number of infected is proportional to the duration of the disease. spatial-game Implementation of the model proposed by Nowak and Sigmund. In this model, each Cell has a strategy and plays a non-cooperative game with its neighbors. Then it updates its strategy with the most successful one among its neighbors. This simple spatial game produces a very complex spatial dynamics such as kaleidoscopes and dynamic fractals. Reference: Nowak and Sigmund (2004) Evolutionary Dynamics of Biological Games, Science 303(5659):793-799. Arguments (global variables) N : Space dimensions in x and y axis. TURNS : Number of simulation steps. tube-discrete A model that describes water flowing out of a tube. It uses an observation step more frequent than the execution. Because of that, we can see that the water flows out of the tube in discrete steps. tube-inflow-outflow A model that describes water flowing in and out of a tube. This implementation also verifies does not allow to have negative amounts of water in the tube. tube A simple model that describes water flowing out of a tube.","title":"Examples"},{"location":"base/examples/#examples","text":"barros Implementation of Barros urban dynamics model. beer Implementation of beer economic chain model. continuous-rain A simple continuous rain model. deforestation Amazonia deforestation models. discrete-rain A simple discrete rain model. drainage A simple drainage model. el-farol Implementation of El Farol model. fire-spread A simple spread model that uses geospatial data. game-of-life Implementation of Conway's Game of Life. growing-moving-society A model with 100 moving and growing Agents. growing-society A model with static Agents that can reproduce to neighbor Cells. ipd Iterated Prisoner's dilemma model. leontief Implementation of a model to study scenarios for the economy of Southeast Para state. predator-prey Implementation of a spatial predator-prey model. runoff Implementation of a simple runoff model using geospatial data. schelling Implementation of Schelling's segregation model. single-agent A simple example with one Agent that moves randomly in space. single-agents-society Simulation of a Society with 30 moving Agents. sir-abm SIR model implemented with agents. sir-basic A simple Susceptible-Infected-Recovered (SIR) model. sir-campaign A Susceptible-Infected-Recovered (SIR) model with a public campaign. sir-improved A Susceptible-Infected-Recovered (SIR) model. spatial-game Implementation of the model proposed by Nowak and Sigmund. tube-discrete A model that describes water flowing out of a tube. tube-inflow-outflow A model that describes water flowing in and out of a tube. tube A simple model that describes water flowing out of a tube.","title":"Examples"},{"location":"base/examples/#barros","text":"Implementation of Barros urban dynamics model. It simulates a virtual city composed by poor, middle class, and rich people. The simulation starts with the city having only one inhabitant in the center of space. At each time step, a new inhabitant arrives in the center. As it is not possible to have more than one inhabitant in the same cell, the arriving inhabitants with higher income can replace those with lower income, which in turn need to search for a new cell to leave, moving randomly. Empty cells can be occupied by any kind of agent. Reference: Barros, J. \"Simulating urban dynamics in Latin American cities.\" GeoDynamics (2005): 313-328.","title":"barros"},{"location":"base/examples/#arguments-global-variables","text":"P_POOR : Percentage of poor agents. P_MIDDLE : Percentage of middle class agents. P_RICH : Percentage of rich agents. Note that the sum of the three percentages must be one. DIM : The x and y dimensions of space. AGENTS : The number of agents in the simulation.","title":"Arguments (global variables)"},{"location":"base/examples/#beer","text":"Implementation of beer economic chain model. This model represents an economic chain with a manufacturer, some intermediate nodes (such as a distributor and a supplier), and a retailer. The agents in the economic chain need to fill their demand by requesting beer to the previous agent of the chain. The retailer has a random demand, while the others have a demand requested by the next agent of the chain. Each requested beer takes three time steps to be delivered from one agent to the next one (as long as there is some stock to fulfil the demand). The objective of the game is to minimize expenditure from back orders and inventory. For more information, see https://en.wikipedia.org/wiki/Beer_distribution_game.","title":"beer"},{"location":"base/examples/#arguments-global-variables_1","text":"NUMBER_OF_AGENTS : Number of agents in the chain, excluding the manufacturer and the retailer. The default value is three.","title":"Arguments (global variables)"},{"location":"base/examples/#continuous-rain","text":"A simple continuous rain model. It uses three differential equations to simulate rain, soil water, and drainage dynamics.","title":"continuous-rain"},{"location":"base/examples/#arguments-global-variables_2","text":"C : The amount of rain per unit of time. The default value is 2. K : The flow coefficient. The default value is 0.4. dt : The step used in the numerical integration. The default value is 0.01.","title":"Arguments (global variables)"},{"location":"base/examples/#deforestation","text":"Amazonia deforestation models. It uses a top-down approach with three strategies to compute deforestation potential. The first strategy compute the deforestation potential based on the deforestation of neighbor cells. The second one uses the result of a statistical regression using distance to urban areas, connection to markets, and coverage of protected areas as parameters. The last strategies mixes the other two. It adds the average deforestation of the neighborhood to the statistical regression.","title":"deforestation"},{"location":"base/examples/#discrete-rain","text":"A simple discrete rain model. It simply computes the amount of water according to the rain and a flow coefficient.","title":"discrete-rain"},{"location":"base/examples/#arguments-global-variables_3","text":"C : The amount of rain per unit of time. The default value is 2. K : The flow coefficient. The default value is 0.4.","title":"Arguments (global variables)"},{"location":"base/examples/#drainage","text":"A simple drainage model. It uses a Chart to show the output of the simulation.","title":"drainage"},{"location":"base/examples/#el-farol","text":"Implementation of El Farol model. It is based on Brian Arthur's paper available at http://www.santafe.edu/~wbarthur/Papers/El_Farol. In this model, there is a city with a given population. Everybody wants to go to an entertainment offered once a week by a bar called El Farol. However, if the bar is too crowded, it is not enjoyable. Each agent decides on whether to go to the bar based on its expectations on how much people the bar will have. Decisions are taken independently from each other. Agents can have different ways of thinking, based on the amount of people that went to the bar in the last weeks.","title":"el-farol"},{"location":"base/examples/#arguments-global-variables_4","text":"N : Number of people in the city. The default value is 100. K : number of strategies each individual has (if only one then the agent will never change its strategy). The default value is 3. MAX : Maximum number of people in the bar. The default value is 60.","title":"Arguments (global variables)"},{"location":"base/examples/#fire-spread","text":"A simple spread model that uses geospatial data. It simulates a fire in Parque Nacional das Emas, in Goias state, Brazil. It has probabilities for fire spread according to the biomass stored in each cell. This model was proposed by Almeida, Rodolfo M., et al. (in portuguese) 'Simulando padroes de incendios no Parque Nacional das Emas, Estado de Goias, Brasil.' X Simposio Brasileiro de Geoinfoamatica (2008).","title":"fire-spread"},{"location":"base/examples/#arguments-global-variables_5","text":"STEPS : The final simulation time. The default value is 35.","title":"Arguments (global variables)"},{"location":"base/examples/#game-of-life","text":"Implementation of Conway's Game of Life. It is a classical Cellular Automata model that simulates changes in a society using very simple rules. Each cell represents an individual that can have two states: alive or dead. Using its own state and the state of its neighbors, each individual decides its next state. The model has four rules. First, an alive cell with fewer than two alive neighbors dies by loneliness. Second, an alive cell with two or three alive neighbors stays alive. Third, an alive cell with more than three alive neighbors dies by over-population. Fourth, a dead cell with three alive neighbors becomes alive by reproduction. This implementation creates the initial distribution of alive cells randomly. For more information, see https://en.wikipedia.org/wiki/Conway 's_Game_of_Life.","title":"game-of-life"},{"location":"base/examples/#arguments-global-variables_6","text":"PROBABILITY : The probability of a Cell to be alive in the beginning of the simulation. The default value is 0.15. TURNS : The number of simulation steps. The default value is 20.","title":"Arguments (global variables)"},{"location":"base/examples/#growing-moving-society","text":"A model with 100 moving and growing Agents. An Agent moves to an empty random cell in each time step and reproduces if it finds another empty random cell, given a probability.","title":"growing-moving-society"},{"location":"base/examples/#arguments-global-variables_7","text":"GROWTH_PROB : The probability of an agent to reproduce in an empty neighbor cell. The default value is 0.3.","title":"Arguments (global variables)"},{"location":"base/examples/#growing-society","text":"A model with static Agents that can reproduce to neighbor Cells. An Agent reproduces if it finds another empty random cell, given a probability.","title":"growing-society"},{"location":"base/examples/#arguments-global-variables_8","text":"GROWTH_PROB : The probability of an agent to reproduce in an empty neighbor cell. The default value is 0.3.","title":"Arguments (global variables)"},{"location":"base/examples/#ipd","text":"Iterated Prisoner's dilemma model. It implements a championship with a set of Agents where they play with each other a non-cooperative game repeatedly. Some of the available strategies are Pavlov and Tit-for-tat. In the end, the model shows the results for each strategy. For more information, see Axelrod, R. (1984) The Evolution of Cooperation. Basic Books. See also Nowak, M., and Sigmund, K. (1993) A strategy of win-stay, lose-shift that outperforms tit-for-tat in the Prisoner's Dilemma game. Nature 364.6432: 56-58.","title":"ipd"},{"location":"base/examples/#arguments-global-variables_9","text":"TURNS : The number of times an Agent plays with each opponent. CHAMPIONSHIP : A vector with the strategies used in the championship.","title":"Arguments (global variables)"},{"location":"base/examples/#leontief","text":"Implementation of a model to study scenarios for the economy of Southeast Para state. This model solves the inversion of an input-output matrix using an agent-based model. It implements a set of investment scenarios for the region and simulates the impacts over salaries, employment, and carbon emissions. For more information, see Andrade et al. (2010) From input-output matrixes to agent-based models: A case study on carbon credits in a local economy. BWSS 2010.","title":"leontief"},{"location":"base/examples/#arguments-global-variables_10","text":"scenario : Number of the scenario. It can be an integer value between 1 and 5. The default value is 1.","title":"Arguments (global variables)"},{"location":"base/examples/#predator-prey","text":"Implementation of a spatial predator-prey model. This model has two Societies. One composed by preys that feed grass and the other composed by predators that feed preys. Agents move randomly in space and can reproduce. The output is similar to Lotka-Volterra equations.","title":"predator-prey"},{"location":"base/examples/#runoff","text":"Implementation of a simple runoff model using geospatial data. There is an initial rain in the highest cells. The Neighborhood of a Cell is composed by its Moore neighbors that have lower height. Each cell then sends its water equally to all neighbors.","title":"runoff"},{"location":"base/examples/#schelling","text":"Implementation of Schelling's segregation model. In this model, a Society is composed by two types of Agents, reds and blacks, which live in Cells. Each Agent is happy if its neighborhood has at least a given number of Agents sharing its type. Otherwise, it will try to move to another place where it is satisfied. Using this model, Thomas Schelling showed that a small preference for one's neighbors to be of the same color could lead to total segregation. For more information, see Schelling, T. (1971) Dynamic models of seggregation, Journal of Mathematical Sociology 1:143-186.","title":"schelling"},{"location":"base/examples/#arguments-global-variables_11","text":"NDIM : Space dimensions in x and y axis. PREFERENCE : Agent contentedness, indicating the minimum number of neighbors of the same color to make the agent satisfied. It should be an integer number between 3 and 5. NAGTS : The proportion of agents in space. MAX_TURNS : Maximum number of simulation steps.","title":"Arguments (global variables)"},{"location":"base/examples/#single-agent","text":"A simple example with one Agent that moves randomly in space.","title":"single-agent"},{"location":"base/examples/#single-agents-society","text":"Simulation of a Society with 30 moving Agents.","title":"single-agents-society"},{"location":"base/examples/#sir-abm","text":"SIR model implemented with agents. This model needs to have more implementation decisions if compared to one implemented using system dynamics. The social network of an agent is fixed? In a system dynamics model it supposes that the network is not fixed as disease is propagated to the whole population using probabilities. Another question: an agent that has got sick in a given time step can infect other agents? This implementation supposes it can only infect in the next time step.","title":"sir-abm"},{"location":"base/examples/#sir-basic","text":"A simple Susceptible-Infected-Recovered (SIR) model. This model represents a given disease that propagates over a population. It starts with a small number of infected that passes the disease to the susceptible ones. After some time, infected become recovered, which cannot be infected again. For mode details visit http://en.wikipedia.org/wiki/Epidemic_model.","title":"sir-basic"},{"location":"base/examples/#sir-campaign","text":"A Susceptible-Infected-Recovered (SIR) model with a public campaign. The campaign asks the population to stop leaving home, which reduces the number of contacts by half. It is activated whenever there are more than 1000 infected individuous in the population.","title":"sir-campaign"},{"location":"base/examples/#sir-improved","text":"A Susceptible-Infected-Recovered (SIR) model. In this model the disease has a duration of 8 weeks. We can see that the maximum number of infected is proportional to the duration of the disease.","title":"sir-improved"},{"location":"base/examples/#spatial-game","text":"Implementation of the model proposed by Nowak and Sigmund. In this model, each Cell has a strategy and plays a non-cooperative game with its neighbors. Then it updates its strategy with the most successful one among its neighbors. This simple spatial game produces a very complex spatial dynamics such as kaleidoscopes and dynamic fractals. Reference: Nowak and Sigmund (2004) Evolutionary Dynamics of Biological Games, Science 303(5659):793-799.","title":"spatial-game"},{"location":"base/examples/#arguments-global-variables_12","text":"N : Space dimensions in x and y axis. TURNS : Number of simulation steps.","title":"Arguments (global variables)"},{"location":"base/examples/#tube-discrete","text":"A model that describes water flowing out of a tube. It uses an observation step more frequent than the execution. Because of that, we can see that the water flows out of the tube in discrete steps.","title":"tube-discrete"},{"location":"base/examples/#tube-inflow-outflow","text":"A model that describes water flowing in and out of a tube. This implementation also verifies does not allow to have negative amounts of water in the tube.","title":"tube-inflow-outflow"},{"location":"base/examples/#tube","text":"A simple model that describes water flowing out of a tube.","title":"tube"},{"location":"base/font/","text":"Font Chess Chess icons. Grissom Free Intellecta Design makes research and development of fonts with historical and artistical relevant forms. JLS Smiles Sampler Font by Michael Adkins & James Stirling. LL Faces Head faces of different sizes and internal content. Pet Animals Pet animals by Zdravko Andreev, aka Z-Designs. Pregnancy Pregnancy icons. Science Some science objects and symbols. Freaky Face Some faces with different number of eyes. Ubuntu The Ubuntu Font Family are a set of matching new libre/open fonts. Chess File: CHEQ_TT.ttf Summary: Chess icons. Source: https://www.dafont.com/chess.font Symbols: Grissom Free File: Grissom Free.ttf Summary: Intellecta Design makes research and development of fonts with historical and artistical relevant forms. This font is a FREE software for personal and non-commercial use only. Source: http://www.dafont.com/grissom.font Symbols: JLS Smiles Sampler File: JLS Smiles Sampler.ttf Summary: Font by Michael Adkins & James Stirling. \"Have a nice day!\" I can remember that motto and the smiley face from childhood. It was friendly, optimistic little image that became an icon. These days it has been updated and is a collection of emoticons used by cultures world wide. The smiley face can now be friendly, sad, happy, angry, etc. This collection is our fun expression of the smiley face. Source: http://www.dafont.com/jls-smiles-sampler.font Symbols: LL Faces File: LLFACES2.ttf Summary: Head faces of different sizes and internal content. Source: https://www.dafont.com/llfaces.font Symbols: Pet Animals File: Pet Animals.ttf Summary: Pet animals by Zdravko Andreev, aka Z-Designs. This font is free for personal and non-commercial use. Source: http://www.dafont.com/pet-animals.font Symbols: Pregnancy File: Pregnancy.ttf Summary: Pregnancy icons. Source: https://www.dafont.com/pregnancy.font Symbols: Science File: Science Icons.ttf Summary: Some science objects and symbols. Source: https://dl.dafont.com/dl/?f=science Symbols: Freaky Face File: TheFreakyFace.ttf Summary: Some faces with different number of eyes. Source: https://www.dafont.com/the-freaky-face.font Symbols: Ubuntu File: Ubuntu-L.ttf Summary: The Ubuntu Font Family are a set of matching new libre/open fonts. The development is being funded by Canonical on behalf the wider Free Software community and the Ubuntu project. The technical font design work and implementation is being undertaken by Dalton Maag. This font is used in every window displayed by TerraME. Source: http://font.ubuntu.com Symbols:","title":"Font"},{"location":"base/font/#font","text":"Chess Chess icons. Grissom Free Intellecta Design makes research and development of fonts with historical and artistical relevant forms. JLS Smiles Sampler Font by Michael Adkins & James Stirling. LL Faces Head faces of different sizes and internal content. Pet Animals Pet animals by Zdravko Andreev, aka Z-Designs. Pregnancy Pregnancy icons. Science Some science objects and symbols. Freaky Face Some faces with different number of eyes. Ubuntu The Ubuntu Font Family are a set of matching new libre/open fonts.","title":"Font"},{"location":"base/font/#chess","text":"File: CHEQ_TT.ttf Summary: Chess icons. Source: https://www.dafont.com/chess.font Symbols:","title":"Chess"},{"location":"base/font/#grissom-free","text":"File: Grissom Free.ttf Summary: Intellecta Design makes research and development of fonts with historical and artistical relevant forms. This font is a FREE software for personal and non-commercial use only. Source: http://www.dafont.com/grissom.font Symbols:","title":"Grissom Free"},{"location":"base/font/#_1","text":"","title":""},{"location":"base/font/#jls-smiles-sampler","text":"File: JLS Smiles Sampler.ttf Summary: Font by Michael Adkins & James Stirling. \"Have a nice day!\" I can remember that motto and the smiley face from childhood. It was friendly, optimistic little image that became an icon. These days it has been updated and is a collection of emoticons used by cultures world wide. The smiley face can now be friendly, sad, happy, angry, etc. This collection is our fun expression of the smiley face. Source: http://www.dafont.com/jls-smiles-sampler.font Symbols:","title":"JLS Smiles Sampler"},{"location":"base/font/#ll-faces","text":"File: LLFACES2.ttf Summary: Head faces of different sizes and internal content. Source: https://www.dafont.com/llfaces.font Symbols:","title":"LL Faces"},{"location":"base/font/#pet-animals","text":"File: Pet Animals.ttf Summary: Pet animals by Zdravko Andreev, aka Z-Designs. This font is free for personal and non-commercial use. Source: http://www.dafont.com/pet-animals.font Symbols:","title":"Pet Animals"},{"location":"base/font/#pregnancy","text":"File: Pregnancy.ttf Summary: Pregnancy icons. Source: https://www.dafont.com/pregnancy.font Symbols:","title":"Pregnancy"},{"location":"base/font/#science","text":"File: Science Icons.ttf Summary: Some science objects and symbols. Source: https://dl.dafont.com/dl/?f=science Symbols:","title":"Science"},{"location":"base/font/#freaky-face","text":"File: TheFreakyFace.ttf Summary: Some faces with different number of eyes. Source: https://www.dafont.com/the-freaky-face.font Symbols:","title":"Freaky Face"},{"location":"base/font/#ubuntu","text":"File: Ubuntu-L.ttf Summary: The Ubuntu Font Family are a set of matching new libre/open fonts. The development is being funded by Canonical on behalf the wider Free Software community and the Ubuntu project. The technical font design work and implementation is being undertaken by Dalton Maag. This font is used in every window displayed by TerraME. Source: http://font.ubuntu.com Symbols:","title":"Ubuntu"},{"location":"base/functions/errorHandling/","text":"ErrorHandling Some basic and useful functions to handle errors and error messages. Functions customError Stop the simulation with an error. customWarning Print a warning. defaultTableValue Verify the default value of a given attribute of a named table. defaultValueMsg Return a message indicating that the modeler is using the default value for a given argument and therefore it could be removed. defaultValueWarning Show a strict warning if the attribute of a table has the default value. deprecatedFunction Show an error indicating a deprecated function. deprecatedFunctionMsg Return a message indicating that a function is deprecated and must be replaced. incompatibleTypeError Stop the simulation with an error of a wrong type for an argument of a function. incompatibleTypeMsg Return an error message for incompatible types. incompatibleValueError Stop the simulation with an error of a wrong value for an argument of a function. incompatibleValueMsg Return an error message for incompatible values. integerArgument Verify whether a given argument is integer. integerArgumentMsg Return a message indicating that a given argument of a function should be integer. integerTableArgument Verify whether a given argument of a named function is integer. invalidFileExtensionError Stop the simulation with an error indicating that the function does not support a given file extension. invalidFileExtensionMsg Return a message indicating that a given file extension is incompatible. mandatoryArgument Verify whether a given argument of a function with non-named arguments belongs to the correct type. mandatoryArgumentError Stop the simulation with an error indicating that a given argument is mandatory. mandatoryArgumentMsg Return a message indicating that a given argument of a function is mandatory. mandatoryTableArgument Verify whether a named table contains a mandatory argument. namedArgumentsMsg Return a message indicating that the arguments of a function must be named. optionalArgument Verify whether an optional argument of a function with non-named arguments belongs to the correct type. optionalTableArgument Verify whether a named table contains an optional argument. positiveArgument Verify whether a given argument is positive. positiveArgumentMsg Return a message indicating that a given argument of a function should be positive. positiveTableArgument Verify whether a given argument of a function with named arguments is positive. resourceNotFoundError Stop the simulation with an error indicating that a given resource was not found. resourceNotFoundMsg Return a message indicating that a given resource could not be found. strictWarning Print a strict warning. suggestion Return a suggestion for a wrong string value. suggestionMsg Return the arguments of suggestion within a question \" Do you mean '#1'?\". switchInvalidArgument Stop the simulation with an error because the user did not choose a correct option. switchInvalidArgumentMsg Return a message for a wrong argument value showing the options. switchInvalidArgumentSuggestionMsg Return a message for a wrong argument value showing the most similar option. tableArgumentMsg Return a message indicating that the argument of a function must be a table. unnecessaryArgumentMsg Return a message indicating that a given argument is unnecessary. valueNotFoundError Stop the simulation with an error due to a wrong value for an argument. valueNotFoundMsg Return a message indicating that a given argument of a function is mandatory. verify Verify a given condition, otherwise it stops the simulation with an error. verifyNamedTable Verify if a given object is a named table. verifyUnnecessaryArguments Verify whether the user has passed only the allowed arguments for a function, removing the unnecessary arguments and showing a strict warning otherwise. customError Stop the simulation with an error. Arguments #1 : A string describing the error message. Usage _, err = pcall(function() customError(\"error message\") end) print(err) customWarning Print a warning. If TerraME is executing in the debug mode, it stops the simulation with an error. Arguments #1 : A string describing the warning. Usage customWarning(\"warning message\") defaultTableValue Verify the default value of a given attribute of a named table. It adds the attribute with the default value in the table if it does not exist, stops with an error ( incompatibleTypeMsg() ) if the value has a different type, or shows a warning ( defaultValueWarning() ) if it is equal to the default value. Arguments #1 : A named table (which can be an argument for a function). #2 : A string with the name of an attribute (or argument) from #1. #3 : The default value (any type). Usage function integrate(attrs) defaultTableValue(attrs, \"method\", \"euler\") return attrs end t = integrate{} print(t.method) defaultValueMsg Return a message indicating that the modeler is using the default value for a given argument and therefore it could be removed. The string is \"Argument '#1' could be removed as it is the default value ('#2').\". Arguments #1 : A string with the name of the argument. #2 : A number or string or boolean value with the default value for the argument. Usage str = defaultValueMsg(\"dbtype\", \"mysql\") print(str) defaultValueWarning Show a strict warning if the attribute of a table has the default value. If TerraME is running in the debug mode, the simulation stops with an error. The warning message comes from defaultValueMsg() . Arguments #1 : A string with the name of the argument. #2 : The default value. Usage str = defaultValueWarning(\"size\", 2) print(str) deprecatedFunction Show an error indicating a deprecated function. The error comes from deprecatedFunctionMsg() . Arguments #1 : A string with the name of the deprecated function. #2 : A string indicating how to proceed to replace the deprecated function call. Usage deprecatedFunc = function() deprecatedFunction(\"abc\", \"def\") end _, err = pcall(function() deprecatedFunc() end) print(err) deprecatedFunctionMsg Return a message indicating that a function is deprecated and must be replaced. The string is \"Function '#1' is deprecated. Use '#2' instead.\". Arguments #1 : A string with the name of the deprecated function. #2 : A string indicating how to proceed to replace the deprecated function call. Usage str = deprecatedFunctionMsg(\"abc\", \"def\") print(str) incompatibleTypeError Stop the simulation with an error of a wrong type for an argument of a function. The error message is the return value of incompatibleTypeMsg() . Arguments #1 : A string with the name of the argument, or a number with its the position. #2 : A string with the possible type (or types). #3 : The value wrongly passed as argument. Usage _, err = pcall(function() incompatibleTypeError(\"cell\", \"Cell\", Agent{}) end) print(err) incompatibleTypeMsg Return an error message for incompatible types. The string is \"Incompatible types. Argument '#1' expected #2, got type(#3).\". Arguments #1 : A string with the name of the argument, or a number with its the position. #2 : A string with the possible type (or types). The default value is \"nil\". #3 : The value wrongly passed as argument. Usage str = incompatibleTypeMsg(\"source\", \"string\", 2) print(str) incompatibleValueError Stop the simulation with an error of a wrong value for an argument of a function. The error message comes from incompatibleValueMsg() . Arguments #1 : A string with the name of the argument or a number with its position. #2 : A string with the expected value(s) for the argument. #3 : The value wrongly passed as argument. Usage _, err = pcall(function() incompatibleValueError(\"position\", \"one of {1, 2, 3}\", 4) end) print(err) incompatibleValueMsg Return an error message for incompatible values. The string is \"Incompatible values. Argument '#1' expected #2, got #3.\". Arguments #1 : A string with the name of the argument or a number with its position. #2 : A string with the expected value(s) for the argument. #3 : The value wrongly passed as argument. Usage str = incompatibleValueMsg(\"source\", \"one of {1, 3, 4}\", 2) print(str) integerArgument Verify whether a given argument is integer. It is useful only for functions with non-named arguments. The error message comes from integerArgumentMsg() . Arguments #1 : A number with the position of the argument in the function. #2 : The value used as argument to the function call. Usage sum = function(a, b) integerArgument(1, a) integerArgument(2, b) return a + b end _, err = pcall(function() sum(5) end) print(err) integerArgumentMsg Return a message indicating that a given argument of a function should be integer. It returns incompatibleValueMsg() with \"integer number\" as #2. Arguments #1 : A string with the name of the argument or a number with the position of the argument. #2 : The value used as argument to the function call. Usage str = integerArgumentMsg(\"target\", 7.4) print(str) str = integerArgumentMsg(2, 5.1) print(str) integerTableArgument Verify whether a given argument of a named function is integer. The error message comes from integerArgumentMsg() . Arguments #1 : A named table. #2 : A string with the name of the argument. Usage myFunction = function(mtable) integerTableArgument(mtable, \"value\") end _, err = pcall(function() myFunction{value = false} end) print(err) invalidFileExtensionError Stop the simulation with an error indicating that the function does not support a given file extension. The error message comes from invalidFileExtensionMsg() . Arguments #1 : A string with the name of the argument or a number with its position. #2 : A string with the incompatible file extension. Usage _, err = pcall(function() invalidFileExtensionError(\"file\", \".txt\") end) print(err) invalidFileExtensionMsg Return a message indicating that a given file extension is incompatible. The string is \"Argument '#1' does not support extension '#2'.\". Arguments #1 : A string with the name of the argument (for functions with named arguments), or its position (for functions with non-named arguments). #2 : A string with the incompatible file extension. Usage str = invalidFileExtensionMsg(\"file\", \"csv\") print(str) mandatoryArgument Verify whether a given argument of a function with non-named arguments belongs to the correct type. The error message comes from mandatoryArgumentMsg() and incompatibleTypeMsg() . Arguments #1 : A number with the position of the argument in the function. #2 : A string with the required type for the argument. #3 : The value used as argument to the function call. Usage myFunction = function(value) mandatoryArgument(1, \"string\", value) end _, err = pcall(function() myFunction(2) end) print(err) mandatoryArgumentError Stop the simulation with an error indicating that a given argument is mandatory. The error message comes from mandatoryArgumentMsg() . Arguments #1 : A string with name of the argument or a number with its position in the function. Usage _, err = pcall(function() mandatoryArgumentError(2) end) print(err) mandatoryArgumentMsg Return a message indicating that a given argument of a function is mandatory. The string is \"Argument '#1' is mandatory.\". Arguments #1 : The name of the argument. It can be a string or a number. Usage str = mandatoryArgumentMsg(\"target\") print(str) str = mandatoryArgumentMsg(2) print(str) mandatoryTableArgument Verify whether a named table contains a mandatory argument. It stops with an error if the value is nil or if it does not belong to the required type. The error message comes from mandatoryArgumentMsg() or incompatibleTypeMsg() . Arguments #1 : A named table. #2 : A string with the argument name. #3 : A string with the required type for the argument, or a vector of strings with the allowed types. This argument is optional. If not used, then this function will check only if the argument is not nil. Usage myFunction = function(mtable) mandatoryTableArgument(mtable, \"value\", \"string\") end _, err = pcall(function() myFunction{value = 2} end) print(err) namedArgumentsMsg Return a message indicating that the arguments of a function must be named. The string is \"Arguments must be named.\". Usage str = namedArgumentsMsg() print(str) optionalArgument Verify whether an optional argument of a function with non-named arguments belongs to the correct type. If the argument is nil then no error is created. The error message comes from incompatibleTypeMsg() . Arguments #1 : A number with the position of the argument in the function. #2 : A string with the required type for the argument. #3 : The value used as argument to the function call. Usage myFunction = function(value) optionalArgument(1, \"string\", value) end _, err = pcall(function() myFunction(2) end) print(err) optionalTableArgument Verify whether a named table contains an optional argument. It stops with an error if the value is not nil and it has a type different from the required type. The error comes from incompatibleTypeError() . Arguments #1 : A named table. #2 : A string with the name of the argument. #3 : A string with the required type for the argument or a table with strings describing the allowed types. Usage myFunction = function(mtable) optionalTableArgument(mtable, \"value\", \"string\") end _, err = pcall(function() myFunction{value = 2} end) print(err) positiveArgument Verify whether a given argument is positive. It is useful only for functions with non-named arguments. The error message comes from positiveArgumentMsg() . Arguments #1 : A number with the position of the argument in the function. #2 : The value used as argument to the function call. #3 : A boolean value indicating whether zero should be included (the default value is false). Usage positiveSum = function(a, b) positiveArgument(1, a) positiveArgument(2, b) return a + b end _, err = pcall(function() positiveSum(5, -2) end) print(err) positiveArgumentMsg Return a message indicating that a given argument of a function should be positive. It returns incompatibleValueMsg() with \"positive number (including/excluding zero)\" as #2. Arguments #1 : The name of the argument. It can be a string or a number. #2 : The value used as argument to the function call. #3 : A boolean value indicating whether zero should be included (the default value is false). Usage str = positiveArgumentMsg(\"target\", -5) print(str) str = positiveArgumentMsg(2, -2, true) print(str) positiveTableArgument Verify whether a given argument of a function with named arguments is positive. The error message comes from positiveArgumentMsg() . Arguments #1 : A named table. #2 : A string with the name of the argument. #3 : A boolean value indicating whether zero should be included (the default value is false). Usage myFunction = function(mtable) positiveTableArgument(mtable, \"value\") end _, err = pcall(function() myFunction{value = -2} end) print(err) resourceNotFoundError Stop the simulation with an error indicating that a given resource was not found. The error message comes from resourceNotFoundMsg() . Arguments #1 : A string with the name of the argument, or its position. #2 : A string with the location of the resource. Usage _, err = pcall(function() resourceNotFoundError(\"file\", \"file.txt\") end) print(err) resourceNotFoundMsg Return a message indicating that a given resource could not be found. The string is \" File /Resource '#1' was not found for argument '#2'.\". Arguments #1 : A string with the name of the argument, or its position. #2 : A File or a string with the location of the resource. Usage str = resourceNotFoundMsg(\"file\", \"c:\\\\myfiles\\\\file.csv\") print(str) strictWarning Print a strict warning. This warning is shown only in the strict mode. If TerraME is executing in the debug mode, it stops the simulation with an error. Arguments #1 : A string describing the warning. Usage strictWarning(\"warning message\") suggestion Return a suggestion for a wrong string value. The suggestion must have a Levenshtein's distance of less than 60% the size of the string, otherwise it returns nil. Arguments #1 : A string. #2 : A named table with the possible suggestions. It can also be a vector of strings. Usage t = { blue = true, red = true, green = true } str = suggestion(\"gren\", t) print(str) suggestionMsg Return the arguments of suggestion within a question \" Do you mean '#1'?\". Arguments #1 : A string. Usage t = { blue = true, red = true, green = true } str = suggestionMsg(suggestion(\"gren\", t)) print(str) switchInvalidArgument Stop the simulation with an error because the user did not choose a correct option. This function supposes that there is a set of available options described as string idexes of a table so it tries to find an approximate string to be shown as a suggestion. Otherwise, it shows all the available options. The error messages come from switchInvalidArgumentSuggestionMsg() and switchInvalidArgumentMsg() . Arguments #1 : A string with the name of the argument. #2 : A string with wrong value passed as argument. #3 : A named table describing the available options. Usage t = { blue = true, red = true, green = true } _, err = pcall(function() switchInvalidArgument(\"attribute\", \"gren\", t) end) print(err) switchInvalidArgumentMsg Return a message for a wrong argument value showing the options. The string is \"'#1' is an invalid value for argument '#2'. It must be a string from the set [#3].\". Arguments #1 : A string with the value of the argument. #2 : A string with the name of the argument. #3 : A named table indicating the available options. Usage local options = { aaa = true, bbb = true, ccc = true } str = switchInvalidArgumentMsg(\"ddd\", \"attr\", options) print(str) switchInvalidArgumentSuggestionMsg Return a message for a wrong argument value showing the most similar option. The string is \"'#1' is an invalid value for argument '#2'. suggestionMsg(#3)\". Arguments #1 : A string with the value of the argument. #2 : A string with the name of the argument. #3 : A string with a suggestion to replace the wrong value. Usage str = switchInvalidArgumentSuggestionMsg(\"aab\", \"attr\", \"aaa\") print(str) tableArgumentMsg Return a message indicating that the argument of a function must be a table. The string is \"Argument must be a table.\". Usage str = tableArgumentMsg() print(str) unnecessaryArgumentMsg Return a message indicating that a given argument is unnecessary. The string is \"Argument '#1' is unnecessary. suggestionMsg(#2)\". Arguments #1 : A string or number or boolean value. #2 : A possible suggestion for the argument. This argument is optional. Usage str = unnecessaryArgumentMsg(\"file\") print(str) str = unnecessaryArgumentMsg(\"filf\", \"file\") print(str) valueNotFoundError Stop the simulation with an error due to a wrong value for an argument. The error message comes from valueNotFoundMsg() . Arguments #1 : A string with the name of the argument or a number with its position. #2 : The value used as argument to the function call. Usage _, err = pcall(function() valueNotFoundError(1, \"neighborhood\") end) print(err) valueNotFoundMsg Return a message indicating that a given argument of a function is mandatory. The string is \"Value '#2' not found for argument '#1'.\". Arguments #1 : A string with the name of the argument or a number with its position. #2 : The valued used as argument to the function call. Usage str = valueNotFoundMsg(1, \"neighborhood\") print(str) verify Verify a given condition, otherwise it stops the simulation with an error. Arguments #1 : A value of any type. If it is false or nil, the function generates an error. #2 : A string with the error to be displayed. Usage greater = function(a, b) verify(a > b, \"#1 is not greater than #2.\") end _, err = pcall(function() greater(5, 7) end) print(err) verifyNamedTable Verify if a given object is a named table. It generates errors if it is nil, if it is not a table, or if it has numeric names. The error messages come from tableArgumentMsg() and namedArgumentsMsg() . Arguments #1 : A value of any type. Usage myFunction = function(mtable) verifyNamedTable(mtable) end _, err = pcall(function() myFunction{1, 2, 3} end) print(err) verifyUnnecessaryArguments Verify whether the user has passed only the allowed arguments for a function, removing the unnecessary arguments and showing a strict warning otherwise. The warning comes from unnecessaryArgumentMsg() . It is recommended that this function should be called as early as possible, in order to show the warning before any error that might be related to it. This function removes each unnecessary argument from #1. Arguments #1 : A named table with the arguments used in the function call. The names of this table will be verified. #2 : A vector with the allowed arguments. Usage myFunction = function(mtable) verifyUnnecessaryArguments(mtable, {\"aaa\", \"bbb\", \"ccc\"}) end _, err = pcall(function() myFunction{aaa = 3, value = 2} end) print(err)","title":"ErrorHandling"},{"location":"base/functions/errorHandling/#errorhandling","text":"Some basic and useful functions to handle errors and error messages.","title":"ErrorHandling"},{"location":"base/functions/errorHandling/#functions","text":"customError Stop the simulation with an error. customWarning Print a warning. defaultTableValue Verify the default value of a given attribute of a named table. defaultValueMsg Return a message indicating that the modeler is using the default value for a given argument and therefore it could be removed. defaultValueWarning Show a strict warning if the attribute of a table has the default value. deprecatedFunction Show an error indicating a deprecated function. deprecatedFunctionMsg Return a message indicating that a function is deprecated and must be replaced. incompatibleTypeError Stop the simulation with an error of a wrong type for an argument of a function. incompatibleTypeMsg Return an error message for incompatible types. incompatibleValueError Stop the simulation with an error of a wrong value for an argument of a function. incompatibleValueMsg Return an error message for incompatible values. integerArgument Verify whether a given argument is integer. integerArgumentMsg Return a message indicating that a given argument of a function should be integer. integerTableArgument Verify whether a given argument of a named function is integer. invalidFileExtensionError Stop the simulation with an error indicating that the function does not support a given file extension. invalidFileExtensionMsg Return a message indicating that a given file extension is incompatible. mandatoryArgument Verify whether a given argument of a function with non-named arguments belongs to the correct type. mandatoryArgumentError Stop the simulation with an error indicating that a given argument is mandatory. mandatoryArgumentMsg Return a message indicating that a given argument of a function is mandatory. mandatoryTableArgument Verify whether a named table contains a mandatory argument. namedArgumentsMsg Return a message indicating that the arguments of a function must be named. optionalArgument Verify whether an optional argument of a function with non-named arguments belongs to the correct type. optionalTableArgument Verify whether a named table contains an optional argument. positiveArgument Verify whether a given argument is positive. positiveArgumentMsg Return a message indicating that a given argument of a function should be positive. positiveTableArgument Verify whether a given argument of a function with named arguments is positive. resourceNotFoundError Stop the simulation with an error indicating that a given resource was not found. resourceNotFoundMsg Return a message indicating that a given resource could not be found. strictWarning Print a strict warning. suggestion Return a suggestion for a wrong string value. suggestionMsg Return the arguments of suggestion within a question \" Do you mean '#1'?\". switchInvalidArgument Stop the simulation with an error because the user did not choose a correct option. switchInvalidArgumentMsg Return a message for a wrong argument value showing the options. switchInvalidArgumentSuggestionMsg Return a message for a wrong argument value showing the most similar option. tableArgumentMsg Return a message indicating that the argument of a function must be a table. unnecessaryArgumentMsg Return a message indicating that a given argument is unnecessary. valueNotFoundError Stop the simulation with an error due to a wrong value for an argument. valueNotFoundMsg Return a message indicating that a given argument of a function is mandatory. verify Verify a given condition, otherwise it stops the simulation with an error. verifyNamedTable Verify if a given object is a named table. verifyUnnecessaryArguments Verify whether the user has passed only the allowed arguments for a function, removing the unnecessary arguments and showing a strict warning otherwise.","title":"Functions"},{"location":"base/functions/errorHandling/#customerror","text":"Stop the simulation with an error.","title":"customError"},{"location":"base/functions/errorHandling/#arguments","text":"#1 : A string describing the error message.","title":"Arguments"},{"location":"base/functions/errorHandling/#usage","text":"_, err = pcall(function() customError(\"error message\") end) print(err)","title":"Usage"},{"location":"base/functions/errorHandling/#customwarning","text":"Print a warning. If TerraME is executing in the debug mode, it stops the simulation with an error.","title":"customWarning"},{"location":"base/functions/errorHandling/#arguments_1","text":"#1 : A string describing the warning.","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_1","text":"customWarning(\"warning message\")","title":"Usage"},{"location":"base/functions/errorHandling/#defaulttablevalue","text":"Verify the default value of a given attribute of a named table. It adds the attribute with the default value in the table if it does not exist, stops with an error ( incompatibleTypeMsg() ) if the value has a different type, or shows a warning ( defaultValueWarning() ) if it is equal to the default value.","title":"defaultTableValue"},{"location":"base/functions/errorHandling/#arguments_2","text":"#1 : A named table (which can be an argument for a function). #2 : A string with the name of an attribute (or argument) from #1. #3 : The default value (any type).","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_2","text":"function integrate(attrs) defaultTableValue(attrs, \"method\", \"euler\") return attrs end t = integrate{} print(t.method)","title":"Usage"},{"location":"base/functions/errorHandling/#defaultvaluemsg","text":"Return a message indicating that the modeler is using the default value for a given argument and therefore it could be removed. The string is \"Argument '#1' could be removed as it is the default value ('#2').\".","title":"defaultValueMsg"},{"location":"base/functions/errorHandling/#arguments_3","text":"#1 : A string with the name of the argument. #2 : A number or string or boolean value with the default value for the argument.","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_3","text":"str = defaultValueMsg(\"dbtype\", \"mysql\") print(str)","title":"Usage"},{"location":"base/functions/errorHandling/#defaultvaluewarning","text":"Show a strict warning if the attribute of a table has the default value. If TerraME is running in the debug mode, the simulation stops with an error. The warning message comes from defaultValueMsg() .","title":"defaultValueWarning"},{"location":"base/functions/errorHandling/#arguments_4","text":"#1 : A string with the name of the argument. #2 : The default value.","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_4","text":"str = defaultValueWarning(\"size\", 2) print(str)","title":"Usage"},{"location":"base/functions/errorHandling/#deprecatedfunction","text":"Show an error indicating a deprecated function. The error comes from deprecatedFunctionMsg() .","title":"deprecatedFunction"},{"location":"base/functions/errorHandling/#arguments_5","text":"#1 : A string with the name of the deprecated function. #2 : A string indicating how to proceed to replace the deprecated function call.","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_5","text":"deprecatedFunc = function() deprecatedFunction(\"abc\", \"def\") end _, err = pcall(function() deprecatedFunc() end) print(err)","title":"Usage"},{"location":"base/functions/errorHandling/#deprecatedfunctionmsg","text":"Return a message indicating that a function is deprecated and must be replaced. The string is \"Function '#1' is deprecated. Use '#2' instead.\".","title":"deprecatedFunctionMsg"},{"location":"base/functions/errorHandling/#arguments_6","text":"#1 : A string with the name of the deprecated function. #2 : A string indicating how to proceed to replace the deprecated function call.","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_6","text":"str = deprecatedFunctionMsg(\"abc\", \"def\") print(str)","title":"Usage"},{"location":"base/functions/errorHandling/#incompatibletypeerror","text":"Stop the simulation with an error of a wrong type for an argument of a function. The error message is the return value of incompatibleTypeMsg() .","title":"incompatibleTypeError"},{"location":"base/functions/errorHandling/#arguments_7","text":"#1 : A string with the name of the argument, or a number with its the position. #2 : A string with the possible type (or types). #3 : The value wrongly passed as argument.","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_7","text":"_, err = pcall(function() incompatibleTypeError(\"cell\", \"Cell\", Agent{}) end) print(err)","title":"Usage"},{"location":"base/functions/errorHandling/#incompatibletypemsg","text":"Return an error message for incompatible types. The string is \"Incompatible types. Argument '#1' expected #2, got type(#3).\".","title":"incompatibleTypeMsg"},{"location":"base/functions/errorHandling/#arguments_8","text":"#1 : A string with the name of the argument, or a number with its the position. #2 : A string with the possible type (or types). The default value is \"nil\". #3 : The value wrongly passed as argument.","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_8","text":"str = incompatibleTypeMsg(\"source\", \"string\", 2) print(str)","title":"Usage"},{"location":"base/functions/errorHandling/#incompatiblevalueerror","text":"Stop the simulation with an error of a wrong value for an argument of a function. The error message comes from incompatibleValueMsg() .","title":"incompatibleValueError"},{"location":"base/functions/errorHandling/#arguments_9","text":"#1 : A string with the name of the argument or a number with its position. #2 : A string with the expected value(s) for the argument. #3 : The value wrongly passed as argument.","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_9","text":"_, err = pcall(function() incompatibleValueError(\"position\", \"one of {1, 2, 3}\", 4) end) print(err)","title":"Usage"},{"location":"base/functions/errorHandling/#incompatiblevaluemsg","text":"Return an error message for incompatible values. The string is \"Incompatible values. Argument '#1' expected #2, got #3.\".","title":"incompatibleValueMsg"},{"location":"base/functions/errorHandling/#arguments_10","text":"#1 : A string with the name of the argument or a number with its position. #2 : A string with the expected value(s) for the argument. #3 : The value wrongly passed as argument.","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_10","text":"str = incompatibleValueMsg(\"source\", \"one of {1, 3, 4}\", 2) print(str)","title":"Usage"},{"location":"base/functions/errorHandling/#integerargument","text":"Verify whether a given argument is integer. It is useful only for functions with non-named arguments. The error message comes from integerArgumentMsg() .","title":"integerArgument"},{"location":"base/functions/errorHandling/#arguments_11","text":"#1 : A number with the position of the argument in the function. #2 : The value used as argument to the function call.","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_11","text":"sum = function(a, b) integerArgument(1, a) integerArgument(2, b) return a + b end _, err = pcall(function() sum(5) end) print(err)","title":"Usage"},{"location":"base/functions/errorHandling/#integerargumentmsg","text":"Return a message indicating that a given argument of a function should be integer. It returns incompatibleValueMsg() with \"integer number\" as #2.","title":"integerArgumentMsg"},{"location":"base/functions/errorHandling/#arguments_12","text":"#1 : A string with the name of the argument or a number with the position of the argument. #2 : The value used as argument to the function call.","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_12","text":"str = integerArgumentMsg(\"target\", 7.4) print(str) str = integerArgumentMsg(2, 5.1) print(str)","title":"Usage"},{"location":"base/functions/errorHandling/#integertableargument","text":"Verify whether a given argument of a named function is integer. The error message comes from integerArgumentMsg() .","title":"integerTableArgument"},{"location":"base/functions/errorHandling/#arguments_13","text":"#1 : A named table. #2 : A string with the name of the argument.","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_13","text":"myFunction = function(mtable) integerTableArgument(mtable, \"value\") end _, err = pcall(function() myFunction{value = false} end) print(err)","title":"Usage"},{"location":"base/functions/errorHandling/#invalidfileextensionerror","text":"Stop the simulation with an error indicating that the function does not support a given file extension. The error message comes from invalidFileExtensionMsg() .","title":"invalidFileExtensionError"},{"location":"base/functions/errorHandling/#arguments_14","text":"#1 : A string with the name of the argument or a number with its position. #2 : A string with the incompatible file extension.","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_14","text":"_, err = pcall(function() invalidFileExtensionError(\"file\", \".txt\") end) print(err)","title":"Usage"},{"location":"base/functions/errorHandling/#invalidfileextensionmsg","text":"Return a message indicating that a given file extension is incompatible. The string is \"Argument '#1' does not support extension '#2'.\".","title":"invalidFileExtensionMsg"},{"location":"base/functions/errorHandling/#arguments_15","text":"#1 : A string with the name of the argument (for functions with named arguments), or its position (for functions with non-named arguments). #2 : A string with the incompatible file extension.","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_15","text":"str = invalidFileExtensionMsg(\"file\", \"csv\") print(str)","title":"Usage"},{"location":"base/functions/errorHandling/#mandatoryargument","text":"Verify whether a given argument of a function with non-named arguments belongs to the correct type. The error message comes from mandatoryArgumentMsg() and incompatibleTypeMsg() .","title":"mandatoryArgument"},{"location":"base/functions/errorHandling/#arguments_16","text":"#1 : A number with the position of the argument in the function. #2 : A string with the required type for the argument. #3 : The value used as argument to the function call.","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_16","text":"myFunction = function(value) mandatoryArgument(1, \"string\", value) end _, err = pcall(function() myFunction(2) end) print(err)","title":"Usage"},{"location":"base/functions/errorHandling/#mandatoryargumenterror","text":"Stop the simulation with an error indicating that a given argument is mandatory. The error message comes from mandatoryArgumentMsg() .","title":"mandatoryArgumentError"},{"location":"base/functions/errorHandling/#arguments_17","text":"#1 : A string with name of the argument or a number with its position in the function.","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_17","text":"_, err = pcall(function() mandatoryArgumentError(2) end) print(err)","title":"Usage"},{"location":"base/functions/errorHandling/#mandatoryargumentmsg","text":"Return a message indicating that a given argument of a function is mandatory. The string is \"Argument '#1' is mandatory.\".","title":"mandatoryArgumentMsg"},{"location":"base/functions/errorHandling/#arguments_18","text":"#1 : The name of the argument. It can be a string or a number.","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_18","text":"str = mandatoryArgumentMsg(\"target\") print(str) str = mandatoryArgumentMsg(2) print(str)","title":"Usage"},{"location":"base/functions/errorHandling/#mandatorytableargument","text":"Verify whether a named table contains a mandatory argument. It stops with an error if the value is nil or if it does not belong to the required type. The error message comes from mandatoryArgumentMsg() or incompatibleTypeMsg() .","title":"mandatoryTableArgument"},{"location":"base/functions/errorHandling/#arguments_19","text":"#1 : A named table. #2 : A string with the argument name. #3 : A string with the required type for the argument, or a vector of strings with the allowed types. This argument is optional. If not used, then this function will check only if the argument is not nil.","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_19","text":"myFunction = function(mtable) mandatoryTableArgument(mtable, \"value\", \"string\") end _, err = pcall(function() myFunction{value = 2} end) print(err)","title":"Usage"},{"location":"base/functions/errorHandling/#namedargumentsmsg","text":"Return a message indicating that the arguments of a function must be named. The string is \"Arguments must be named.\".","title":"namedArgumentsMsg"},{"location":"base/functions/errorHandling/#usage_20","text":"str = namedArgumentsMsg() print(str)","title":"Usage"},{"location":"base/functions/errorHandling/#optionalargument","text":"Verify whether an optional argument of a function with non-named arguments belongs to the correct type. If the argument is nil then no error is created. The error message comes from incompatibleTypeMsg() .","title":"optionalArgument"},{"location":"base/functions/errorHandling/#arguments_20","text":"#1 : A number with the position of the argument in the function. #2 : A string with the required type for the argument. #3 : The value used as argument to the function call.","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_21","text":"myFunction = function(value) optionalArgument(1, \"string\", value) end _, err = pcall(function() myFunction(2) end) print(err)","title":"Usage"},{"location":"base/functions/errorHandling/#optionaltableargument","text":"Verify whether a named table contains an optional argument. It stops with an error if the value is not nil and it has a type different from the required type. The error comes from incompatibleTypeError() .","title":"optionalTableArgument"},{"location":"base/functions/errorHandling/#arguments_21","text":"#1 : A named table. #2 : A string with the name of the argument. #3 : A string with the required type for the argument or a table with strings describing the allowed types.","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_22","text":"myFunction = function(mtable) optionalTableArgument(mtable, \"value\", \"string\") end _, err = pcall(function() myFunction{value = 2} end) print(err)","title":"Usage"},{"location":"base/functions/errorHandling/#positiveargument","text":"Verify whether a given argument is positive. It is useful only for functions with non-named arguments. The error message comes from positiveArgumentMsg() .","title":"positiveArgument"},{"location":"base/functions/errorHandling/#arguments_22","text":"#1 : A number with the position of the argument in the function. #2 : The value used as argument to the function call. #3 : A boolean value indicating whether zero should be included (the default value is false).","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_23","text":"positiveSum = function(a, b) positiveArgument(1, a) positiveArgument(2, b) return a + b end _, err = pcall(function() positiveSum(5, -2) end) print(err)","title":"Usage"},{"location":"base/functions/errorHandling/#positiveargumentmsg","text":"Return a message indicating that a given argument of a function should be positive. It returns incompatibleValueMsg() with \"positive number (including/excluding zero)\" as #2.","title":"positiveArgumentMsg"},{"location":"base/functions/errorHandling/#arguments_23","text":"#1 : The name of the argument. It can be a string or a number. #2 : The value used as argument to the function call. #3 : A boolean value indicating whether zero should be included (the default value is false).","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_24","text":"str = positiveArgumentMsg(\"target\", -5) print(str) str = positiveArgumentMsg(2, -2, true) print(str)","title":"Usage"},{"location":"base/functions/errorHandling/#positivetableargument","text":"Verify whether a given argument of a function with named arguments is positive. The error message comes from positiveArgumentMsg() .","title":"positiveTableArgument"},{"location":"base/functions/errorHandling/#arguments_24","text":"#1 : A named table. #2 : A string with the name of the argument. #3 : A boolean value indicating whether zero should be included (the default value is false).","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_25","text":"myFunction = function(mtable) positiveTableArgument(mtable, \"value\") end _, err = pcall(function() myFunction{value = -2} end) print(err)","title":"Usage"},{"location":"base/functions/errorHandling/#resourcenotfounderror","text":"Stop the simulation with an error indicating that a given resource was not found. The error message comes from resourceNotFoundMsg() .","title":"resourceNotFoundError"},{"location":"base/functions/errorHandling/#arguments_25","text":"#1 : A string with the name of the argument, or its position. #2 : A string with the location of the resource.","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_26","text":"_, err = pcall(function() resourceNotFoundError(\"file\", \"file.txt\") end) print(err)","title":"Usage"},{"location":"base/functions/errorHandling/#resourcenotfoundmsg","text":"Return a message indicating that a given resource could not be found. The string is \" File /Resource '#1' was not found for argument '#2'.\".","title":"resourceNotFoundMsg"},{"location":"base/functions/errorHandling/#arguments_26","text":"#1 : A string with the name of the argument, or its position. #2 : A File or a string with the location of the resource.","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_27","text":"str = resourceNotFoundMsg(\"file\", \"c:\\\\myfiles\\\\file.csv\") print(str)","title":"Usage"},{"location":"base/functions/errorHandling/#strictwarning","text":"Print a strict warning. This warning is shown only in the strict mode. If TerraME is executing in the debug mode, it stops the simulation with an error.","title":"strictWarning"},{"location":"base/functions/errorHandling/#arguments_27","text":"#1 : A string describing the warning.","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_28","text":"strictWarning(\"warning message\")","title":"Usage"},{"location":"base/functions/errorHandling/#suggestion","text":"Return a suggestion for a wrong string value. The suggestion must have a Levenshtein's distance of less than 60% the size of the string, otherwise it returns nil.","title":"suggestion"},{"location":"base/functions/errorHandling/#arguments_28","text":"#1 : A string. #2 : A named table with the possible suggestions. It can also be a vector of strings.","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_29","text":"t = { blue = true, red = true, green = true } str = suggestion(\"gren\", t) print(str)","title":"Usage"},{"location":"base/functions/errorHandling/#suggestionmsg","text":"Return the arguments of suggestion within a question \" Do you mean '#1'?\".","title":"suggestionMsg"},{"location":"base/functions/errorHandling/#arguments_29","text":"#1 : A string.","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_30","text":"t = { blue = true, red = true, green = true } str = suggestionMsg(suggestion(\"gren\", t)) print(str)","title":"Usage"},{"location":"base/functions/errorHandling/#switchinvalidargument","text":"Stop the simulation with an error because the user did not choose a correct option. This function supposes that there is a set of available options described as string idexes of a table so it tries to find an approximate string to be shown as a suggestion. Otherwise, it shows all the available options. The error messages come from switchInvalidArgumentSuggestionMsg() and switchInvalidArgumentMsg() .","title":"switchInvalidArgument"},{"location":"base/functions/errorHandling/#arguments_30","text":"#1 : A string with the name of the argument. #2 : A string with wrong value passed as argument. #3 : A named table describing the available options.","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_31","text":"t = { blue = true, red = true, green = true } _, err = pcall(function() switchInvalidArgument(\"attribute\", \"gren\", t) end) print(err)","title":"Usage"},{"location":"base/functions/errorHandling/#switchinvalidargumentmsg","text":"Return a message for a wrong argument value showing the options. The string is \"'#1' is an invalid value for argument '#2'. It must be a string from the set [#3].\".","title":"switchInvalidArgumentMsg"},{"location":"base/functions/errorHandling/#arguments_31","text":"#1 : A string with the value of the argument. #2 : A string with the name of the argument. #3 : A named table indicating the available options.","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_32","text":"local options = { aaa = true, bbb = true, ccc = true } str = switchInvalidArgumentMsg(\"ddd\", \"attr\", options) print(str)","title":"Usage"},{"location":"base/functions/errorHandling/#switchinvalidargumentsuggestionmsg","text":"Return a message for a wrong argument value showing the most similar option. The string is \"'#1' is an invalid value for argument '#2'. suggestionMsg(#3)\".","title":"switchInvalidArgumentSuggestionMsg"},{"location":"base/functions/errorHandling/#arguments_32","text":"#1 : A string with the value of the argument. #2 : A string with the name of the argument. #3 : A string with a suggestion to replace the wrong value.","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_33","text":"str = switchInvalidArgumentSuggestionMsg(\"aab\", \"attr\", \"aaa\") print(str)","title":"Usage"},{"location":"base/functions/errorHandling/#tableargumentmsg","text":"Return a message indicating that the argument of a function must be a table. The string is \"Argument must be a table.\".","title":"tableArgumentMsg"},{"location":"base/functions/errorHandling/#usage_34","text":"str = tableArgumentMsg() print(str)","title":"Usage"},{"location":"base/functions/errorHandling/#unnecessaryargumentmsg","text":"Return a message indicating that a given argument is unnecessary. The string is \"Argument '#1' is unnecessary. suggestionMsg(#2)\".","title":"unnecessaryArgumentMsg"},{"location":"base/functions/errorHandling/#arguments_33","text":"#1 : A string or number or boolean value. #2 : A possible suggestion for the argument. This argument is optional.","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_35","text":"str = unnecessaryArgumentMsg(\"file\") print(str) str = unnecessaryArgumentMsg(\"filf\", \"file\") print(str)","title":"Usage"},{"location":"base/functions/errorHandling/#valuenotfounderror","text":"Stop the simulation with an error due to a wrong value for an argument. The error message comes from valueNotFoundMsg() .","title":"valueNotFoundError"},{"location":"base/functions/errorHandling/#arguments_34","text":"#1 : A string with the name of the argument or a number with its position. #2 : The value used as argument to the function call.","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_36","text":"_, err = pcall(function() valueNotFoundError(1, \"neighborhood\") end) print(err)","title":"Usage"},{"location":"base/functions/errorHandling/#valuenotfoundmsg","text":"Return a message indicating that a given argument of a function is mandatory. The string is \"Value '#2' not found for argument '#1'.\".","title":"valueNotFoundMsg"},{"location":"base/functions/errorHandling/#arguments_35","text":"#1 : A string with the name of the argument or a number with its position. #2 : The valued used as argument to the function call.","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_37","text":"str = valueNotFoundMsg(1, \"neighborhood\") print(str)","title":"Usage"},{"location":"base/functions/errorHandling/#verify","text":"Verify a given condition, otherwise it stops the simulation with an error.","title":"verify"},{"location":"base/functions/errorHandling/#arguments_36","text":"#1 : A value of any type. If it is false or nil, the function generates an error. #2 : A string with the error to be displayed.","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_38","text":"greater = function(a, b) verify(a > b, \"#1 is not greater than #2.\") end _, err = pcall(function() greater(5, 7) end) print(err)","title":"Usage"},{"location":"base/functions/errorHandling/#verifynamedtable","text":"Verify if a given object is a named table. It generates errors if it is nil, if it is not a table, or if it has numeric names. The error messages come from tableArgumentMsg() and namedArgumentsMsg() .","title":"verifyNamedTable"},{"location":"base/functions/errorHandling/#arguments_37","text":"#1 : A value of any type.","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_39","text":"myFunction = function(mtable) verifyNamedTable(mtable) end _, err = pcall(function() myFunction{1, 2, 3} end) print(err)","title":"Usage"},{"location":"base/functions/errorHandling/#verifyunnecessaryarguments","text":"Verify whether the user has passed only the allowed arguments for a function, removing the unnecessary arguments and showing a strict warning otherwise. The warning comes from unnecessaryArgumentMsg() . It is recommended that this function should be called as early as possible, in order to show the warning before any error that might be related to it. This function removes each unnecessary argument from #1.","title":"verifyUnnecessaryArguments"},{"location":"base/functions/errorHandling/#arguments_38","text":"#1 : A named table with the arguments used in the function call. The names of this table will be verified. #2 : A vector with the allowed arguments.","title":"Arguments"},{"location":"base/functions/errorHandling/#usage_40","text":"myFunction = function(mtable) verifyUnnecessaryArguments(mtable, {\"aaa\", \"bbb\", \"ccc\"}) end _, err = pcall(function() myFunction{aaa = 3, value = 2} end) print(err)","title":"Usage"},{"location":"base/functions/os/","text":"OS Functions to handle files and directories. Most of the functions bellow are taken from LuaFileSystem 1.6.2. Copyright Kepler Project 2003 ( https://keplerproject.github.io/luafilesystem ). Functions currentDir Return a Directory with the current working directory. isDirectory Return if a given path represents a directory that exists. isFile Return if a given file path exists. openWebpage Opens a webpage in a Web Browser. runCommand Execute a system command and return its output. sessionInfo Return information about the current execution. currentDir Return a Directory with the current working directory. Usage cdir = currentDir() print(cdir) isDirectory Return if a given path represents a directory that exists. Arguments #1 : A string with a path. Usage print(isDirectory(\"/home/user/mydirectory\")) isFile Return if a given file path exists. Arguments #1 : A string with a file path. Usage print(isFile(\"abc.lua\")) openWebpage Opens a webpage in a Web Browser. Arguments #1 : A string with the webpage to be opened. Usage openWebpage(\"www.terrame.org\") runCommand Execute a system command and return its output. It returns two tables. The first one contains each standard output line as a position. The second one contains each error output line as a position. Arguments #1 : A command. Usage result, error = runCommand(\"dir\") sessionInfo Return information about the current execution. The result is a table with the values below. Some of them are read only, while others might be changed accordingly. Attribute Description Read only? autoclose When a simulation creates graphical components ( Chart , Map , etc.), TerraME waits for the modeler to close them to finish its execution. This attribute is a boolean value indicating whether TerraME should be automatically closed after executing the simulation. No color A boolean value indicating whether text output might be colored. If colored, errors are shown red, warnings are shown yellow, and some prints in executions like -test and -doc might be green. This option can only be set from TerraME command line (-color). Yes currentFile A File with the name of the file currently being executed. This value only exists when the file is passed as argument to the command line. Yes initialDir A Directory where TerraME was executed. Whenever TerraME needs to import() a package and cannot find it in the installed packages, it tries to load from this directory. Yes dbVersion A string with the current TerraLib version for databases. Yes fullTraceback A boolean value indicating whether TerraME should show all the stack when an error occurs. This means that the lines from base package and internal files are also going to be shown when an error occurs. As default, TerraME does not show such lines. This value can be set from TerraME command line (-ft). No graphics A boolean value indicating whether the graphics are enabled. If false and one creates a Chart , Map , or any other object that has a graphical interface, it will not be shown. Because of that, it will not be possible to save the output from these objects. TerraME starts with graphics enabled (true). No interface A boolean value indicating whether a graphical interface to configure models is running. When this value is true, toLabel() converts errors to more readable texts referring to graphical objects instead of Model arguments. No mode A string with the current mode for warnings (\"normal\", \"debug\", \"quiet\", or \"strict\"). Run terrame -help for a description of such modes. No path A string with the location of TerraME in the computer. Yes round A number used whenever it is possible to have rounding problems. For instance, it works with Events that have period less than one by rounding the execution time of an Event that is going to be scheduled to a future time if the difference between such time and the closest integer number is less then the value of this argument. In this case, if an Event that starts in time one and has period 0.1, it might execute in time 1.999999999, as we are working with real number. This argument is then useful to make sure that such Event will be executed in time exactly two. The default value is 1e-5. There is a function to compare numbers called equals() , that uses this value internally. No separator A character with the directory separator. Each operational system has its own separator. Yes silent A boolean value indicating whether print() calls should not be shown. This value can only be set from TerraME command line (-silent). Yes system A string with the operating system. It is one of \"windows\", \"linux\", or \"mac\". Yes time A number with the execution time of TerraME in seconds. Yes version A string with the current version of TerraME. Yes Usage print(sessionInfo().mode)","title":"Os"},{"location":"base/functions/os/#os","text":"Functions to handle files and directories. Most of the functions bellow are taken from LuaFileSystem 1.6.2. Copyright Kepler Project 2003 ( https://keplerproject.github.io/luafilesystem ).","title":"OS"},{"location":"base/functions/os/#functions","text":"currentDir Return a Directory with the current working directory. isDirectory Return if a given path represents a directory that exists. isFile Return if a given file path exists. openWebpage Opens a webpage in a Web Browser. runCommand Execute a system command and return its output. sessionInfo Return information about the current execution.","title":"Functions"},{"location":"base/functions/os/#currentdir","text":"Return a Directory with the current working directory.","title":"currentDir"},{"location":"base/functions/os/#usage","text":"cdir = currentDir() print(cdir)","title":"Usage"},{"location":"base/functions/os/#isdirectory","text":"Return if a given path represents a directory that exists.","title":"isDirectory"},{"location":"base/functions/os/#arguments","text":"#1 : A string with a path.","title":"Arguments"},{"location":"base/functions/os/#usage_1","text":"print(isDirectory(\"/home/user/mydirectory\"))","title":"Usage"},{"location":"base/functions/os/#isfile","text":"Return if a given file path exists.","title":"isFile"},{"location":"base/functions/os/#arguments_1","text":"#1 : A string with a file path.","title":"Arguments"},{"location":"base/functions/os/#usage_2","text":"print(isFile(\"abc.lua\"))","title":"Usage"},{"location":"base/functions/os/#openwebpage","text":"Opens a webpage in a Web Browser.","title":"openWebpage"},{"location":"base/functions/os/#arguments_2","text":"#1 : A string with the webpage to be opened.","title":"Arguments"},{"location":"base/functions/os/#usage_3","text":"openWebpage(\"www.terrame.org\")","title":"Usage"},{"location":"base/functions/os/#runcommand","text":"Execute a system command and return its output. It returns two tables. The first one contains each standard output line as a position. The second one contains each error output line as a position.","title":"runCommand"},{"location":"base/functions/os/#arguments_3","text":"#1 : A command.","title":"Arguments"},{"location":"base/functions/os/#usage_4","text":"result, error = runCommand(\"dir\")","title":"Usage"},{"location":"base/functions/os/#sessioninfo","text":"Return information about the current execution. The result is a table with the values below. Some of them are read only, while others might be changed accordingly. Attribute Description Read only? autoclose When a simulation creates graphical components ( Chart , Map , etc.), TerraME waits for the modeler to close them to finish its execution. This attribute is a boolean value indicating whether TerraME should be automatically closed after executing the simulation. No color A boolean value indicating whether text output might be colored. If colored, errors are shown red, warnings are shown yellow, and some prints in executions like -test and -doc might be green. This option can only be set from TerraME command line (-color). Yes currentFile A File with the name of the file currently being executed. This value only exists when the file is passed as argument to the command line. Yes initialDir A Directory where TerraME was executed. Whenever TerraME needs to import() a package and cannot find it in the installed packages, it tries to load from this directory. Yes dbVersion A string with the current TerraLib version for databases. Yes fullTraceback A boolean value indicating whether TerraME should show all the stack when an error occurs. This means that the lines from base package and internal files are also going to be shown when an error occurs. As default, TerraME does not show such lines. This value can be set from TerraME command line (-ft). No graphics A boolean value indicating whether the graphics are enabled. If false and one creates a Chart , Map , or any other object that has a graphical interface, it will not be shown. Because of that, it will not be possible to save the output from these objects. TerraME starts with graphics enabled (true). No interface A boolean value indicating whether a graphical interface to configure models is running. When this value is true, toLabel() converts errors to more readable texts referring to graphical objects instead of Model arguments. No mode A string with the current mode for warnings (\"normal\", \"debug\", \"quiet\", or \"strict\"). Run terrame -help for a description of such modes. No path A string with the location of TerraME in the computer. Yes round A number used whenever it is possible to have rounding problems. For instance, it works with Events that have period less than one by rounding the execution time of an Event that is going to be scheduled to a future time if the difference between such time and the closest integer number is less then the value of this argument. In this case, if an Event that starts in time one and has period 0.1, it might execute in time 1.999999999, as we are working with real number. This argument is then useful to make sure that such Event will be executed in time exactly two. The default value is 1e-5. There is a function to compare numbers called equals() , that uses this value internally. No separator A character with the directory separator. Each operational system has its own separator. Yes silent A boolean value indicating whether print() calls should not be shown. This value can only be set from TerraME command line (-silent). Yes system A string with the operating system. It is one of \"windows\", \"linux\", or \"mac\". Yes time A number with the execution time of TerraME in seconds. Yes version A string with the current version of TerraME. Yes","title":"sessionInfo"},{"location":"base/functions/os/#usage_5","text":"print(sessionInfo().mode)","title":"Usage"},{"location":"base/functions/package/","text":"Package Functions to work with packages in TerraME. Functions filePath Return a File storing the full path of a file within a given package. filesByExtension Return a table with the files of a package that have a given extension. getPackage Return a table with the content of a given package. import Load a given package. isLoaded Return whether a given package is loaded. packageInfo Return the description of a package. filePath Return a File storing the full path of a file within a given package. The file must be inside the directory data of package. Arguments #1 : A string with the name of the file. #2 : A string with the name of the package. As default, it uses base package. Usage cs = CellularSpace{file = filePath(\"simple.pgm\")} filesByExtension Return a table with the files of a package that have a given extension. Arguments #1 : A string with the name of the package. #2 : A string with the extension. Usage filesByExtension(\"base\", \"csv\") getPackage Return a table with the content of a given package. If the package is not installed, it verifies if the package is in the current directory. Arguments #1 : A package name. Usage base = getPackage(\"base\") cs = base.CellularSpace{xdim = 10} import Load a given package. If the package is not installed, it verifies if the package is available in the current directory. It shows a warning if trying to load a package that was already loaded. In this case, the package will not be loaded again. See #2 below for a different procedure. Arguments #1 : A package name. #2 : A boolean value indicating whether TerraME should load the package even if it was already loaded (default is false). In this case, it also avoids a warning indicating that the package was already loaded. Usage import(\"calibration\") isLoaded Return whether a given package is loaded. Arguments #1 : A string with the name of the package. Usage if isLoaded(\"base\") then print(\"is loaded\") end packageInfo Return the description of a package. This function tries to find the package in the TerraME installation directory. If it does not exist then it checks wether the package is available in the current directory. If the package does not exist then it stops with an error. Otherwise, it reads file description.lua and returns the following string attributes. Attribute Description authors Name of the author(s) of the package. contact E-mail of one or more authors. content A description of the package. data A Directory with the path to the data directory of the package. This attribute is added by this function as it does not exist in description.lua. date Date of the current version. depends A string containing a comma-separated list of package names which this package depends on. tdepends A table describing the dependencies of the package using internal tables containing three values: operator (a string), package (a string), and version (a vector of numbers). license Name of the package's license. package Name of the package. path A Directory with the path where the package is stored in the computer. title Optional title for the HTML documentation of the package. url An optional value with the webpage of the package. version Current version of the package, in the form [.]*. For example: 1, 0.2, 2.5.2. Arguments #1 : A string with the name of the package. If nil, packageInfo will return the description of TerraME. Usage str = packageInfo().version print(str)","title":"Package"},{"location":"base/functions/package/#package","text":"Functions to work with packages in TerraME.","title":"Package"},{"location":"base/functions/package/#functions","text":"filePath Return a File storing the full path of a file within a given package. filesByExtension Return a table with the files of a package that have a given extension. getPackage Return a table with the content of a given package. import Load a given package. isLoaded Return whether a given package is loaded. packageInfo Return the description of a package.","title":"Functions"},{"location":"base/functions/package/#filepath","text":"Return a File storing the full path of a file within a given package. The file must be inside the directory data of package.","title":"filePath"},{"location":"base/functions/package/#arguments","text":"#1 : A string with the name of the file. #2 : A string with the name of the package. As default, it uses base package.","title":"Arguments"},{"location":"base/functions/package/#usage","text":"cs = CellularSpace{file = filePath(\"simple.pgm\")}","title":"Usage"},{"location":"base/functions/package/#filesbyextension","text":"Return a table with the files of a package that have a given extension.","title":"filesByExtension"},{"location":"base/functions/package/#arguments_1","text":"#1 : A string with the name of the package. #2 : A string with the extension.","title":"Arguments"},{"location":"base/functions/package/#usage_1","text":"filesByExtension(\"base\", \"csv\")","title":"Usage"},{"location":"base/functions/package/#getpackage","text":"Return a table with the content of a given package. If the package is not installed, it verifies if the package is in the current directory.","title":"getPackage"},{"location":"base/functions/package/#arguments_2","text":"#1 : A package name.","title":"Arguments"},{"location":"base/functions/package/#usage_2","text":"base = getPackage(\"base\") cs = base.CellularSpace{xdim = 10}","title":"Usage"},{"location":"base/functions/package/#import","text":"Load a given package. If the package is not installed, it verifies if the package is available in the current directory. It shows a warning if trying to load a package that was already loaded. In this case, the package will not be loaded again. See #2 below for a different procedure.","title":"import"},{"location":"base/functions/package/#arguments_3","text":"#1 : A package name. #2 : A boolean value indicating whether TerraME should load the package even if it was already loaded (default is false). In this case, it also avoids a warning indicating that the package was already loaded.","title":"Arguments"},{"location":"base/functions/package/#usage_3","text":"import(\"calibration\")","title":"Usage"},{"location":"base/functions/package/#isloaded","text":"Return whether a given package is loaded.","title":"isLoaded"},{"location":"base/functions/package/#arguments_4","text":"#1 : A string with the name of the package.","title":"Arguments"},{"location":"base/functions/package/#usage_4","text":"if isLoaded(\"base\") then print(\"is loaded\") end","title":"Usage"},{"location":"base/functions/package/#packageinfo","text":"Return the description of a package. This function tries to find the package in the TerraME installation directory. If it does not exist then it checks wether the package is available in the current directory. If the package does not exist then it stops with an error. Otherwise, it reads file description.lua and returns the following string attributes. Attribute Description authors Name of the author(s) of the package. contact E-mail of one or more authors. content A description of the package. data A Directory with the path to the data directory of the package. This attribute is added by this function as it does not exist in description.lua. date Date of the current version. depends A string containing a comma-separated list of package names which this package depends on. tdepends A table describing the dependencies of the package using internal tables containing three values: operator (a string), package (a string), and version (a vector of numbers). license Name of the package's license. package Name of the package. path A Directory with the path where the package is stored in the computer. title Optional title for the HTML documentation of the package. url An optional value with the webpage of the package. version Current version of the package, in the form [.]*. For example: 1, 0.2, 2.5.2.","title":"packageInfo"},{"location":"base/functions/package/#arguments_5","text":"#1 : A string with the name of the package. If nil, packageInfo will return the description of TerraME.","title":"Arguments"},{"location":"base/functions/package/#usage_5","text":"str = packageInfo().version print(str)","title":"Usage"},{"location":"base/functions/utils/","text":"Utils Some basic and useful functions for modeling. Functions belong Return whether a given value belong to a table. call Return a function that executes a given function of an object. clean Remove all graphical interfaces ( Chart , Map , etc.). clone Return a copy of a given table. d Constructor for an ordinary differential equation. delay Pause the simulation for a given time. equals Return whether two numbers are equals. forEachAgent Second order function to traverse a Society , Group , or Cell , applying a function to each of its Agents . forEachAttribute Second order function to traverse the attributes of a Cell or Agent defined by the user. forEachCell Second order function to traverse a given CellularSpace , Trajectory , or Agent , applying a given function to each of its Cells . forEachCellPair Second order function to traverse two CellularSpaces with the same resolution and size. forEachConnection Second order function to traverse the connections of a given Agent , applying a function to each of them. forEachDirectory Second order function to traverse a given directory, applying a given function on each of its internal directories. forEachElement Second order function to traverse a given object, applying a function to each of its elements. forEachFile Second order function to traverse a given directory, applying a given function on each of its files. forEachModel Second order function to traverse the instances of Models within a given Environment . forEachNeighbor Second order function to traverse a given Neighborhood of a Cell , applying a function in each of its neighbors. forEachNeighborAgent Second order function to traverse the Agents within the neighbor Cells fom the current location of a given Agent, applying a function to each of them. forEachNeighborhood Second order function to traverse all Neighborhoods of a Cell , applying a given function on them. forEachOrderedElement Second order function to traverse a given object, applying a function to each of its elements according to their alphabetical order. forEachRecursiveDirectory Second order function to traverse a given directory recursively, applying a given function on each of its internal files. forEachSocialNetwork Second order function to traverse all SocialNetworks of an Agent , applying a given function on them. getConfig Return a table with the content of the file config.lua, stored in the current directory of the simulation. getLuaFile Load a lua file and return its global values as a Lua table. getn Return the number of elements of a table, be them named or not. getNames Return the names of a given object derived from a table. greaterByAttribute Return a function that compares two tables (which can be, for instance, Agents or Cells ). greaterByCoord Return a function that compares two tables with x and y attributes (basically two regular Cells ). integrate A second order function to numerically solve ordinary differential equations with a given initial value. integrationEuler Implements the Euler (Euler-Cauchy) Method to integrate ordinary differential equations. integrationHeun Implements the Heun (Euler Second Order) Method to integrate ordinary differential equations. integrationRungeKutta Implements the Runge-Kutta Method (Fourth Order) to integrate ordinary differential equations. isModel Return whether a given value is a Model or an instance of a Model. isTable Return whether an object can be used as a table. levenshtein Return the Levenshtein's distance between two strings. replaceLatinCharacters This function converts latin characters to hexadecimal code by the characters bytes. round Round a number given a precision. string.endswith Return whether a string ends with a given substring (no case sensitive). switch Implement a switch case function, where functions are associated to the available options. toLabel Convert a string into a more readable name. type Return the type of an object. vardump Function that returns a string describing the internal content of an object. belong Return whether a given value belong to a table. Arguments #1 : A value. #2 : A table with a set of values. Usage belong(2, {1, 2, 3}) call Return a function that executes a given function of an object. It is particularly useful as argument action for an Event . Arguments #1 : Any TerraME object. #2 : A string with the function to be executed. Usage a = Agent{exec = function(self, ev) print(ev:getTime()) end} t = Timer{ Event{action = call(a, \"exec\")} } t:run(10) clean Remove all graphical interfaces ( Chart , Map , etc.). This function is particularly useful when one wants to simulate a Model repeated times. Usage clean() clone Return a copy of a given table. It does not copy metatables. Arguments #1 : A table. Usage animal = { age = 5, height = 10, weight = 8 } copy = clone(animal) copy.age = 2 print(animal.age) d Constructor for an ordinary differential equation. It works in the same way of integrate() , but it is more efficient as it does not get a table as argument. The default integration method is Euler but the modeler can declare a global variable INTEGRATION_METHOD to change the default method. Arguments 1 : A differential equation or a vector of differential equations. Each equation is described as a function of one or two arguments that returns a value of its derivative f(t, y), where t is the time instant, and y starts with the value of attribute initial and changes according to the result of f() and the chosen method. The calls to f will use the first argument (t) in the interval [a,b[, according to the argument step. 2 : The initial condition, or a vector of initial conditions, which must be satisfied. Each initial condition represents the value of y when t (first argument of f) is equal to the value of argument a. 3 : A number with the beginning of the interval. 4 : A number with the end of the interval. 5 : A positive number with the step within the interval. The default value is 0.2, but the user can change it by declaring a global variable DELTA. Usage df = function(x, y) return y - x ^ 2 + 1 end a = 0 b = 2 init = 0.5 delta = 0.2 result = d{df, init, a, b, delta} print(result) delay Pause the simulation for a given time. Arguments #1 : A number indicating how long in seconds should the model pause. The default value is 1. Usage delay(0.1) equals Return whether two numbers are equals. It supposes that there can exist a maximum difference of sessionInfo().round between them. Arguments #1 : A number. #2 : Another number. Usage print(equals(2, 2.0000001)) See also sessionInfo() (OS) forEachAgent Second order function to traverse a Society , Group , or Cell , applying a function to each of its Agents . It returns true if no call to the function taken as argument returns false, otherwise it returns false. Arguments #1 : A Society, Group, or Cell. Cells need to have a placement in order to execute this function. #2 : (Optional) A string with the name of the placement to be traversed. The default value is \"placement\". This argument can only be used when the first argument is a Cell. #3 : A function that takes one single Agent as argument. If some call to it returns false, forEachAgent() stops and does not process any other Agent. This function can optionally get a second argument with a positive number representing the position of the Agent in the vector of Agents. In the case where the second argument is missing, this function becomes the second argument. Usage ag = Agent{age = Random{min = 0, max = 2}} soc = Society{ instance = ag, quantity = 5 } forEachAgent(soc, function(agent) agent.age = agent.age + 1 end) See also createPlacement (Environment) forEachAttribute Second order function to traverse the attributes of a Cell or Agent defined by the user. It hides all the attributes and functions automatically created by TerraME. Note that, if the Agent (Cell) belongs to a Society ( CellularSpace ) created with an instance, those attributes from the instance that were not yet updated will not be captured by this function. Arguments #1 : An Agent or a Cell. #2 : A function that takes two arguments. The first argument is the attribute name and the second is its value. Usage ag = Agent{ age = 5, color = \"blue\" } forEachAttribute(ag, function(att) print(att) end) forEachCell Second order function to traverse a given CellularSpace , Trajectory , or Agent , applying a given function to each of its Cells . If any of the function calls returns false, forEachCell() stops and returns false, otherwise it returns true. Arguments #1 : A CellularSpace, Trajectory, or Agent. Agents need to have a placement in order to execute this function. #2 : (Optional) A string with the name of the placement to be traversed. The default value is \"placement\". This argument can only be used when the first argument is an Agent. #3 : A user-defined function that takes a Cell as argument. It can optionally have a second argument with a positive number representing the position of the Cell in the vector of Cells. If it returns false when processing a given Cell, forEachCell() stops and does not process any other Cell. In the case where the second argument is missing, this function becomes the second argument. Usage cellularspace = CellularSpace{xdim = 10} forEachCell(cellularspace, function(cell) cell.water = 0 end) See also createPlacement (Environment) forEachCellPair Second order function to traverse two CellularSpaces with the same resolution and size. It applies a function that gets two Cells as arguments, one from each CellularSpace. Both Cells share the same (x, y) location. It returns true if no call to the function taken as argument returns false, otherwise it returns false. Arguments #1 : A CellularSpace. #2 : Another CellularSpace. #3 : A user-defined function that takes two Cells as arguments, one coming from the first argument and the other from the second one. If some call returns false, forEachCellPair() stops and does not process any other pair of Cells. Usage cs1 = CellularSpace{ xdim = 10, instance = Cell{water = Random{min = 0, max = 20}} } cs2 = CellularSpace{xdim = 10} forEachCellPair(cs1, cs2, function(cell1, cell2) cell2.water = cell1.water cell1.water = 0 end) forEachConnection Second order function to traverse the connections of a given Agent , applying a function to each of them. It returns true if no call to the function taken as argument returns false, otherwise it returns false. There are two ways of using this function because the second argument is optional. Arguments #1 : An Agent. #2 : (Optional) A string with the name of the SocialNetwork to be traversed. The default value is \"1\". #3 : A function that takes three arguments: A connection (Agent), the connection weight, and the Agent itself. If some call to f returns false, forEachConnection() stops and does not process any other connection. In the case where the second argument is missing, this function becomes the second argument. Usage ag = Agent{ value = 2, on_message = function() print(\"thanks\") end } soc = Society{instance = ag, quantity = 10} soc:createSocialNetwork{quantity = 3} agent = soc:sample() forEachConnection(agent, function(conn) agent:message{receiver = conn} end) See also createSocialNetwork (Society) forEachDirectory Second order function to traverse a given directory, applying a given function on each of its internal directories. If any of the function calls returns false, forEachDirectory() stops and returns false, otherwise it returns true. Arguments #1 : A string with the path to a directory, or a vector of files. #2 : A user-defined function that takes a file name as argument. Note that the name does not include the directory where the file is placed. Usage forEachDirectory(packageInfo(\"base\").path, function(dir) print(dir) end) See also list (Directory) forEachElement Second order function to traverse a given object, applying a function to each of its elements. It can be used for instance to traverse all the elements of an Agent or an Environment . According to the current Lua version, if one uses this function twice, Lua does not guarantee that the objects will be traversed in the same order. If you need to guarantee this, it is recommended to use forEachOrderedElement() instead. This function returns true if no call to the function taken as argument returns false, otherwise it returns false. Arguments #1 : A TerraME object or a table. #2 : A user-defined function that takes three arguments: the name of the element, the element itself, and the type of the element. If some call to this function returns false then forEachElement() stops. Usage cell = Cell{ value1 = 10, value2 = 5 } forEachElement(cell, function(idx, _, etype) print(idx..\"\\t\"..etype) end) forEachFile Second order function to traverse a given directory, applying a given function on each of its files. Internal directories are ignored. If any of the function calls returns false, forEachFile() stops and returns false, otherwise it returns true. Arguments #1 : A string with the path to a directory, or a vector of files. #2 : A user-defined function that takes a file name as argument. Note that the name does not include the directory where the file is placed. Usage forEachFile(packageInfo(\"base\").path, function(file) print(file) end) See also list (Directory) forEachModel Second order function to traverse the instances of Models within a given Environment . It applies a given function on each of its instances. If any of the function calls returns false, forEachModel() stops and returns false, otherwise it returns true. Arguments #1 : An Environment. #2 : A user-defined function that takes an instance of Model as first argument and its name within the Environment as second argument. Usage MyTube = Model{ water = 200, sun = Choice{min = 0, default = 10}, init = function(model) model.finalTime = 100 model.timer = Timer{ Event{action = function() -- ... end} } end } e = Environment{ scenario0 = MyTube{}, scenario1 = MyTube{water = 100}, scenario2 = MyTube{water = 100, sun = 5}, scenario3 = MyTube{water = 100, sun = 10} } forEachModel(e, function(model, name) print(name..\" \"..model:title()) end) forEachNeighbor Second order function to traverse a given Neighborhood of a Cell , applying a function in each of its neighbors. It returns true if no call to the function taken as argument returns false, otherwise it returns false. There are two ways of using this function because the second argument is optional. Arguments #1 : A Cell. #2 : (Optional) A string with the name of the Neighborhood to be traversed. The default value is \"1\". #3 : A user-defined function that takes three arguments: the neighbor Cell, the connection weight, and the Cell itself. If some call to it returns false, forEachNeighbor() stops and does not process any other neighbor. In the case where the second argument is missing, this function becomes the second argument. Usage cs = CellularSpace{ xdim = 10, instance = Cell{deforestation = Random{min = 0, max = 1}} } cs:createNeighborhood() cell = cs:sample() forEachNeighbor(cell, function(neighbor) if neighbor.deforestation > 0.9 then cell.deforestation = cell.deforestation * 1.01 end end) cs:createNeighborhood{ strategy = \"vonneumann\", name = \"vonneumann\", self = true } forEachNeighbor(cell, \"vonneumann\", function(neighbor) if cell.deforestation <= neighbor.deforestation then cell.deforestation = neighbor.deforestation end end) See also createNeighborhood (CellularSpace) loadNeighborhood (CellularSpace) forEachNeighborAgent Second order function to traverse the Agents within the neighbor Cells fom the current location of a given Agent, applying a function to each of them. This function requires that the Agent has a default placement (\"placement\") and its Cell has a default Neighborhood (\"1\"). More complex placements and neighborhoods need to be traversed manually using Agent:getCell() and Cell:getNeighborhood() . It returns true if no call to the function taken as argument returns false, otherwise it returns false. Arguments #1 : An Agent. #2 : A function that takes one single Agent as argument. This function is called once for each agent within a neighbor cell of the current cell where the Agent belongs. If some call to it returns false, forEachNeighborAgent() stops and does not process any other Agent. Usage ag = Agent{age = Random{min = 0, max = 2}} soc = Society{ instance = ag, quantity = 5 } cs = CellularSpace{xdim = 5} cs:createNeighborhood{} env = Environment{soc, cs} env:createPlacement{} forEachNeighborAgent(soc:sample(), function(agent) print(\"Found Agent \"..agent.id) end) See also createNeighborhood (CellularSpace) createPlacement (Environment) forEachNeighborhood Second order function to traverse all Neighborhoods of a Cell , applying a given function on them. It returns true if no call to the function taken as argument returns false, otherwise it returns false. Arguments #1 : A Cell. #2 : A function that receives a Neighborhood name as argument. Usage cs = CellularSpace{ xdim = 10 } cs:createNeighborhood() cs:createNeighborhood{ name = \"2\" } cell = cs:sample() forEachNeighborhood(cell, function(idx) print(idx) print(#cell:getNeighborhood(idx)) end) forEachOrderedElement Second order function to traverse a given object, applying a function to each of its elements according to their alphabetical order. It can be used for instance to traverse all the elements of an Agent or an Environment . This function executes first the positions with numeric names and then the string ones, with upper case characters having priority over lower case. This function returns true if no call to the function taken as argument returns false, otherwise it returns false. Arguments #1 : A TerraME object or a table. #2 : A user-defined function that takes three arguments: the name of the element, the element itself, and the type of the element. If some call to this function returns false then forEachElement() stops. Usage cell = Cell{ value1 = 10, value2 = 5 } forEachOrderedElement(cell, function(idx, _, etype) print(idx..\"\\t\"..etype) end) forEachRecursiveDirectory Second order function to traverse a given directory recursively, applying a given function on each of its internal files. If any of the function calls returns false, forEachRecursiveDirectory() stops and returns false, otherwise it returns true. Arguments #1 : A string with the path to a directory, or a Directory (base package) . #2 : A user-defined function that takes a file path as argument. Usage forEachRecursiveDirectory(packageInfo(\"base\").path..\"data\", function(file) print(file) end) forEachSocialNetwork Second order function to traverse all SocialNetworks of an Agent , applying a given function on them. It returns true if no call to the function taken as argument returns false, otherwise it returns false. Arguments #1 : An Agent. #2 : A function that receives a SocialNetwork name as argument. Usage ag = Agent{value = 2} soc = Society{instance = ag, quantity = 20} soc:createSocialNetwork{quantity = 3} soc:createSocialNetwork{ quantity = 5, name = \"2\" } agent = soc:sample() forEachSocialNetwork(agent, function(idx) print(idx) print(#agent:getSocialNetwork(idx)) end) getConfig Return a table with the content of the file config.lua, stored in the current directory of the simulation. All the global variables of the file are elements of the returned table. Some packages require specific variables in this file in order to be tested or executed. Additional calls to getConfig will return the same output of the first call even if the current directory changes along the simulation. Usage getConfig() getLuaFile Load a lua file and return its global values as a Lua table. Arguments #1 : A File or a string with a file name. #2 : An optional table where the new values will be placed. Usage print(getLuaFile(packageInfo(\"base\").path..\"description.lua\").version) getn Return the number of elements of a table, be them named or not. It is a substitute for the old Lua function table.getn. It can also be used to compute the number of elements of any TerraME object, such as Agent or Environment . Arguments #1 : A table. Usage getn{name = \"john\", age = 20} getNames Return the names of a given object derived from a table. The output is a vector with the names as values alphabetically ordered. Arguments #1 : Any table or TerraME type that works as a table. Usage t = { cover = \"forest\", area = 200, water = false } getNames(t) -- {\"area\", \"cover\", \"water\"} See also isTable greaterByAttribute Return a function that compares two tables (which can be, for instance, Agents or Cells ). The function returns which one has a priority over the other, according to an attribute of the objects and a given operator. If the function was not successfully built it returns nil. Arguments #1 : A string with the name of the attribute. #2 : A string with the operator, which can be \">\", \"<\", \"<=\", or \">=\". The default value is \"<\". Usage cs = CellularSpace{ xdim = 10, instance = Cell{cover = Random{min = 0, max = 1}} } t = Trajectory{ target = cs, greater = greaterByAttribute(\"cover\") } See also Group Trajectory greaterByCoord Return a function that compares two tables with x and y attributes (basically two regular Cells ). The function returns which one has a priority over the other, according to a given operator. Arguments #1 : A string with the operator, which can be \">\", \"<\", \"<=\", or \">=\". The default value is \"<\". Usage cs = CellularSpace{ xdim = 10 } t = Trajectory{ target = cs, greater = greaterByCoord() } See also Trajectory integrate A second order function to numerically solve ordinary differential equations with a given initial value. Arguments a : A number with the beginning of the interval. b : A number with the end of the interval. equation : A differential equation or a vector of differential equations. Each equation is described as a function of one or two arguments that returns a value of its derivative f(t, y), where t is the time instant, and y starts with the value of attribute initial and changes according to the result of f() and the chosen method. The calls to f will use the first argument (t) in the interval [a,b[, according to the argument step. event : An Event that can be used to set arguments a and b with values event:getTime() - event:getPeriodicity() and event:getTime(), respectively. The period of the event must be a multiple of step. Note that the first execution of the event will compute the equation relative to a time interval between event.time - event.period and event.time. Be careful about that, as it can start before the initial Event of the simulation. initial : The initial condition, or a vector of initial conditions, which must be satisfied. Each initial condition represents the value of y when t (first argument of f) is equal to the value of argument a. method : the name of a numeric algorithm to solve the ordinary differential equations. See the options below. Method Description \"euler\" (default) Euler integration method \"heun\" Heun (Second Order Euler) \"rungekutta\" Runge-Kutta Method (Fourth Order) step : A positive number with the step within the interval. It must satisfy the condition that (b - a) is a multiple of step. Usage v = integrate{ equation = function(t, y) return t - 0.1 * y end, initial = 0, a = 0, b = 100, step = 0.1 } integrationEuler Implements the Euler (Euler-Cauchy) Method to integrate ordinary differential equations. Arguments #1 : The differential equation. #2 : The initial condition that must be satisfied. #3 : The value of 'a' in the interval [a,b[. #4 : The value of 'b' of in the interval [a,b[. #5 : The step of the independent variable. Usage f = function(x) return x^3 end v = integrationEuler(f, 0, 0, 3, 0.1) integrationHeun Implements the Heun (Euler Second Order) Method to integrate ordinary differential equations. It is a method of type Predictor-Corrector. Arguments #1 : The differential equation. #2 : The initial condition that must be satisfied. #3 : The value of 'a' in the interval [a,b[. #4 : The value of 'b' of in the interval [a,b[. #5 : The step of the independent variable. Usage f = function(x) return x^3 end v = integrationHeun(f, 0, 0, 3, 0.1) integrationRungeKutta Implements the Runge-Kutta Method (Fourth Order) to integrate ordinary differential equations. Arguments #1 : The differential equation. #2 : The initial condition that must be satisfied. #3 : The value of 'a' in the interval [a,b[. #4 : The value of 'b' of in the interval [a,b[. #5 : The step of the independent variable. Usage f = function(x) return x^3 end v = integrationRungeKutta(f, 0, 0, 3, 0.1) isModel Return whether a given value is a Model or an instance of a Model. Arguments #1 : A value. Usage print(isModel(2)) -- false isTable Return whether an object can be used as a table. This includes tables themselves as well as all TerraME types ( Cell , CellularSpace , etc.). Arguments #1 : A value of any type. Usage c = Cell{} print(isTable(c)) See also type levenshtein Return the Levenshtein's distance between two strings. See http://en.wikipedia.org/wiki/Levenshtein_distance for more details. Arguments #1 : A string. #2 : Another string. Usage levenshtein(\"abc\", \"abb\") replaceLatinCharacters This function converts latin characters to hexadecimal code by the characters bytes. It is necessary to Windows OS works correctly with latin characters. Also, it is necessary to set Lua locale as the same as the system locale. See os.setlocale() for more details. The list of unicode characters can be found in https://en.wikipedia.org/wiki/List_of_Unicode_characters. Arguments #1 : A string. Usage print(replaceLatinCharacters(\ufffd\ufffdguia)) -- \\xE1guia round Round a number given a precision. Arguments #1 : A number. #2 : The number of decimal places to be used. The default value is zero. Usage round(2.34566, 3) string.endswith Return whether a string ends with a given substring (no case sensitive). Arguments #1 : A string. #2 : A substring describing the end of #1. Usage string.endswith(\"abcdef\", \"def\") switch Implement a switch case function, where functions are associated to the available options. This function returns a table that contains a function called caseof, that gets a named table with functions describing what to do for each case (which is the name for the respective function). This table can have a field \"default\" that is executed when the selected value is not one of the available options within caseof. The error messages of this function come from switchInvalidArgumentMsg() and switchInvalidArgumentSuggestionMsg() . Arguments #1 : A named table. #2 : A string with the chosen attribute of the named table. Usage data = {protocol = \"udp\"} switch(data, \"protocol\"):caseof{ tcp = function() print(\"tcp\") end, udp = function() print(\"udp\") end } toLabel Convert a string into a more readable name. It is useful to work with Model:init() when the model will be available through a graphical interface. In graphical interfaces (see sessionInfo() ), if the string contains underscores, it replaces them by spaces and convert the next characters to uppercase. Otherwise, it adds a space before each uppercase character. It also converts the first character of the string to uppercase. Arguments #1 : A string with the parameter name. #2 : A string with the name of the table the parameter belongs to. This parameter is optional. Usage toLabel(\"maxValue\") -- 'Max Value' (with graphical interface) or 'maxValue' (without) type Return the type of an object. It extends the original Lua type() to support TerraME objects, whose type name (for instance \" CellularSpace \" or \" Agent \") is returned instead of \"table\". Arguments #1 : Any object or value. Usage c = Cell{value = 3} print(type(c)) -- \"Cell\" See also isTable vardump Function that returns a string describing the internal content of an object. It converts a table into a string that represents a Lua code that declares such table. If some internal object is named \"parent\", it will be converted into a string with the type of the object. It avoids infinite loops due to the internal cyclic representation of TerraME. Arguments #1 : The object to be converted into a string. #2 : A string to be placed in the beginning of each line of the returning string. Usage vardump{name = \"john\", age = 20} -- { -- age = 20, -- name = \"john\" -- }","title":"Utils"},{"location":"base/functions/utils/#utils","text":"Some basic and useful functions for modeling.","title":"Utils"},{"location":"base/functions/utils/#functions","text":"belong Return whether a given value belong to a table. call Return a function that executes a given function of an object. clean Remove all graphical interfaces ( Chart , Map , etc.). clone Return a copy of a given table. d Constructor for an ordinary differential equation. delay Pause the simulation for a given time. equals Return whether two numbers are equals. forEachAgent Second order function to traverse a Society , Group , or Cell , applying a function to each of its Agents . forEachAttribute Second order function to traverse the attributes of a Cell or Agent defined by the user. forEachCell Second order function to traverse a given CellularSpace , Trajectory , or Agent , applying a given function to each of its Cells . forEachCellPair Second order function to traverse two CellularSpaces with the same resolution and size. forEachConnection Second order function to traverse the connections of a given Agent , applying a function to each of them. forEachDirectory Second order function to traverse a given directory, applying a given function on each of its internal directories. forEachElement Second order function to traverse a given object, applying a function to each of its elements. forEachFile Second order function to traverse a given directory, applying a given function on each of its files. forEachModel Second order function to traverse the instances of Models within a given Environment . forEachNeighbor Second order function to traverse a given Neighborhood of a Cell , applying a function in each of its neighbors. forEachNeighborAgent Second order function to traverse the Agents within the neighbor Cells fom the current location of a given Agent, applying a function to each of them. forEachNeighborhood Second order function to traverse all Neighborhoods of a Cell , applying a given function on them. forEachOrderedElement Second order function to traverse a given object, applying a function to each of its elements according to their alphabetical order. forEachRecursiveDirectory Second order function to traverse a given directory recursively, applying a given function on each of its internal files. forEachSocialNetwork Second order function to traverse all SocialNetworks of an Agent , applying a given function on them. getConfig Return a table with the content of the file config.lua, stored in the current directory of the simulation. getLuaFile Load a lua file and return its global values as a Lua table. getn Return the number of elements of a table, be them named or not. getNames Return the names of a given object derived from a table. greaterByAttribute Return a function that compares two tables (which can be, for instance, Agents or Cells ). greaterByCoord Return a function that compares two tables with x and y attributes (basically two regular Cells ). integrate A second order function to numerically solve ordinary differential equations with a given initial value. integrationEuler Implements the Euler (Euler-Cauchy) Method to integrate ordinary differential equations. integrationHeun Implements the Heun (Euler Second Order) Method to integrate ordinary differential equations. integrationRungeKutta Implements the Runge-Kutta Method (Fourth Order) to integrate ordinary differential equations. isModel Return whether a given value is a Model or an instance of a Model. isTable Return whether an object can be used as a table. levenshtein Return the Levenshtein's distance between two strings. replaceLatinCharacters This function converts latin characters to hexadecimal code by the characters bytes. round Round a number given a precision. string.endswith Return whether a string ends with a given substring (no case sensitive). switch Implement a switch case function, where functions are associated to the available options. toLabel Convert a string into a more readable name. type Return the type of an object. vardump Function that returns a string describing the internal content of an object.","title":"Functions"},{"location":"base/functions/utils/#belong","text":"Return whether a given value belong to a table.","title":"belong"},{"location":"base/functions/utils/#arguments","text":"#1 : A value. #2 : A table with a set of values.","title":"Arguments"},{"location":"base/functions/utils/#usage","text":"belong(2, {1, 2, 3})","title":"Usage"},{"location":"base/functions/utils/#call","text":"Return a function that executes a given function of an object. It is particularly useful as argument action for an Event .","title":"call"},{"location":"base/functions/utils/#arguments_1","text":"#1 : Any TerraME object. #2 : A string with the function to be executed.","title":"Arguments"},{"location":"base/functions/utils/#usage_1","text":"a = Agent{exec = function(self, ev) print(ev:getTime()) end} t = Timer{ Event{action = call(a, \"exec\")} } t:run(10)","title":"Usage"},{"location":"base/functions/utils/#clean","text":"Remove all graphical interfaces ( Chart , Map , etc.). This function is particularly useful when one wants to simulate a Model repeated times.","title":"clean"},{"location":"base/functions/utils/#usage_2","text":"clean()","title":"Usage"},{"location":"base/functions/utils/#clone","text":"Return a copy of a given table. It does not copy metatables.","title":"clone"},{"location":"base/functions/utils/#arguments_2","text":"#1 : A table.","title":"Arguments"},{"location":"base/functions/utils/#usage_3","text":"animal = { age = 5, height = 10, weight = 8 } copy = clone(animal) copy.age = 2 print(animal.age)","title":"Usage"},{"location":"base/functions/utils/#d","text":"Constructor for an ordinary differential equation. It works in the same way of integrate() , but it is more efficient as it does not get a table as argument. The default integration method is Euler but the modeler can declare a global variable INTEGRATION_METHOD to change the default method.","title":"d"},{"location":"base/functions/utils/#arguments_3","text":"1 : A differential equation or a vector of differential equations. Each equation is described as a function of one or two arguments that returns a value of its derivative f(t, y), where t is the time instant, and y starts with the value of attribute initial and changes according to the result of f() and the chosen method. The calls to f will use the first argument (t) in the interval [a,b[, according to the argument step. 2 : The initial condition, or a vector of initial conditions, which must be satisfied. Each initial condition represents the value of y when t (first argument of f) is equal to the value of argument a. 3 : A number with the beginning of the interval. 4 : A number with the end of the interval. 5 : A positive number with the step within the interval. The default value is 0.2, but the user can change it by declaring a global variable DELTA.","title":"Arguments"},{"location":"base/functions/utils/#usage_4","text":"df = function(x, y) return y - x ^ 2 + 1 end a = 0 b = 2 init = 0.5 delta = 0.2 result = d{df, init, a, b, delta} print(result)","title":"Usage"},{"location":"base/functions/utils/#delay","text":"Pause the simulation for a given time.","title":"delay"},{"location":"base/functions/utils/#arguments_4","text":"#1 : A number indicating how long in seconds should the model pause. The default value is 1.","title":"Arguments"},{"location":"base/functions/utils/#usage_5","text":"delay(0.1)","title":"Usage"},{"location":"base/functions/utils/#equals","text":"Return whether two numbers are equals. It supposes that there can exist a maximum difference of sessionInfo().round between them.","title":"equals"},{"location":"base/functions/utils/#arguments_5","text":"#1 : A number. #2 : Another number.","title":"Arguments"},{"location":"base/functions/utils/#usage_6","text":"print(equals(2, 2.0000001))","title":"Usage"},{"location":"base/functions/utils/#see-also","text":"sessionInfo() (OS)","title":"See also"},{"location":"base/functions/utils/#foreachagent","text":"Second order function to traverse a Society , Group , or Cell , applying a function to each of its Agents . It returns true if no call to the function taken as argument returns false, otherwise it returns false.","title":"forEachAgent"},{"location":"base/functions/utils/#arguments_6","text":"#1 : A Society, Group, or Cell. Cells need to have a placement in order to execute this function. #2 : (Optional) A string with the name of the placement to be traversed. The default value is \"placement\". This argument can only be used when the first argument is a Cell. #3 : A function that takes one single Agent as argument. If some call to it returns false, forEachAgent() stops and does not process any other Agent. This function can optionally get a second argument with a positive number representing the position of the Agent in the vector of Agents. In the case where the second argument is missing, this function becomes the second argument.","title":"Arguments"},{"location":"base/functions/utils/#usage_7","text":"ag = Agent{age = Random{min = 0, max = 2}} soc = Society{ instance = ag, quantity = 5 } forEachAgent(soc, function(agent) agent.age = agent.age + 1 end)","title":"Usage"},{"location":"base/functions/utils/#see-also_1","text":"createPlacement (Environment)","title":"See also"},{"location":"base/functions/utils/#foreachattribute","text":"Second order function to traverse the attributes of a Cell or Agent defined by the user. It hides all the attributes and functions automatically created by TerraME. Note that, if the Agent (Cell) belongs to a Society ( CellularSpace ) created with an instance, those attributes from the instance that were not yet updated will not be captured by this function.","title":"forEachAttribute"},{"location":"base/functions/utils/#arguments_7","text":"#1 : An Agent or a Cell. #2 : A function that takes two arguments. The first argument is the attribute name and the second is its value.","title":"Arguments"},{"location":"base/functions/utils/#usage_8","text":"ag = Agent{ age = 5, color = \"blue\" } forEachAttribute(ag, function(att) print(att) end)","title":"Usage"},{"location":"base/functions/utils/#foreachcell","text":"Second order function to traverse a given CellularSpace , Trajectory , or Agent , applying a given function to each of its Cells . If any of the function calls returns false, forEachCell() stops and returns false, otherwise it returns true.","title":"forEachCell"},{"location":"base/functions/utils/#arguments_8","text":"#1 : A CellularSpace, Trajectory, or Agent. Agents need to have a placement in order to execute this function. #2 : (Optional) A string with the name of the placement to be traversed. The default value is \"placement\". This argument can only be used when the first argument is an Agent. #3 : A user-defined function that takes a Cell as argument. It can optionally have a second argument with a positive number representing the position of the Cell in the vector of Cells. If it returns false when processing a given Cell, forEachCell() stops and does not process any other Cell. In the case where the second argument is missing, this function becomes the second argument.","title":"Arguments"},{"location":"base/functions/utils/#usage_9","text":"cellularspace = CellularSpace{xdim = 10} forEachCell(cellularspace, function(cell) cell.water = 0 end)","title":"Usage"},{"location":"base/functions/utils/#see-also_2","text":"createPlacement (Environment)","title":"See also"},{"location":"base/functions/utils/#foreachcellpair","text":"Second order function to traverse two CellularSpaces with the same resolution and size. It applies a function that gets two Cells as arguments, one from each CellularSpace. Both Cells share the same (x, y) location. It returns true if no call to the function taken as argument returns false, otherwise it returns false.","title":"forEachCellPair"},{"location":"base/functions/utils/#arguments_9","text":"#1 : A CellularSpace. #2 : Another CellularSpace. #3 : A user-defined function that takes two Cells as arguments, one coming from the first argument and the other from the second one. If some call returns false, forEachCellPair() stops and does not process any other pair of Cells.","title":"Arguments"},{"location":"base/functions/utils/#usage_10","text":"cs1 = CellularSpace{ xdim = 10, instance = Cell{water = Random{min = 0, max = 20}} } cs2 = CellularSpace{xdim = 10} forEachCellPair(cs1, cs2, function(cell1, cell2) cell2.water = cell1.water cell1.water = 0 end)","title":"Usage"},{"location":"base/functions/utils/#foreachconnection","text":"Second order function to traverse the connections of a given Agent , applying a function to each of them. It returns true if no call to the function taken as argument returns false, otherwise it returns false. There are two ways of using this function because the second argument is optional.","title":"forEachConnection"},{"location":"base/functions/utils/#arguments_10","text":"#1 : An Agent. #2 : (Optional) A string with the name of the SocialNetwork to be traversed. The default value is \"1\". #3 : A function that takes three arguments: A connection (Agent), the connection weight, and the Agent itself. If some call to f returns false, forEachConnection() stops and does not process any other connection. In the case where the second argument is missing, this function becomes the second argument.","title":"Arguments"},{"location":"base/functions/utils/#usage_11","text":"ag = Agent{ value = 2, on_message = function() print(\"thanks\") end } soc = Society{instance = ag, quantity = 10} soc:createSocialNetwork{quantity = 3} agent = soc:sample() forEachConnection(agent, function(conn) agent:message{receiver = conn} end)","title":"Usage"},{"location":"base/functions/utils/#see-also_3","text":"createSocialNetwork (Society)","title":"See also"},{"location":"base/functions/utils/#foreachdirectory","text":"Second order function to traverse a given directory, applying a given function on each of its internal directories. If any of the function calls returns false, forEachDirectory() stops and returns false, otherwise it returns true.","title":"forEachDirectory"},{"location":"base/functions/utils/#arguments_11","text":"#1 : A string with the path to a directory, or a vector of files. #2 : A user-defined function that takes a file name as argument. Note that the name does not include the directory where the file is placed.","title":"Arguments"},{"location":"base/functions/utils/#usage_12","text":"forEachDirectory(packageInfo(\"base\").path, function(dir) print(dir) end)","title":"Usage"},{"location":"base/functions/utils/#see-also_4","text":"list (Directory)","title":"See also"},{"location":"base/functions/utils/#foreachelement","text":"Second order function to traverse a given object, applying a function to each of its elements. It can be used for instance to traverse all the elements of an Agent or an Environment . According to the current Lua version, if one uses this function twice, Lua does not guarantee that the objects will be traversed in the same order. If you need to guarantee this, it is recommended to use forEachOrderedElement() instead. This function returns true if no call to the function taken as argument returns false, otherwise it returns false.","title":"forEachElement"},{"location":"base/functions/utils/#arguments_12","text":"#1 : A TerraME object or a table. #2 : A user-defined function that takes three arguments: the name of the element, the element itself, and the type of the element. If some call to this function returns false then forEachElement() stops.","title":"Arguments"},{"location":"base/functions/utils/#usage_13","text":"cell = Cell{ value1 = 10, value2 = 5 } forEachElement(cell, function(idx, _, etype) print(idx..\"\\t\"..etype) end)","title":"Usage"},{"location":"base/functions/utils/#foreachfile","text":"Second order function to traverse a given directory, applying a given function on each of its files. Internal directories are ignored. If any of the function calls returns false, forEachFile() stops and returns false, otherwise it returns true.","title":"forEachFile"},{"location":"base/functions/utils/#arguments_13","text":"#1 : A string with the path to a directory, or a vector of files. #2 : A user-defined function that takes a file name as argument. Note that the name does not include the directory where the file is placed.","title":"Arguments"},{"location":"base/functions/utils/#usage_14","text":"forEachFile(packageInfo(\"base\").path, function(file) print(file) end)","title":"Usage"},{"location":"base/functions/utils/#see-also_5","text":"list (Directory)","title":"See also"},{"location":"base/functions/utils/#foreachmodel","text":"Second order function to traverse the instances of Models within a given Environment . It applies a given function on each of its instances. If any of the function calls returns false, forEachModel() stops and returns false, otherwise it returns true.","title":"forEachModel"},{"location":"base/functions/utils/#arguments_14","text":"#1 : An Environment. #2 : A user-defined function that takes an instance of Model as first argument and its name within the Environment as second argument.","title":"Arguments"},{"location":"base/functions/utils/#usage_15","text":"MyTube = Model{ water = 200, sun = Choice{min = 0, default = 10}, init = function(model) model.finalTime = 100 model.timer = Timer{ Event{action = function() -- ... end} } end } e = Environment{ scenario0 = MyTube{}, scenario1 = MyTube{water = 100}, scenario2 = MyTube{water = 100, sun = 5}, scenario3 = MyTube{water = 100, sun = 10} } forEachModel(e, function(model, name) print(name..\" \"..model:title()) end)","title":"Usage"},{"location":"base/functions/utils/#foreachneighbor","text":"Second order function to traverse a given Neighborhood of a Cell , applying a function in each of its neighbors. It returns true if no call to the function taken as argument returns false, otherwise it returns false. There are two ways of using this function because the second argument is optional.","title":"forEachNeighbor"},{"location":"base/functions/utils/#arguments_15","text":"#1 : A Cell. #2 : (Optional) A string with the name of the Neighborhood to be traversed. The default value is \"1\". #3 : A user-defined function that takes three arguments: the neighbor Cell, the connection weight, and the Cell itself. If some call to it returns false, forEachNeighbor() stops and does not process any other neighbor. In the case where the second argument is missing, this function becomes the second argument.","title":"Arguments"},{"location":"base/functions/utils/#usage_16","text":"cs = CellularSpace{ xdim = 10, instance = Cell{deforestation = Random{min = 0, max = 1}} } cs:createNeighborhood() cell = cs:sample() forEachNeighbor(cell, function(neighbor) if neighbor.deforestation > 0.9 then cell.deforestation = cell.deforestation * 1.01 end end) cs:createNeighborhood{ strategy = \"vonneumann\", name = \"vonneumann\", self = true } forEachNeighbor(cell, \"vonneumann\", function(neighbor) if cell.deforestation <= neighbor.deforestation then cell.deforestation = neighbor.deforestation end end)","title":"Usage"},{"location":"base/functions/utils/#see-also_6","text":"createNeighborhood (CellularSpace) loadNeighborhood (CellularSpace)","title":"See also"},{"location":"base/functions/utils/#foreachneighboragent","text":"Second order function to traverse the Agents within the neighbor Cells fom the current location of a given Agent, applying a function to each of them. This function requires that the Agent has a default placement (\"placement\") and its Cell has a default Neighborhood (\"1\"). More complex placements and neighborhoods need to be traversed manually using Agent:getCell() and Cell:getNeighborhood() . It returns true if no call to the function taken as argument returns false, otherwise it returns false.","title":"forEachNeighborAgent"},{"location":"base/functions/utils/#arguments_16","text":"#1 : An Agent. #2 : A function that takes one single Agent as argument. This function is called once for each agent within a neighbor cell of the current cell where the Agent belongs. If some call to it returns false, forEachNeighborAgent() stops and does not process any other Agent.","title":"Arguments"},{"location":"base/functions/utils/#usage_17","text":"ag = Agent{age = Random{min = 0, max = 2}} soc = Society{ instance = ag, quantity = 5 } cs = CellularSpace{xdim = 5} cs:createNeighborhood{} env = Environment{soc, cs} env:createPlacement{} forEachNeighborAgent(soc:sample(), function(agent) print(\"Found Agent \"..agent.id) end)","title":"Usage"},{"location":"base/functions/utils/#see-also_7","text":"createNeighborhood (CellularSpace) createPlacement (Environment)","title":"See also"},{"location":"base/functions/utils/#foreachneighborhood","text":"Second order function to traverse all Neighborhoods of a Cell , applying a given function on them. It returns true if no call to the function taken as argument returns false, otherwise it returns false.","title":"forEachNeighborhood"},{"location":"base/functions/utils/#arguments_17","text":"#1 : A Cell. #2 : A function that receives a Neighborhood name as argument.","title":"Arguments"},{"location":"base/functions/utils/#usage_18","text":"cs = CellularSpace{ xdim = 10 } cs:createNeighborhood() cs:createNeighborhood{ name = \"2\" } cell = cs:sample() forEachNeighborhood(cell, function(idx) print(idx) print(#cell:getNeighborhood(idx)) end)","title":"Usage"},{"location":"base/functions/utils/#foreachorderedelement","text":"Second order function to traverse a given object, applying a function to each of its elements according to their alphabetical order. It can be used for instance to traverse all the elements of an Agent or an Environment . This function executes first the positions with numeric names and then the string ones, with upper case characters having priority over lower case. This function returns true if no call to the function taken as argument returns false, otherwise it returns false.","title":"forEachOrderedElement"},{"location":"base/functions/utils/#arguments_18","text":"#1 : A TerraME object or a table. #2 : A user-defined function that takes three arguments: the name of the element, the element itself, and the type of the element. If some call to this function returns false then forEachElement() stops.","title":"Arguments"},{"location":"base/functions/utils/#usage_19","text":"cell = Cell{ value1 = 10, value2 = 5 } forEachOrderedElement(cell, function(idx, _, etype) print(idx..\"\\t\"..etype) end)","title":"Usage"},{"location":"base/functions/utils/#foreachrecursivedirectory","text":"Second order function to traverse a given directory recursively, applying a given function on each of its internal files. If any of the function calls returns false, forEachRecursiveDirectory() stops and returns false, otherwise it returns true.","title":"forEachRecursiveDirectory"},{"location":"base/functions/utils/#arguments_19","text":"#1 : A string with the path to a directory, or a Directory (base package) . #2 : A user-defined function that takes a file path as argument.","title":"Arguments"},{"location":"base/functions/utils/#usage_20","text":"forEachRecursiveDirectory(packageInfo(\"base\").path..\"data\", function(file) print(file) end)","title":"Usage"},{"location":"base/functions/utils/#foreachsocialnetwork","text":"Second order function to traverse all SocialNetworks of an Agent , applying a given function on them. It returns true if no call to the function taken as argument returns false, otherwise it returns false.","title":"forEachSocialNetwork"},{"location":"base/functions/utils/#arguments_20","text":"#1 : An Agent. #2 : A function that receives a SocialNetwork name as argument.","title":"Arguments"},{"location":"base/functions/utils/#usage_21","text":"ag = Agent{value = 2} soc = Society{instance = ag, quantity = 20} soc:createSocialNetwork{quantity = 3} soc:createSocialNetwork{ quantity = 5, name = \"2\" } agent = soc:sample() forEachSocialNetwork(agent, function(idx) print(idx) print(#agent:getSocialNetwork(idx)) end)","title":"Usage"},{"location":"base/functions/utils/#getconfig","text":"Return a table with the content of the file config.lua, stored in the current directory of the simulation. All the global variables of the file are elements of the returned table. Some packages require specific variables in this file in order to be tested or executed. Additional calls to getConfig will return the same output of the first call even if the current directory changes along the simulation.","title":"getConfig"},{"location":"base/functions/utils/#usage_22","text":"getConfig()","title":"Usage"},{"location":"base/functions/utils/#getluafile","text":"Load a lua file and return its global values as a Lua table.","title":"getLuaFile"},{"location":"base/functions/utils/#arguments_21","text":"#1 : A File or a string with a file name. #2 : An optional table where the new values will be placed.","title":"Arguments"},{"location":"base/functions/utils/#usage_23","text":"print(getLuaFile(packageInfo(\"base\").path..\"description.lua\").version)","title":"Usage"},{"location":"base/functions/utils/#getn","text":"Return the number of elements of a table, be them named or not. It is a substitute for the old Lua function table.getn. It can also be used to compute the number of elements of any TerraME object, such as Agent or Environment .","title":"getn"},{"location":"base/functions/utils/#arguments_22","text":"#1 : A table.","title":"Arguments"},{"location":"base/functions/utils/#usage_24","text":"getn{name = \"john\", age = 20}","title":"Usage"},{"location":"base/functions/utils/#getnames","text":"Return the names of a given object derived from a table. The output is a vector with the names as values alphabetically ordered.","title":"getNames"},{"location":"base/functions/utils/#arguments_23","text":"#1 : Any table or TerraME type that works as a table.","title":"Arguments"},{"location":"base/functions/utils/#usage_25","text":"t = { cover = \"forest\", area = 200, water = false } getNames(t) -- {\"area\", \"cover\", \"water\"}","title":"Usage"},{"location":"base/functions/utils/#see-also_8","text":"isTable","title":"See also"},{"location":"base/functions/utils/#greaterbyattribute","text":"Return a function that compares two tables (which can be, for instance, Agents or Cells ). The function returns which one has a priority over the other, according to an attribute of the objects and a given operator. If the function was not successfully built it returns nil.","title":"greaterByAttribute"},{"location":"base/functions/utils/#arguments_24","text":"#1 : A string with the name of the attribute. #2 : A string with the operator, which can be \">\", \"<\", \"<=\", or \">=\". The default value is \"<\".","title":"Arguments"},{"location":"base/functions/utils/#usage_26","text":"cs = CellularSpace{ xdim = 10, instance = Cell{cover = Random{min = 0, max = 1}} } t = Trajectory{ target = cs, greater = greaterByAttribute(\"cover\") }","title":"Usage"},{"location":"base/functions/utils/#see-also_9","text":"Group Trajectory","title":"See also"},{"location":"base/functions/utils/#greaterbycoord","text":"Return a function that compares two tables with x and y attributes (basically two regular Cells ). The function returns which one has a priority over the other, according to a given operator.","title":"greaterByCoord"},{"location":"base/functions/utils/#arguments_25","text":"#1 : A string with the operator, which can be \">\", \"<\", \"<=\", or \">=\". The default value is \"<\".","title":"Arguments"},{"location":"base/functions/utils/#usage_27","text":"cs = CellularSpace{ xdim = 10 } t = Trajectory{ target = cs, greater = greaterByCoord() }","title":"Usage"},{"location":"base/functions/utils/#see-also_10","text":"Trajectory","title":"See also"},{"location":"base/functions/utils/#integrate","text":"A second order function to numerically solve ordinary differential equations with a given initial value.","title":"integrate"},{"location":"base/functions/utils/#arguments_26","text":"a : A number with the beginning of the interval. b : A number with the end of the interval. equation : A differential equation or a vector of differential equations. Each equation is described as a function of one or two arguments that returns a value of its derivative f(t, y), where t is the time instant, and y starts with the value of attribute initial and changes according to the result of f() and the chosen method. The calls to f will use the first argument (t) in the interval [a,b[, according to the argument step. event : An Event that can be used to set arguments a and b with values event:getTime() - event:getPeriodicity() and event:getTime(), respectively. The period of the event must be a multiple of step. Note that the first execution of the event will compute the equation relative to a time interval between event.time - event.period and event.time. Be careful about that, as it can start before the initial Event of the simulation. initial : The initial condition, or a vector of initial conditions, which must be satisfied. Each initial condition represents the value of y when t (first argument of f) is equal to the value of argument a. method : the name of a numeric algorithm to solve the ordinary differential equations. See the options below. Method Description \"euler\" (default) Euler integration method \"heun\" Heun (Second Order Euler) \"rungekutta\" Runge-Kutta Method (Fourth Order) step : A positive number with the step within the interval. It must satisfy the condition that (b - a) is a multiple of step.","title":"Arguments"},{"location":"base/functions/utils/#usage_28","text":"v = integrate{ equation = function(t, y) return t - 0.1 * y end, initial = 0, a = 0, b = 100, step = 0.1 }","title":"Usage"},{"location":"base/functions/utils/#integrationeuler","text":"Implements the Euler (Euler-Cauchy) Method to integrate ordinary differential equations.","title":"integrationEuler"},{"location":"base/functions/utils/#arguments_27","text":"#1 : The differential equation. #2 : The initial condition that must be satisfied. #3 : The value of 'a' in the interval [a,b[. #4 : The value of 'b' of in the interval [a,b[. #5 : The step of the independent variable.","title":"Arguments"},{"location":"base/functions/utils/#usage_29","text":"f = function(x) return x^3 end v = integrationEuler(f, 0, 0, 3, 0.1)","title":"Usage"},{"location":"base/functions/utils/#integrationheun","text":"Implements the Heun (Euler Second Order) Method to integrate ordinary differential equations. It is a method of type Predictor-Corrector.","title":"integrationHeun"},{"location":"base/functions/utils/#arguments_28","text":"#1 : The differential equation. #2 : The initial condition that must be satisfied. #3 : The value of 'a' in the interval [a,b[. #4 : The value of 'b' of in the interval [a,b[. #5 : The step of the independent variable.","title":"Arguments"},{"location":"base/functions/utils/#usage_30","text":"f = function(x) return x^3 end v = integrationHeun(f, 0, 0, 3, 0.1)","title":"Usage"},{"location":"base/functions/utils/#integrationrungekutta","text":"Implements the Runge-Kutta Method (Fourth Order) to integrate ordinary differential equations.","title":"integrationRungeKutta"},{"location":"base/functions/utils/#arguments_29","text":"#1 : The differential equation. #2 : The initial condition that must be satisfied. #3 : The value of 'a' in the interval [a,b[. #4 : The value of 'b' of in the interval [a,b[. #5 : The step of the independent variable.","title":"Arguments"},{"location":"base/functions/utils/#usage_31","text":"f = function(x) return x^3 end v = integrationRungeKutta(f, 0, 0, 3, 0.1)","title":"Usage"},{"location":"base/functions/utils/#ismodel","text":"Return whether a given value is a Model or an instance of a Model.","title":"isModel"},{"location":"base/functions/utils/#arguments_30","text":"#1 : A value.","title":"Arguments"},{"location":"base/functions/utils/#usage_32","text":"print(isModel(2)) -- false","title":"Usage"},{"location":"base/functions/utils/#istable","text":"Return whether an object can be used as a table. This includes tables themselves as well as all TerraME types ( Cell , CellularSpace , etc.).","title":"isTable"},{"location":"base/functions/utils/#arguments_31","text":"#1 : A value of any type.","title":"Arguments"},{"location":"base/functions/utils/#usage_33","text":"c = Cell{} print(isTable(c))","title":"Usage"},{"location":"base/functions/utils/#see-also_11","text":"type","title":"See also"},{"location":"base/functions/utils/#levenshtein","text":"Return the Levenshtein's distance between two strings. See http://en.wikipedia.org/wiki/Levenshtein_distance for more details.","title":"levenshtein"},{"location":"base/functions/utils/#arguments_32","text":"#1 : A string. #2 : Another string.","title":"Arguments"},{"location":"base/functions/utils/#usage_34","text":"levenshtein(\"abc\", \"abb\")","title":"Usage"},{"location":"base/functions/utils/#replacelatincharacters","text":"This function converts latin characters to hexadecimal code by the characters bytes. It is necessary to Windows OS works correctly with latin characters. Also, it is necessary to set Lua locale as the same as the system locale. See os.setlocale() for more details. The list of unicode characters can be found in https://en.wikipedia.org/wiki/List_of_Unicode_characters.","title":"replaceLatinCharacters"},{"location":"base/functions/utils/#arguments_33","text":"#1 : A string.","title":"Arguments"},{"location":"base/functions/utils/#usage_35","text":"print(replaceLatinCharacters(\ufffd\ufffdguia)) -- \\xE1guia","title":"Usage"},{"location":"base/functions/utils/#round","text":"Round a number given a precision.","title":"round"},{"location":"base/functions/utils/#arguments_34","text":"#1 : A number. #2 : The number of decimal places to be used. The default value is zero.","title":"Arguments"},{"location":"base/functions/utils/#usage_36","text":"round(2.34566, 3)","title":"Usage"},{"location":"base/functions/utils/#stringendswith","text":"Return whether a string ends with a given substring (no case sensitive).","title":"string.endswith"},{"location":"base/functions/utils/#arguments_35","text":"#1 : A string. #2 : A substring describing the end of #1.","title":"Arguments"},{"location":"base/functions/utils/#usage_37","text":"string.endswith(\"abcdef\", \"def\")","title":"Usage"},{"location":"base/functions/utils/#switch","text":"Implement a switch case function, where functions are associated to the available options. This function returns a table that contains a function called caseof, that gets a named table with functions describing what to do for each case (which is the name for the respective function). This table can have a field \"default\" that is executed when the selected value is not one of the available options within caseof. The error messages of this function come from switchInvalidArgumentMsg() and switchInvalidArgumentSuggestionMsg() .","title":"switch"},{"location":"base/functions/utils/#arguments_36","text":"#1 : A named table. #2 : A string with the chosen attribute of the named table.","title":"Arguments"},{"location":"base/functions/utils/#usage_38","text":"data = {protocol = \"udp\"} switch(data, \"protocol\"):caseof{ tcp = function() print(\"tcp\") end, udp = function() print(\"udp\") end }","title":"Usage"},{"location":"base/functions/utils/#tolabel","text":"Convert a string into a more readable name. It is useful to work with Model:init() when the model will be available through a graphical interface. In graphical interfaces (see sessionInfo() ), if the string contains underscores, it replaces them by spaces and convert the next characters to uppercase. Otherwise, it adds a space before each uppercase character. It also converts the first character of the string to uppercase.","title":"toLabel"},{"location":"base/functions/utils/#arguments_37","text":"#1 : A string with the parameter name. #2 : A string with the name of the table the parameter belongs to. This parameter is optional.","title":"Arguments"},{"location":"base/functions/utils/#usage_39","text":"toLabel(\"maxValue\") -- 'Max Value' (with graphical interface) or 'maxValue' (without)","title":"Usage"},{"location":"base/functions/utils/#type","text":"Return the type of an object. It extends the original Lua type() to support TerraME objects, whose type name (for instance \" CellularSpace \" or \" Agent \") is returned instead of \"table\".","title":"type"},{"location":"base/functions/utils/#arguments_38","text":"#1 : Any object or value.","title":"Arguments"},{"location":"base/functions/utils/#usage_40","text":"c = Cell{value = 3} print(type(c)) -- \"Cell\"","title":"Usage"},{"location":"base/functions/utils/#see-also_12","text":"isTable","title":"See also"},{"location":"base/functions/utils/#vardump","text":"Function that returns a string describing the internal content of an object. It converts a table into a string that represents a Lua code that declares such table. If some internal object is named \"parent\", it will be converted into a string with the type of the object. It avoids infinite loops due to the internal cyclic representation of TerraME.","title":"vardump"},{"location":"base/functions/utils/#arguments_39","text":"#1 : The object to be converted into a string. #2 : A string to be placed in the beginning of each line of the returning string.","title":"Arguments"},{"location":"base/functions/utils/#usage_41","text":"vardump{name = \"john\", age = 20} -- { -- age = 20, -- name = \"john\" -- }","title":"Usage"},{"location":"base/types/agent/","text":"Agent An autonomous entity that is capable of performing actions as well as interacting with other Agents and the spatial representation of the model. The Agent constructor gets a table containing the attributes and functions of the Agent. It can be described as a simple table or as a hybrid State machine that has a unique internal state. When the Agent has a set of States, the initial State will be the one declared first. When the agent does not have States, there is a set of user-defined functions that have an associated semantics in TerraME. An Agent can belong to a Society and can have SocialNetworks . Arguments execute: An optional function to describe the behavior of the agent each time step it is executed. See execute() . id: A string with the unique identifier of the Agent. Agents used as instance for a Society cannot have id as the Society will create the ids for each of its Agents. init: An optional function to be executed when the Agent enters in a Society. See init() . on_message: An optional function describing the behavior of the agent when it receives a message. See on_message() . ...: Any other attribute or function for the Agent. It can have, for instance, other \"on_x\" functions to get messages with subject \"x\" (see message() ). Attributes Some attributes of Agent have internal semantics. They can be used as read-only by the modeler. cells: A vector with the Cells representing the default placement of the Agent. It is necessary to use forEachCell() . This value is the same of \"agent.placement.cells\". cObj_: A pointer to a C++ representation of the Agent. Never use this object. id: The unique identifier of the Agent. This attribute only exists when the agent belongs to a Society. parent: The Society it belongs (if any). placement: A Trajectory representing the default placement of the Agent (only when a call to Environment:createPlacement() use the Agent). socialnetworks: A set of SocialNetworks with the connections of the Agent. This value only exists if the Agent has at least one SocialNetwork. state_: An internal state for the Agent. Never use this object. Usage singleFooAgent = Agent { size = 10 , name = \"foo\" , execute = function ( self ) self . size = self . size + 1 self : walk () end , on_hello = function ( self , m ) self : message { receiver = m . sender , content = \"hi\" } end } Functions add Add a Trajectory or a State to the Agent. addSocialNetwork Add a SocialNetwork to the Agent. die Kill the agent and remove it from the Society it belongs. emptyNeighbor Return an empty Neighbor Cell . enter Put the Agent into a Cell . execute The entry point for executing a given Agent. getCell Return the Cell where the Agent is located according to its placement. getCells Return a vector with the Cells pointed by the Agent. getLatency Return the time when the State machine executed the transition to the current state. getSocialNetwork Return a SocialNetwork of the Agent given its name. getStateName Return a string with the current State name. getTrajectoryStatus Return the status of the Trajectories of the Agent. init User-defined function that is used to initialize an Agent when it enters in a given Society (e.g. leave Remove the Agent from its current Cell . message Send a message to another Agent. move Move the Agent to a new Cell . notify Notify the Observers of the Agent. on_message User-defined function that can be implemented to allow Agents to exchange messages. reproduce Create an Agent with the same behavior in the same Cell where the original Agent is (according to its placement). sample Return a random Agent from a SocialNetwork of the Agent. setTrajectoryStatus Activate or not the Trajectories defined for a given Agent. walk Execute a random walk to a neighbor Cell . walkIfEmpty Choose a random Neighbor Cell and move if it is empty. walkToEmpty Walk to one of the available empty Cells in the Neighborhood . add Add a Trajectory or a State to the Agent. Arguments #1 : A State or a Trajectory. Usage ag = Agent{} cs = CellularSpace{xdim = 5} traj = Trajectory{target = cs} ag:add(traj) addSocialNetwork Add a SocialNetwork to the Agent. This function replaces previous SocialNetwork with the same id (if it exists) without showing any warning message. Arguments #1 : A SocialNetwork. #2 : Name of the relation. The default value is \"1\". Usage agent = Agent{} soc = Society{ instance = agent, quantity = 30 } agent = soc:sample() friend1 = soc:sample() friend2 = soc:sample() sn = SocialNetwork() sn:add(friend1) if friend2 ~= friend1 then sn:add(friend2) end agent:addSocialNetwork(sn) See also forEachConnection (Utils) die Kill the agent and remove it from the Society it belongs. It also removes any basic placements from the agents (those used by Agent:enter() , Agent:leave() , and Agent:move() ). After executing this function, it will not be possible to call any function from the Agent anymore. Therefore, if there is any complex placement in the model, it should be removed manually before calling this function. Usage agent = Agent{ execute = function(self) if self.energy <= 0 then agent:die() end end } emptyNeighbor Return an empty Neighbor Cell . If there is no empty neighbor, it returns nil. The Agent needs to have a placement to be able to use this function, and the CellularSpace must have a Neighborhood . This function is recommended to be used only when it is possible to have only one Agent per Cell. Arguments #1 : A string representing the placement to be used. The default value is \"placement\". #2 : A string representing the Neighborhood to be used. The default value is \"1. Usage singleFooAgent = Agent{} cs = CellularSpace{xdim = 10} cs:createNeighborhood() e = Environment{cs, singleFooAgent} e:createPlacement() singleFooAgent:move(singleFooAgent:emptyNeighbor()) -- same as singleFooAgent:moveToEmpty() See also createPlacement (Environment) enter Put the Agent into a Cell . This function supposes that each Agent can be in one and only one Cell along the simulation. If the Agent is already inside of a Cell, use Agent:move() instead. The agent needs to have a placement to be able to use Agent:enter() , Agent:leave() , Agent:move() , or Agent:walk() . Arguments #1 : A Cell. #2 : A string representing the name of the placement to be used. The default value is \"placement\". Usage soc = Society{ instance = Agent{}, quantity = 30 } cs = CellularSpace{ xdim = 10 } env = Environment{soc, cs} env:createPlacement{strategy = \"void\"} agent = soc:sample() agent:enter(cs:sample()) See also createPlacement (Environment) execute The entry point for executing a given Agent. When the Agent is not defined as a composition of States , it is an user-defined function to describe the behavior of an Agent.When the Agent is described as a State machine, execute is automatically defined by TerraME. It activates the Jump of the current State while it jumps from State to State. After that, it executes all the Flows of the current State. Usually, this function is called within an Event , thus the time of the Event can be got directly from the Timer . Arguments #1 : An Event. Usage agent = Agent{ size = 5, execute = function(self) self.size = self.size + 1 end } agent:execute() getCell Return the Cell where the Agent is located according to its placement. It assumes that each Agent belongs to at most one Cell. Arguments #1 : A string representing the name of the placement to be used. The default value is \"placement\". Usage soc = Society{ instance = Agent{}, quantity = 30 } cs = CellularSpace{ xdim = 10 } env = Environment{soc, cs} env:createPlacement{} agent = soc:sample() cell = agent:getCell() getCells Return a vector with the Cells pointed by the Agent. Arguments #1 : A string representing the name of the placement to be used. The default value is \"placement\". Usage soc = Society{ instance = Agent{}, quantity = 30 } cs = CellularSpace{ xdim = 10 } env = Environment{soc, cs} env:createPlacement{} agent = soc:sample() cell = agent:getCells()[1] getLatency Return the time when the State machine executed the transition to the current state. Before executing for the first time, the latency is zero. This function is useful only when the Agent is described as a State machine. Usage -- latency = agent:getLatency() getSocialNetwork Return a SocialNetwork of the Agent given its name. Arguments #1 : Name of the SocialNetwork. Usage agent = Agent{} soc = Society{ instance = agent, quantity = 100 } soc:createSocialNetwork{probability = 0.5, name = \"friends\"} ag = soc:sample() ag:getSocialNetwork(\"friends\") See also createSocialNetwork (Society) forEachConnection (Utils) getStateName Return a string with the current State name. This function is useful only when the Agent is described as a state machine. Usage name = agent:getStateName() getTrajectoryStatus Return the status of the Trajectories of the Agent. This function is useful only when the Agent is described as a State machine. Usage agent:getTrajectoryStatus() See also setTrajectoryStatus init User-defined function that is used to initialize an Agent when it enters in a given Society (e.g. when the Society is created, or when one calls Society:add() ). Usage agent = Agent{ age = Random{min = 1, max = 50, step = 1}, init = function(self) if self.age > 40 then self.wealth = Random():integer(50, 100) else self.wealth = Random():integer(5, 10) end end } soc = Society{ instance = agent, quantity = 10 } print(soc:sample().age) See also Random leave Remove the Agent from its current Cell . If the Agent does not belong to any Cell then it will stop with an error. This function supposes that each Agent can be in one and only one Cell along the simulation. The Agent needs to have a placement to be able to use Agent:enter() , Agent:leave() , Agent:move() , and Agent:walk() . Arguments #1 : A string representing the name of the placement to be used. The default value is \"placement\". Usage ag1 = Agent{} cs = CellularSpace{xdim = 3} myEnv = Environment{cs, ag1} myEnv:createPlacement() ag1:leave() See also createPlacement (Environment) message Send a message to another Agent. The receiver will get a message as a table through its Agent:on_message() (as default). Messages can arrive exactly after they are sent (synchronous) or have some delay (asynchronous). In the latter case, it is necessary to call function Society:synchronize() from the Society they belong to deliver the messages. Arguments delay: A number indicating temporal delay before activating this message. The efault value is zero (no delay, no synchronization required). Whenever a delayed message is received, it comes with an attribute delay equals to true. receiver: The Agent that will get the message. subject: A string describing the function that will be called in the receiver. Given a string x, the receiver will get the message in a function called on_x. The default value is \"message\". The function to receive the message must be implemented by the modeler. See Agent:on_message() for more details. ...: Other arguments are allowed to this function, as the message is a table. The receiver will get all the attributes sent plus an attribute called sender. Usage agent1 = Agent{ on_message = function(self, message) print(\"Got money:\"..message.quantity) end } agent2 = Agent{} agent2:message{ receiver = agent1, content = \"money\", quantity = 20 } move Move the Agent to a new Cell . This function supposes that each Agent can be in one and only one Cell along the simulation. The agent needs to have a placement to be able to use Agent:enter() , Agent:leave() , Agent:move() , or Agent:walk() . Arguments #1 : The new Cell. #2 : A string representing the placement to be used. The default value is \"placement\". Usage ag1 = Agent{} cs = CellularSpace{xdim = 3} soc = Society{ instance = ag1, quantity = 5 } myEnv = Environment{cs, soc} myEnv:createPlacement() ag = soc:sample() cell = cs:sample() ag:move(cell) See also createPlacement (Environment) notify Notify the Observers of the Agent. Arguments #1 : A number representing the notification time. The default value is zero. It is also possible to use an Event as argument. In this case, it will use the result of Event:getTime() . Usage agent = Agent{ value = 1 } Chart{target = agent} agent:notify(1) agent:notify(2) on_message User-defined function that can be implemented to allow Agents to exchange messages. It is executed every time a receiver gets a message. The received message has the same content of the sent message, plus an attribute called sender with the Agent that sent the message. In the case of non-delayed messages, the returning value of this function (executed by the receiver) is also returned as the result of message (executed by the sender). Note that, although in the description below on_message has only one argument, the signature has two arguments, the first one being the agent itself. This function is usually called internally by TerraME, as result of calls of Agent:message() by the modeler. Other functions on_ can be defined by the modeler, and will be called by TerraME according to the subject of the message. Arguments #1 : A table with the received message. It has an attribute called sender with the Agent that sent the message. Usage agent = Agent{ money = 0, on_message = function(self, message) self.money = self.money + message.quantity self:message{receiver = message.sender, subject = \"thanks\"} end, on_thanks = function(self, message) print(\"thanks\") self:message{receiver = message.sender, subject = \"yourewelcome\"} end, on_yourewelcome = function() print(\"yourewelcome\") end } soc = Society{ instance = agent, quantity = 10 } soc:sample():message{ receiver = soc:sample(), quantity = 20 } See also message synchronize (Society) reproduce Create an Agent with the same behavior in the same Cell where the original Agent is (according to its placement). The new Agent is pushed into the same Society the original Agent belongs and placements created using the Society are instantiated with size zero if the only argument of reproduce does not contain such placements. This function returns the new Agent. Arguments #1 : An optional table with attributes of the new Agent. If this table do not contay some of the placements registered in its Society, then they are instantiated and the newborn will be placed in the same Cell of its parent. This functionality supposes that an Agent can be in one and only one Cell for each placement along the simulation. Usage agent = Agent{} soc = Society{ instance = agent, quantity = 100 } soc.agents[1]:reproduce() print(#soc) sample Return a random Agent from a SocialNetwork of the Agent. Arguments #1 : A string with the name of the SocialNetwork. The default value is \"1\". Usage ag = Agent{} soc = Society{instance = ag, quantity = 5} sn = SocialNetwork() forEachAgent(soc, function(agent) sn:add(agent) end) ag:addSocialNetwork(sn) friend = ag:sample() See also getSocialNetwork setTrajectoryStatus Activate or not the Trajectories defined for a given Agent. Arguments #1 : Use or not the Trajectories. As default, Trajectories are turned off. If status is true, when executed, the Agent that contains States will automatically traverse all trajectories defined within it, which means that Agent:execute() will be executed once for each of its Cells . This function is useful only when the Agent is described as a State machine. Usage -- agent:setTrajectoryStatus(true) walk Execute a random walk to a neighbor Cell . This function supposes that each Agent can be in one and only one Cell along the simulation. The Agent needs to have a placement to be able to use Agent:enter() , Agent:leave() , Agent:move() , and Agent:walk() . Arguments #1 : A string representing the placement to be used. The default value is \"placement\". #2 : A string representing the Neighborhood to be used. The default value is \"1. Usage singleFooAgent = Agent{} cs = CellularSpace{xdim = 10} cs:createNeighborhood() e = Environment{cs, singleFooAgent} e:createPlacement() singleFooAgent:walk() singleFooAgent:walk() See also createPlacement (Environment) walkIfEmpty Choose a random Neighbor Cell and move if it is empty. Note that if it selects a non-empty Cell the Agent will not move, even if there are empty Cells in the Neighborhood . The Agent needs to have a placement to be able to use this function, and the CellularSpace must have a Neighborhood. This function is recommended to be used only when it is possible to have only one Agent per Cell. Arguments #1 : A string representing the placement to be used. The default value is \"placement\". #2 : A string representing the Neighborhood to be used. The default value is \"1. Usage singleFooAgent = Agent{} cs = CellularSpace{xdim = 10} cs:createNeighborhood() e = Environment{cs, singleFooAgent} e:createPlacement() singleFooAgent:walkIfEmpty() See also createPlacement (Environment) walkToEmpty Walk to one of the available empty Cells in the Neighborhood . If there is no empty neighbor, the Agent will not move. The Agent needs to have a placement to be able to use this function, and the CellularSpace must have a Neighborhood. This function is recommended to be used only when it is possible to have only one Agent per Cell. Arguments #1 : A string representing the placement to be used. The default value is \"placement\". #2 : A string representing the Neighborhood to be used. The default value is \"1. Usage singleFooAgent = Agent{} cs = CellularSpace{xdim = 10} cs:createNeighborhood() e = Environment{cs, singleFooAgent} e:createPlacement() singleFooAgent:walkToEmpty() See also createPlacement (Environment)","title":"Agent"},{"location":"base/types/agent/#agent","text":"An autonomous entity that is capable of performing actions as well as interacting with other Agents and the spatial representation of the model. The Agent constructor gets a table containing the attributes and functions of the Agent. It can be described as a simple table or as a hybrid State machine that has a unique internal state. When the Agent has a set of States, the initial State will be the one declared first. When the agent does not have States, there is a set of user-defined functions that have an associated semantics in TerraME. An Agent can belong to a Society and can have SocialNetworks .","title":"Agent"},{"location":"base/types/agent/#arguments","text":"execute: An optional function to describe the behavior of the agent each time step it is executed. See execute() . id: A string with the unique identifier of the Agent. Agents used as instance for a Society cannot have id as the Society will create the ids for each of its Agents. init: An optional function to be executed when the Agent enters in a Society. See init() . on_message: An optional function describing the behavior of the agent when it receives a message. See on_message() . ...: Any other attribute or function for the Agent. It can have, for instance, other \"on_x\" functions to get messages with subject \"x\" (see message() ).","title":"Arguments"},{"location":"base/types/agent/#attributes","text":"Some attributes of Agent have internal semantics. They can be used as read-only by the modeler. cells: A vector with the Cells representing the default placement of the Agent. It is necessary to use forEachCell() . This value is the same of \"agent.placement.cells\". cObj_: A pointer to a C++ representation of the Agent. Never use this object. id: The unique identifier of the Agent. This attribute only exists when the agent belongs to a Society. parent: The Society it belongs (if any). placement: A Trajectory representing the default placement of the Agent (only when a call to Environment:createPlacement() use the Agent). socialnetworks: A set of SocialNetworks with the connections of the Agent. This value only exists if the Agent has at least one SocialNetwork. state_: An internal state for the Agent. Never use this object.","title":"Attributes"},{"location":"base/types/agent/#usage","text":"singleFooAgent = Agent { size = 10 , name = \"foo\" , execute = function ( self ) self . size = self . size + 1 self : walk () end , on_hello = function ( self , m ) self : message { receiver = m . sender , content = \"hi\" } end }","title":"Usage"},{"location":"base/types/agent/#functions","text":"add Add a Trajectory or a State to the Agent. addSocialNetwork Add a SocialNetwork to the Agent. die Kill the agent and remove it from the Society it belongs. emptyNeighbor Return an empty Neighbor Cell . enter Put the Agent into a Cell . execute The entry point for executing a given Agent. getCell Return the Cell where the Agent is located according to its placement. getCells Return a vector with the Cells pointed by the Agent. getLatency Return the time when the State machine executed the transition to the current state. getSocialNetwork Return a SocialNetwork of the Agent given its name. getStateName Return a string with the current State name. getTrajectoryStatus Return the status of the Trajectories of the Agent. init User-defined function that is used to initialize an Agent when it enters in a given Society (e.g. leave Remove the Agent from its current Cell . message Send a message to another Agent. move Move the Agent to a new Cell . notify Notify the Observers of the Agent. on_message User-defined function that can be implemented to allow Agents to exchange messages. reproduce Create an Agent with the same behavior in the same Cell where the original Agent is (according to its placement). sample Return a random Agent from a SocialNetwork of the Agent. setTrajectoryStatus Activate or not the Trajectories defined for a given Agent. walk Execute a random walk to a neighbor Cell . walkIfEmpty Choose a random Neighbor Cell and move if it is empty. walkToEmpty Walk to one of the available empty Cells in the Neighborhood .","title":"Functions"},{"location":"base/types/agent/#add","text":"Add a Trajectory or a State to the Agent.","title":"add"},{"location":"base/types/agent/#arguments_1","text":"#1 : A State or a Trajectory.","title":"Arguments"},{"location":"base/types/agent/#usage_1","text":"ag = Agent{} cs = CellularSpace{xdim = 5} traj = Trajectory{target = cs} ag:add(traj)","title":"Usage"},{"location":"base/types/agent/#addsocialnetwork","text":"Add a SocialNetwork to the Agent. This function replaces previous SocialNetwork with the same id (if it exists) without showing any warning message.","title":"addSocialNetwork"},{"location":"base/types/agent/#arguments_2","text":"#1 : A SocialNetwork. #2 : Name of the relation. The default value is \"1\".","title":"Arguments"},{"location":"base/types/agent/#usage_2","text":"agent = Agent{} soc = Society{ instance = agent, quantity = 30 } agent = soc:sample() friend1 = soc:sample() friend2 = soc:sample() sn = SocialNetwork() sn:add(friend1) if friend2 ~= friend1 then sn:add(friend2) end agent:addSocialNetwork(sn)","title":"Usage"},{"location":"base/types/agent/#see-also","text":"forEachConnection (Utils)","title":"See also"},{"location":"base/types/agent/#die","text":"Kill the agent and remove it from the Society it belongs. It also removes any basic placements from the agents (those used by Agent:enter() , Agent:leave() , and Agent:move() ). After executing this function, it will not be possible to call any function from the Agent anymore. Therefore, if there is any complex placement in the model, it should be removed manually before calling this function.","title":"die"},{"location":"base/types/agent/#usage_3","text":"agent = Agent{ execute = function(self) if self.energy <= 0 then agent:die() end end }","title":"Usage"},{"location":"base/types/agent/#emptyneighbor","text":"Return an empty Neighbor Cell . If there is no empty neighbor, it returns nil. The Agent needs to have a placement to be able to use this function, and the CellularSpace must have a Neighborhood . This function is recommended to be used only when it is possible to have only one Agent per Cell.","title":"emptyNeighbor"},{"location":"base/types/agent/#arguments_3","text":"#1 : A string representing the placement to be used. The default value is \"placement\". #2 : A string representing the Neighborhood to be used. The default value is \"1.","title":"Arguments"},{"location":"base/types/agent/#usage_4","text":"singleFooAgent = Agent{} cs = CellularSpace{xdim = 10} cs:createNeighborhood() e = Environment{cs, singleFooAgent} e:createPlacement() singleFooAgent:move(singleFooAgent:emptyNeighbor()) -- same as singleFooAgent:moveToEmpty()","title":"Usage"},{"location":"base/types/agent/#see-also_1","text":"createPlacement (Environment)","title":"See also"},{"location":"base/types/agent/#enter","text":"Put the Agent into a Cell . This function supposes that each Agent can be in one and only one Cell along the simulation. If the Agent is already inside of a Cell, use Agent:move() instead. The agent needs to have a placement to be able to use Agent:enter() , Agent:leave() , Agent:move() , or Agent:walk() .","title":"enter"},{"location":"base/types/agent/#arguments_4","text":"#1 : A Cell. #2 : A string representing the name of the placement to be used. The default value is \"placement\".","title":"Arguments"},{"location":"base/types/agent/#usage_5","text":"soc = Society{ instance = Agent{}, quantity = 30 } cs = CellularSpace{ xdim = 10 } env = Environment{soc, cs} env:createPlacement{strategy = \"void\"} agent = soc:sample() agent:enter(cs:sample())","title":"Usage"},{"location":"base/types/agent/#see-also_2","text":"createPlacement (Environment)","title":"See also"},{"location":"base/types/agent/#execute","text":"The entry point for executing a given Agent. When the Agent is not defined as a composition of States , it is an user-defined function to describe the behavior of an Agent.When the Agent is described as a State machine, execute is automatically defined by TerraME. It activates the Jump of the current State while it jumps from State to State. After that, it executes all the Flows of the current State. Usually, this function is called within an Event , thus the time of the Event can be got directly from the Timer .","title":"execute"},{"location":"base/types/agent/#arguments_5","text":"#1 : An Event.","title":"Arguments"},{"location":"base/types/agent/#usage_6","text":"agent = Agent{ size = 5, execute = function(self) self.size = self.size + 1 end } agent:execute()","title":"Usage"},{"location":"base/types/agent/#getcell","text":"Return the Cell where the Agent is located according to its placement. It assumes that each Agent belongs to at most one Cell.","title":"getCell"},{"location":"base/types/agent/#arguments_6","text":"#1 : A string representing the name of the placement to be used. The default value is \"placement\".","title":"Arguments"},{"location":"base/types/agent/#usage_7","text":"soc = Society{ instance = Agent{}, quantity = 30 } cs = CellularSpace{ xdim = 10 } env = Environment{soc, cs} env:createPlacement{} agent = soc:sample() cell = agent:getCell()","title":"Usage"},{"location":"base/types/agent/#getcells","text":"Return a vector with the Cells pointed by the Agent.","title":"getCells"},{"location":"base/types/agent/#arguments_7","text":"#1 : A string representing the name of the placement to be used. The default value is \"placement\".","title":"Arguments"},{"location":"base/types/agent/#usage_8","text":"soc = Society{ instance = Agent{}, quantity = 30 } cs = CellularSpace{ xdim = 10 } env = Environment{soc, cs} env:createPlacement{} agent = soc:sample() cell = agent:getCells()[1]","title":"Usage"},{"location":"base/types/agent/#getlatency","text":"Return the time when the State machine executed the transition to the current state. Before executing for the first time, the latency is zero. This function is useful only when the Agent is described as a State machine.","title":"getLatency"},{"location":"base/types/agent/#usage_9","text":"-- latency = agent:getLatency()","title":"Usage"},{"location":"base/types/agent/#getsocialnetwork","text":"Return a SocialNetwork of the Agent given its name.","title":"getSocialNetwork"},{"location":"base/types/agent/#arguments_8","text":"#1 : Name of the SocialNetwork.","title":"Arguments"},{"location":"base/types/agent/#usage_10","text":"agent = Agent{} soc = Society{ instance = agent, quantity = 100 } soc:createSocialNetwork{probability = 0.5, name = \"friends\"} ag = soc:sample() ag:getSocialNetwork(\"friends\")","title":"Usage"},{"location":"base/types/agent/#see-also_3","text":"createSocialNetwork (Society) forEachConnection (Utils)","title":"See also"},{"location":"base/types/agent/#getstatename","text":"Return a string with the current State name. This function is useful only when the Agent is described as a state machine.","title":"getStateName"},{"location":"base/types/agent/#usage_11","text":"name = agent:getStateName()","title":"Usage"},{"location":"base/types/agent/#gettrajectorystatus","text":"Return the status of the Trajectories of the Agent. This function is useful only when the Agent is described as a State machine.","title":"getTrajectoryStatus"},{"location":"base/types/agent/#usage_12","text":"agent:getTrajectoryStatus()","title":"Usage"},{"location":"base/types/agent/#see-also_4","text":"setTrajectoryStatus","title":"See also"},{"location":"base/types/agent/#init","text":"User-defined function that is used to initialize an Agent when it enters in a given Society (e.g. when the Society is created, or when one calls Society:add() ).","title":"init"},{"location":"base/types/agent/#usage_13","text":"agent = Agent{ age = Random{min = 1, max = 50, step = 1}, init = function(self) if self.age > 40 then self.wealth = Random():integer(50, 100) else self.wealth = Random():integer(5, 10) end end } soc = Society{ instance = agent, quantity = 10 } print(soc:sample().age)","title":"Usage"},{"location":"base/types/agent/#see-also_5","text":"Random","title":"See also"},{"location":"base/types/agent/#leave","text":"Remove the Agent from its current Cell . If the Agent does not belong to any Cell then it will stop with an error. This function supposes that each Agent can be in one and only one Cell along the simulation. The Agent needs to have a placement to be able to use Agent:enter() , Agent:leave() , Agent:move() , and Agent:walk() .","title":"leave"},{"location":"base/types/agent/#arguments_9","text":"#1 : A string representing the name of the placement to be used. The default value is \"placement\".","title":"Arguments"},{"location":"base/types/agent/#usage_14","text":"ag1 = Agent{} cs = CellularSpace{xdim = 3} myEnv = Environment{cs, ag1} myEnv:createPlacement() ag1:leave()","title":"Usage"},{"location":"base/types/agent/#see-also_6","text":"createPlacement (Environment)","title":"See also"},{"location":"base/types/agent/#message","text":"Send a message to another Agent. The receiver will get a message as a table through its Agent:on_message() (as default). Messages can arrive exactly after they are sent (synchronous) or have some delay (asynchronous). In the latter case, it is necessary to call function Society:synchronize() from the Society they belong to deliver the messages.","title":"message"},{"location":"base/types/agent/#arguments_10","text":"delay: A number indicating temporal delay before activating this message. The efault value is zero (no delay, no synchronization required). Whenever a delayed message is received, it comes with an attribute delay equals to true. receiver: The Agent that will get the message. subject: A string describing the function that will be called in the receiver. Given a string x, the receiver will get the message in a function called on_x. The default value is \"message\". The function to receive the message must be implemented by the modeler. See Agent:on_message() for more details. ...: Other arguments are allowed to this function, as the message is a table. The receiver will get all the attributes sent plus an attribute called sender.","title":"Arguments"},{"location":"base/types/agent/#usage_15","text":"agent1 = Agent{ on_message = function(self, message) print(\"Got money:\"..message.quantity) end } agent2 = Agent{} agent2:message{ receiver = agent1, content = \"money\", quantity = 20 }","title":"Usage"},{"location":"base/types/agent/#move","text":"Move the Agent to a new Cell . This function supposes that each Agent can be in one and only one Cell along the simulation. The agent needs to have a placement to be able to use Agent:enter() , Agent:leave() , Agent:move() , or Agent:walk() .","title":"move"},{"location":"base/types/agent/#arguments_11","text":"#1 : The new Cell. #2 : A string representing the placement to be used. The default value is \"placement\".","title":"Arguments"},{"location":"base/types/agent/#usage_16","text":"ag1 = Agent{} cs = CellularSpace{xdim = 3} soc = Society{ instance = ag1, quantity = 5 } myEnv = Environment{cs, soc} myEnv:createPlacement() ag = soc:sample() cell = cs:sample() ag:move(cell)","title":"Usage"},{"location":"base/types/agent/#see-also_7","text":"createPlacement (Environment)","title":"See also"},{"location":"base/types/agent/#notify","text":"Notify the Observers of the Agent.","title":"notify"},{"location":"base/types/agent/#arguments_12","text":"#1 : A number representing the notification time. The default value is zero. It is also possible to use an Event as argument. In this case, it will use the result of Event:getTime() .","title":"Arguments"},{"location":"base/types/agent/#usage_17","text":"agent = Agent{ value = 1 } Chart{target = agent} agent:notify(1) agent:notify(2)","title":"Usage"},{"location":"base/types/agent/#on_message","text":"User-defined function that can be implemented to allow Agents to exchange messages. It is executed every time a receiver gets a message. The received message has the same content of the sent message, plus an attribute called sender with the Agent that sent the message. In the case of non-delayed messages, the returning value of this function (executed by the receiver) is also returned as the result of message (executed by the sender). Note that, although in the description below on_message has only one argument, the signature has two arguments, the first one being the agent itself. This function is usually called internally by TerraME, as result of calls of Agent:message() by the modeler. Other functions on_ can be defined by the modeler, and will be called by TerraME according to the subject of the message.","title":"on_message"},{"location":"base/types/agent/#arguments_13","text":"#1 : A table with the received message. It has an attribute called sender with the Agent that sent the message.","title":"Arguments"},{"location":"base/types/agent/#usage_18","text":"agent = Agent{ money = 0, on_message = function(self, message) self.money = self.money + message.quantity self:message{receiver = message.sender, subject = \"thanks\"} end, on_thanks = function(self, message) print(\"thanks\") self:message{receiver = message.sender, subject = \"yourewelcome\"} end, on_yourewelcome = function() print(\"yourewelcome\") end } soc = Society{ instance = agent, quantity = 10 } soc:sample():message{ receiver = soc:sample(), quantity = 20 }","title":"Usage"},{"location":"base/types/agent/#see-also_8","text":"message synchronize (Society)","title":"See also"},{"location":"base/types/agent/#reproduce","text":"Create an Agent with the same behavior in the same Cell where the original Agent is (according to its placement). The new Agent is pushed into the same Society the original Agent belongs and placements created using the Society are instantiated with size zero if the only argument of reproduce does not contain such placements. This function returns the new Agent.","title":"reproduce"},{"location":"base/types/agent/#arguments_14","text":"#1 : An optional table with attributes of the new Agent. If this table do not contay some of the placements registered in its Society, then they are instantiated and the newborn will be placed in the same Cell of its parent. This functionality supposes that an Agent can be in one and only one Cell for each placement along the simulation.","title":"Arguments"},{"location":"base/types/agent/#usage_19","text":"agent = Agent{} soc = Society{ instance = agent, quantity = 100 } soc.agents[1]:reproduce() print(#soc)","title":"Usage"},{"location":"base/types/agent/#sample","text":"Return a random Agent from a SocialNetwork of the Agent.","title":"sample"},{"location":"base/types/agent/#arguments_15","text":"#1 : A string with the name of the SocialNetwork. The default value is \"1\".","title":"Arguments"},{"location":"base/types/agent/#usage_20","text":"ag = Agent{} soc = Society{instance = ag, quantity = 5} sn = SocialNetwork() forEachAgent(soc, function(agent) sn:add(agent) end) ag:addSocialNetwork(sn) friend = ag:sample()","title":"Usage"},{"location":"base/types/agent/#see-also_9","text":"getSocialNetwork","title":"See also"},{"location":"base/types/agent/#settrajectorystatus","text":"Activate or not the Trajectories defined for a given Agent.","title":"setTrajectoryStatus"},{"location":"base/types/agent/#arguments_16","text":"#1 : Use or not the Trajectories. As default, Trajectories are turned off. If status is true, when executed, the Agent that contains States will automatically traverse all trajectories defined within it, which means that Agent:execute() will be executed once for each of its Cells . This function is useful only when the Agent is described as a State machine.","title":"Arguments"},{"location":"base/types/agent/#usage_21","text":"-- agent:setTrajectoryStatus(true)","title":"Usage"},{"location":"base/types/agent/#walk","text":"Execute a random walk to a neighbor Cell . This function supposes that each Agent can be in one and only one Cell along the simulation. The Agent needs to have a placement to be able to use Agent:enter() , Agent:leave() , Agent:move() , and Agent:walk() .","title":"walk"},{"location":"base/types/agent/#arguments_17","text":"#1 : A string representing the placement to be used. The default value is \"placement\". #2 : A string representing the Neighborhood to be used. The default value is \"1.","title":"Arguments"},{"location":"base/types/agent/#usage_22","text":"singleFooAgent = Agent{} cs = CellularSpace{xdim = 10} cs:createNeighborhood() e = Environment{cs, singleFooAgent} e:createPlacement() singleFooAgent:walk() singleFooAgent:walk()","title":"Usage"},{"location":"base/types/agent/#see-also_10","text":"createPlacement (Environment)","title":"See also"},{"location":"base/types/agent/#walkifempty","text":"Choose a random Neighbor Cell and move if it is empty. Note that if it selects a non-empty Cell the Agent will not move, even if there are empty Cells in the Neighborhood . The Agent needs to have a placement to be able to use this function, and the CellularSpace must have a Neighborhood. This function is recommended to be used only when it is possible to have only one Agent per Cell.","title":"walkIfEmpty"},{"location":"base/types/agent/#arguments_18","text":"#1 : A string representing the placement to be used. The default value is \"placement\". #2 : A string representing the Neighborhood to be used. The default value is \"1.","title":"Arguments"},{"location":"base/types/agent/#usage_23","text":"singleFooAgent = Agent{} cs = CellularSpace{xdim = 10} cs:createNeighborhood() e = Environment{cs, singleFooAgent} e:createPlacement() singleFooAgent:walkIfEmpty()","title":"Usage"},{"location":"base/types/agent/#see-also_11","text":"createPlacement (Environment)","title":"See also"},{"location":"base/types/agent/#walktoempty","text":"Walk to one of the available empty Cells in the Neighborhood . If there is no empty neighbor, the Agent will not move. The Agent needs to have a placement to be able to use this function, and the CellularSpace must have a Neighborhood. This function is recommended to be used only when it is possible to have only one Agent per Cell.","title":"walkToEmpty"},{"location":"base/types/agent/#arguments_19","text":"#1 : A string representing the placement to be used. The default value is \"placement\". #2 : A string representing the Neighborhood to be used. The default value is \"1.","title":"Arguments"},{"location":"base/types/agent/#usage_24","text":"singleFooAgent = Agent{} cs = CellularSpace{xdim = 10} cs:createNeighborhood() e = Environment{cs, singleFooAgent} e:createPlacement() singleFooAgent:walkToEmpty()","title":"Usage"},{"location":"base/types/agent/#see-also_12","text":"createPlacement (Environment)","title":"See also"},{"location":"base/types/automaton/","text":"Automaton A hybrid state machine that needs to be located on a CellularSpace , and is replicated over each Cell of the space. It has independent States in each Cell. Arguments id : A string that names the Automanton. Attributes Some attributes of Automaton have internal semantics. They can be used as read-only by the modeler. parent : The Environment it belongs. Usage automaton = Automaton { id = \"MyAutomaton\", State {...}, -- ... State {...} } Functions add Add a new Trajectory or State to the Automaton. execute Execute the State machine. getId Return the unique identifier name of the Automaton. getState Get a State of the Automaton according to a given position. getStateName Return the name of the current State . getStates Get all the States inside the Automaton. notify Notify every Observer connected to the Automaton. setId Set the unique identifier of the Automaton. setTrajectoryStatus Activate or not the Trajectories defined for the Automaton. add Add a new Trajectory or State to the Automaton. It returns a boolean value indicating whether the new element was successfully added. Arguments #1 : A Trajectory or State. Usage automaton:add(state) automaton:add(trajectory) execute Execute the State machine. First, it executes the Jump of the current State while it jumps from State to State. When the machine stops jumping, it executes all the Flows of the current State. Usually, this function is called within an Event , thus the time of the Event can be got from the Timer . It returns a boolean value indicating whether the Jumps were executed correctly. Arguments #1 : An Event. Usage automaton:execute(event) getId Return the unique identifier name of the Automaton. Usage automaton:getId() getState Get a State of the Automaton according to a given position. Arguments #1 : A number indicating the position of the State to be retrieved. Usage state = automaton:getState(1) getStateName Return the name of the current State . As an Automaton has independent States in each Cell , it requires a location to return its State name. Arguments #1 : A Cell. Usage id = automaton:getStateName(cell) getStates Get all the States inside the Automaton. It returns a vector. Usage state = automaton:getStates()[1] notify Notify every Observer connected to the Automaton. Arguments #1 : An integer number representing the notification time. The default value is zero. It is also possible to use an Event as argument. In this case, it will use the result of Event:getTime() . Usage automaton:notify() setId Set the unique identifier of the Automaton. Return a boolean value indicating whether the id was changed correctly. Arguments #1 : A string that names the Automaton. Usage automaton:setId(\"newid\") setTrajectoryStatus Activate or not the Trajectories defined for the Automaton. Returns whether the change was successfully executed. When the Automaton is built its status is not activated. Arguments #1 : A boolean that indicates if the Trajectories will be activated. Usage automaton:setTrajectoryStatus(true)","title":"Automaton"},{"location":"base/types/automaton/#automaton","text":"A hybrid state machine that needs to be located on a CellularSpace , and is replicated over each Cell of the space. It has independent States in each Cell.","title":"Automaton"},{"location":"base/types/automaton/#arguments","text":"id : A string that names the Automanton.","title":"Arguments"},{"location":"base/types/automaton/#attributes","text":"Some attributes of Automaton have internal semantics. They can be used as read-only by the modeler. parent : The Environment it belongs.","title":"Attributes"},{"location":"base/types/automaton/#usage","text":"automaton = Automaton { id = \"MyAutomaton\", State {...}, -- ... State {...} }","title":"Usage"},{"location":"base/types/automaton/#functions","text":"add Add a new Trajectory or State to the Automaton. execute Execute the State machine. getId Return the unique identifier name of the Automaton. getState Get a State of the Automaton according to a given position. getStateName Return the name of the current State . getStates Get all the States inside the Automaton. notify Notify every Observer connected to the Automaton. setId Set the unique identifier of the Automaton. setTrajectoryStatus Activate or not the Trajectories defined for the Automaton.","title":"Functions"},{"location":"base/types/automaton/#add","text":"Add a new Trajectory or State to the Automaton. It returns a boolean value indicating whether the new element was successfully added.","title":"add"},{"location":"base/types/automaton/#arguments_1","text":"#1 : A Trajectory or State.","title":"Arguments"},{"location":"base/types/automaton/#usage_1","text":"automaton:add(state) automaton:add(trajectory)","title":"Usage"},{"location":"base/types/automaton/#execute","text":"Execute the State machine. First, it executes the Jump of the current State while it jumps from State to State. When the machine stops jumping, it executes all the Flows of the current State. Usually, this function is called within an Event , thus the time of the Event can be got from the Timer . It returns a boolean value indicating whether the Jumps were executed correctly.","title":"execute"},{"location":"base/types/automaton/#arguments_2","text":"#1 : An Event.","title":"Arguments"},{"location":"base/types/automaton/#usage_2","text":"automaton:execute(event)","title":"Usage"},{"location":"base/types/automaton/#getid","text":"Return the unique identifier name of the Automaton.","title":"getId"},{"location":"base/types/automaton/#usage_3","text":"automaton:getId()","title":"Usage"},{"location":"base/types/automaton/#getstate","text":"Get a State of the Automaton according to a given position.","title":"getState"},{"location":"base/types/automaton/#arguments_3","text":"#1 : A number indicating the position of the State to be retrieved.","title":"Arguments"},{"location":"base/types/automaton/#usage_4","text":"state = automaton:getState(1)","title":"Usage"},{"location":"base/types/automaton/#getstatename","text":"Return the name of the current State . As an Automaton has independent States in each Cell , it requires a location to return its State name.","title":"getStateName"},{"location":"base/types/automaton/#arguments_4","text":"#1 : A Cell.","title":"Arguments"},{"location":"base/types/automaton/#usage_5","text":"id = automaton:getStateName(cell)","title":"Usage"},{"location":"base/types/automaton/#getstates","text":"Get all the States inside the Automaton. It returns a vector.","title":"getStates"},{"location":"base/types/automaton/#usage_6","text":"state = automaton:getStates()[1]","title":"Usage"},{"location":"base/types/automaton/#notify","text":"Notify every Observer connected to the Automaton.","title":"notify"},{"location":"base/types/automaton/#arguments_5","text":"#1 : An integer number representing the notification time. The default value is zero. It is also possible to use an Event as argument. In this case, it will use the result of Event:getTime() .","title":"Arguments"},{"location":"base/types/automaton/#usage_7","text":"automaton:notify()","title":"Usage"},{"location":"base/types/automaton/#setid","text":"Set the unique identifier of the Automaton. Return a boolean value indicating whether the id was changed correctly.","title":"setId"},{"location":"base/types/automaton/#arguments_6","text":"#1 : A string that names the Automaton.","title":"Arguments"},{"location":"base/types/automaton/#usage_8","text":"automaton:setId(\"newid\")","title":"Usage"},{"location":"base/types/automaton/#settrajectorystatus","text":"Activate or not the Trajectories defined for the Automaton. Returns whether the change was successfully executed. When the Automaton is built its status is not activated.","title":"setTrajectoryStatus"},{"location":"base/types/automaton/#arguments_7","text":"#1 : A boolean that indicates if the Trajectories will be activated.","title":"Arguments"},{"location":"base/types/automaton/#usage_9","text":"automaton:setTrajectoryStatus(true)","title":"Usage"},{"location":"base/types/cell/","text":"Cell A spatial location with homogeneous internal content. It is a table that may contain nearness relations as well as persistent and runtime attributes. Persistent attributes can be loaded from databases using CellularSpace , while runtime attributes can be created along the simulation. Arguments init : An optional function that describes how to initialize a Cell that is going to be used as an instance of a CellularSpace. See init() . x : An integer number with the x location of the Cell. The default value is 0. y : An integer number with the y location of the Cell. The default value is 0. ... : Any other attribute or function for the Cell. Attributes Some attributes of Cell have internal semantics. They can be used as read-only by the modeler. agents : A vector with the Agents representing the default placement of the Cell. It is necessary to use forEachAgent() . This value is the same of \"cell.placement.agents\". cObj_ : A pointer to a C++ representation of the Cell. Never use this object. parent : The CellularSpace it belongs. past : A copy of the attributes at the time of the last synchronization. placement : A SocialNetwork representing the default placement of the Cell (only when a call to Environment:createPlacement() use the Cell). Usage cell = Cell { cover = \"forest\", soilWater = 0 } See also forEachNeighborhood (Utils) Functions addNeighborhood Add a new Neighborhood to the Cell. area Return the Cell area. distance Returns the shortest distance between the cells. getAgent Return an Agent that belongs to the Cell. getAgents Return the Agents that belong to the Cell. getId Return a string with the unique identifier of the Cell. getNeighborhood Return a Neighborhood of the Cell. init User-defined function that is used to initialize a Cell when a CellularSpace is created. isEmpty Return whether the cell is empty according to a given placement. notify Notify every Observer connected to the Cell. on_synchronize An optional user-defined function that is activated just after one calls Cell:synchronize() . sample Return a random Cell from a Neighborhood of the Cell. setId Update the unique identifier of the Cell. synchronize Synchronizes the Cell. # Return the number of Neighborhoods in the Cell. addNeighborhood Add a new Neighborhood to the Cell. This function replaces previous Neighborhood with the same name (if it exists) without showing any warning message. Arguments #1 : A Neighborhood. #2 : Neighborhood's name. The default value is \"1\". Usage c1 = Cell{} c2 = Cell{} n = Neighborhood() n:add(c2) c1:addNeighborhood(n) See also Neighborhood area Return the Cell area. Usage cell:area() distance Returns the shortest distance between the cells. If the cell do not have geometry, it calculates the Euclidean distance to a given Cell using the attributes x and y of both Cells. Arguments #1 : Other Cell. Usage c1 = Cell{x = 5, y = 5} c2 = Cell{x = 10, y = 10} dist = c1:distance(c2) print(dist) getAgent Return an Agent that belongs to the Cell. It assumes that there is at most one Agent per Cell. If there is no Agent within the cell then it returns nil. Arguments #1 : A string with the name of the placement. The default value is \"placement\". Usage ag = Agent{} s = Society{instance = ag, quantity = 2} ag1 = s.agents[1] cs = CellularSpace{xdim = 3} c = cs.cells[1] myEnv = Environment{cs, ag1} myEnv:createPlacement{strategy = \"void\"} ag1:enter(c) if c:getAgent() == ag1 then print(\"equal\") end getAgents Return the Agents that belong to the Cell. The returning vector. Arguments #1 : A string with the name of the placement. The default value is \"placement\". Usage ag = Agent{} s = Society{instance = ag, quantity = 2} ag1 = s.agents[1] cs = CellularSpace{xdim = 3} c = cs.cells[1] myEnv = Environment{cs, ag1} myEnv:createPlacement{strategy = \"void\"} ag1:enter(c) if c:getAgents()[1] == ag1 then print(\"equal\") end getId Return a string with the unique identifier of the Cell. Note that any Cell that belongs to a CellularSpace has an id. Usage cell = Cell{id = \"2\"} id = cell:getId() print(id) getNeighborhood Return a Neighborhood of the Cell. If the Neighborhood does not exist then it returns nil. Arguments #1 : A string with the neighborhood's name to be retrieved. The default value is \"1\". Usage cs = CellularSpace{ xdim = 10 } cs:createNeighborhood() n = cs:sample():getNeighborhood() print(#n) init User-defined function that is used to initialize a Cell when a CellularSpace is created. This function gets the Cell itself as argument. Usage cell = Cell{ init = function(self) self.population = Random():integer(1, 100) -- initial population chosen randomly end, -- ... } cs = CellularSpace{ xdim = 10, instance = cell } print(cs:sample().population) See also Random isEmpty Return whether the cell is empty according to a given placement. An empty Cell does not contain any Agent . Arguments #1 : A string with the name of the placement. The default value is \"placement\". Usage ag = Agent{} s = Society{instance = ag, quantity = 2} ag1 = s.agents[1] cs = CellularSpace{xdim = 3} c = cs.cells[1] myEnv = Environment{cs, ag1} myEnv:createPlacement{strategy = \"void\"} ag1:enter(c) if not c:isEmpty() then print(\"not empty\") end notify Notify every Observer connected to the Cell. Arguments #1 : A positive number representing the notification time. The default value is zero. It is also possible to use an Event as argument. In this case, it will use the result of Event:getTime() . Usage cell = Cell{value = 5} Chart{target = cell} cell:notify(1) cell:notify(2) on_synchronize An optional user-defined function that is activated just after one calls Cell:synchronize() . Usage cell = Cell{ value = 3, on_synchronize = function(self) self.value = 0 end } cell:synchronize() print(cell.value) -- 0 sample Return a random Cell from a Neighborhood of the Cell. Arguments #1 : A string with the name of the Neighborhood. The default value is \"1\". Usage cs = CellularSpace{ xdim = 10 } cs:createNeighborhood() cell = cs:sample() neigh = cell:sample() print(type(neigh)) See also getNeighborhood setId Update the unique identifier of the Cell. Arguments #1 : A string with the new unique identifier. Usage cell = Cell{id = \"2\"} cell:setId(\"newid\") id = cell:getId() print(id) synchronize Synchronizes the Cell. TerraME can keep two copies of the attributes of a Cell in memory: one stores the past values and the other stores the current (present) values. Synchronize copies the current values to a table named past, within the Cell. The previous past is therefore overwritten. In the end synchronize, it calls Cell:on_synchronize() if it exists. Usage cell = Cell{value = 5} cell:synchronize() print(cell.past.value) See also synchronize (CellularSpace) # Return the number of Neighborhoods in the Cell. Usage cell = Cell{} cell:addNeighborhood(Neighborhood()) cell:addNeighborhood(Neighborhood()) size = #cell print(size)","title":"Cell"},{"location":"base/types/cell/#cell","text":"A spatial location with homogeneous internal content. It is a table that may contain nearness relations as well as persistent and runtime attributes. Persistent attributes can be loaded from databases using CellularSpace , while runtime attributes can be created along the simulation.","title":"Cell"},{"location":"base/types/cell/#arguments","text":"init : An optional function that describes how to initialize a Cell that is going to be used as an instance of a CellularSpace. See init() . x : An integer number with the x location of the Cell. The default value is 0. y : An integer number with the y location of the Cell. The default value is 0. ... : Any other attribute or function for the Cell.","title":"Arguments"},{"location":"base/types/cell/#attributes","text":"Some attributes of Cell have internal semantics. They can be used as read-only by the modeler. agents : A vector with the Agents representing the default placement of the Cell. It is necessary to use forEachAgent() . This value is the same of \"cell.placement.agents\". cObj_ : A pointer to a C++ representation of the Cell. Never use this object. parent : The CellularSpace it belongs. past : A copy of the attributes at the time of the last synchronization. placement : A SocialNetwork representing the default placement of the Cell (only when a call to Environment:createPlacement() use the Cell).","title":"Attributes"},{"location":"base/types/cell/#usage","text":"cell = Cell { cover = \"forest\", soilWater = 0 }","title":"Usage"},{"location":"base/types/cell/#see-also","text":"forEachNeighborhood (Utils)","title":"See also"},{"location":"base/types/cell/#functions","text":"addNeighborhood Add a new Neighborhood to the Cell. area Return the Cell area. distance Returns the shortest distance between the cells. getAgent Return an Agent that belongs to the Cell. getAgents Return the Agents that belong to the Cell. getId Return a string with the unique identifier of the Cell. getNeighborhood Return a Neighborhood of the Cell. init User-defined function that is used to initialize a Cell when a CellularSpace is created. isEmpty Return whether the cell is empty according to a given placement. notify Notify every Observer connected to the Cell. on_synchronize An optional user-defined function that is activated just after one calls Cell:synchronize() . sample Return a random Cell from a Neighborhood of the Cell. setId Update the unique identifier of the Cell. synchronize Synchronizes the Cell. # Return the number of Neighborhoods in the Cell.","title":"Functions"},{"location":"base/types/cell/#addneighborhood","text":"Add a new Neighborhood to the Cell. This function replaces previous Neighborhood with the same name (if it exists) without showing any warning message.","title":"addNeighborhood"},{"location":"base/types/cell/#arguments_1","text":"#1 : A Neighborhood. #2 : Neighborhood's name. The default value is \"1\".","title":"Arguments"},{"location":"base/types/cell/#usage_1","text":"c1 = Cell{} c2 = Cell{} n = Neighborhood() n:add(c2) c1:addNeighborhood(n)","title":"Usage"},{"location":"base/types/cell/#see-also_1","text":"Neighborhood","title":"See also"},{"location":"base/types/cell/#area","text":"Return the Cell area.","title":"area"},{"location":"base/types/cell/#usage_2","text":"cell:area()","title":"Usage"},{"location":"base/types/cell/#distance","text":"Returns the shortest distance between the cells. If the cell do not have geometry, it calculates the Euclidean distance to a given Cell using the attributes x and y of both Cells.","title":"distance"},{"location":"base/types/cell/#arguments_2","text":"#1 : Other Cell.","title":"Arguments"},{"location":"base/types/cell/#usage_3","text":"c1 = Cell{x = 5, y = 5} c2 = Cell{x = 10, y = 10} dist = c1:distance(c2) print(dist)","title":"Usage"},{"location":"base/types/cell/#getagent","text":"Return an Agent that belongs to the Cell. It assumes that there is at most one Agent per Cell. If there is no Agent within the cell then it returns nil.","title":"getAgent"},{"location":"base/types/cell/#arguments_3","text":"#1 : A string with the name of the placement. The default value is \"placement\".","title":"Arguments"},{"location":"base/types/cell/#usage_4","text":"ag = Agent{} s = Society{instance = ag, quantity = 2} ag1 = s.agents[1] cs = CellularSpace{xdim = 3} c = cs.cells[1] myEnv = Environment{cs, ag1} myEnv:createPlacement{strategy = \"void\"} ag1:enter(c) if c:getAgent() == ag1 then print(\"equal\") end","title":"Usage"},{"location":"base/types/cell/#getagents","text":"Return the Agents that belong to the Cell. The returning vector.","title":"getAgents"},{"location":"base/types/cell/#arguments_4","text":"#1 : A string with the name of the placement. The default value is \"placement\".","title":"Arguments"},{"location":"base/types/cell/#usage_5","text":"ag = Agent{} s = Society{instance = ag, quantity = 2} ag1 = s.agents[1] cs = CellularSpace{xdim = 3} c = cs.cells[1] myEnv = Environment{cs, ag1} myEnv:createPlacement{strategy = \"void\"} ag1:enter(c) if c:getAgents()[1] == ag1 then print(\"equal\") end","title":"Usage"},{"location":"base/types/cell/#getid","text":"Return a string with the unique identifier of the Cell. Note that any Cell that belongs to a CellularSpace has an id.","title":"getId"},{"location":"base/types/cell/#usage_6","text":"cell = Cell{id = \"2\"} id = cell:getId() print(id)","title":"Usage"},{"location":"base/types/cell/#getneighborhood","text":"Return a Neighborhood of the Cell. If the Neighborhood does not exist then it returns nil.","title":"getNeighborhood"},{"location":"base/types/cell/#arguments_5","text":"#1 : A string with the neighborhood's name to be retrieved. The default value is \"1\".","title":"Arguments"},{"location":"base/types/cell/#usage_7","text":"cs = CellularSpace{ xdim = 10 } cs:createNeighborhood() n = cs:sample():getNeighborhood() print(#n)","title":"Usage"},{"location":"base/types/cell/#init","text":"User-defined function that is used to initialize a Cell when a CellularSpace is created. This function gets the Cell itself as argument.","title":"init"},{"location":"base/types/cell/#usage_8","text":"cell = Cell{ init = function(self) self.population = Random():integer(1, 100) -- initial population chosen randomly end, -- ... } cs = CellularSpace{ xdim = 10, instance = cell } print(cs:sample().population)","title":"Usage"},{"location":"base/types/cell/#see-also_2","text":"Random","title":"See also"},{"location":"base/types/cell/#isempty","text":"Return whether the cell is empty according to a given placement. An empty Cell does not contain any Agent .","title":"isEmpty"},{"location":"base/types/cell/#arguments_6","text":"#1 : A string with the name of the placement. The default value is \"placement\".","title":"Arguments"},{"location":"base/types/cell/#usage_9","text":"ag = Agent{} s = Society{instance = ag, quantity = 2} ag1 = s.agents[1] cs = CellularSpace{xdim = 3} c = cs.cells[1] myEnv = Environment{cs, ag1} myEnv:createPlacement{strategy = \"void\"} ag1:enter(c) if not c:isEmpty() then print(\"not empty\") end","title":"Usage"},{"location":"base/types/cell/#notify","text":"Notify every Observer connected to the Cell.","title":"notify"},{"location":"base/types/cell/#arguments_7","text":"#1 : A positive number representing the notification time. The default value is zero. It is also possible to use an Event as argument. In this case, it will use the result of Event:getTime() .","title":"Arguments"},{"location":"base/types/cell/#usage_10","text":"cell = Cell{value = 5} Chart{target = cell} cell:notify(1) cell:notify(2)","title":"Usage"},{"location":"base/types/cell/#on_synchronize","text":"An optional user-defined function that is activated just after one calls Cell:synchronize() .","title":"on_synchronize"},{"location":"base/types/cell/#usage_11","text":"cell = Cell{ value = 3, on_synchronize = function(self) self.value = 0 end } cell:synchronize() print(cell.value) -- 0","title":"Usage"},{"location":"base/types/cell/#sample","text":"Return a random Cell from a Neighborhood of the Cell.","title":"sample"},{"location":"base/types/cell/#arguments_8","text":"#1 : A string with the name of the Neighborhood. The default value is \"1\".","title":"Arguments"},{"location":"base/types/cell/#usage_12","text":"cs = CellularSpace{ xdim = 10 } cs:createNeighborhood() cell = cs:sample() neigh = cell:sample() print(type(neigh))","title":"Usage"},{"location":"base/types/cell/#see-also_3","text":"getNeighborhood","title":"See also"},{"location":"base/types/cell/#setid","text":"Update the unique identifier of the Cell.","title":"setId"},{"location":"base/types/cell/#arguments_9","text":"#1 : A string with the new unique identifier.","title":"Arguments"},{"location":"base/types/cell/#usage_13","text":"cell = Cell{id = \"2\"} cell:setId(\"newid\") id = cell:getId() print(id)","title":"Usage"},{"location":"base/types/cell/#synchronize","text":"Synchronizes the Cell. TerraME can keep two copies of the attributes of a Cell in memory: one stores the past values and the other stores the current (present) values. Synchronize copies the current values to a table named past, within the Cell. The previous past is therefore overwritten. In the end synchronize, it calls Cell:on_synchronize() if it exists.","title":"synchronize"},{"location":"base/types/cell/#usage_14","text":"cell = Cell{value = 5} cell:synchronize() print(cell.past.value)","title":"Usage"},{"location":"base/types/cell/#see-also_4","text":"synchronize (CellularSpace)","title":"See also"},{"location":"base/types/cell/#_1","text":"Return the number of Neighborhoods in the Cell.","title":"#"},{"location":"base/types/cell/#usage_15","text":"cell = Cell{} cell:addNeighborhood(Neighborhood()) cell:addNeighborhood(Neighborhood()) size = #cell print(size)","title":"Usage"},{"location":"base/types/cellularSpace/","text":"CellularSpace A multivalued set of Cells . It can be retrieved from databases, files, or created directly within TerraME. Each spatial object read from a data source becomes a Cell, be it a point, a polygon, a line, or a pixel. If the Cells have attributes \"row\" and \"col\" (the name can be set by argument xy, as shown below), they can be used to createNeighborhood() and to draw the CellularSpace in the screen by using a Map . The Cell with lower (row, col) represents the upper left location (see argument zero below). See the table below with the description and the arguments of each data source. Calling forEachCell() traverses CellularSpaces. Arguments as : A table with string indexes and values. It renames the loaded attributes of the CellularSpace from the values to its indexes. attrname : A string with an attribute name. It is useful for files that have only one attribute value for each cell but no attribute name. The default value is the name of the file being read. directory : A directory. It opens a set of tif files using the file names as attribute names. The directory must contains at least two tif files and they must have the same number of columns and rows. file : A string with a file name (if it is stored in the current directory), or the complete path to a given file. geometry : A boolean value indicating whether the geometry should also be loaded. The default value is true. If true, each cell will have an attribute called geom with a TerraLib object. instance : A Cell with the description of attributes and functions. When using this argument, each Cell will have attributes and functions according to the instance. It also calls Cell:init() from the instance for each of its Cells. Every attribute from the Cell that is a Random will be converted into Random:sample() . Additional functions are also created to the CellularSpace, according to the attributes of the instance. For each attribute of the instance, one function is created in the CellularSpace with the same name (note that attributes declared exclusively in Cell:init() will not be mapped, as they do not belong to the instance). The table below describes how each attribute is mapped: Type of attribute Function within the CellularSpace function Call the function of each of its Cells. number Return the sum of the number in each of its Cells. boolean Return the quantity of true values in its Cells. string Return a table with positions equal to the unique strings and values equal to the number of occurrences in each of its Cells. layer : A string with the name of the layer stored in a GIS project, or a Layer (gis package) . missing : An optional number that replaces all numeric attributes read from a data source that do not have any value. If this argument is not set and TerraME finds some attribute without a value, the simulation will stop with an error. project : A string with the name of the GIS project to be used. It can also be a Project (gis package) . sep : A string with the file separator. The default value is \",\". source : A string with the name of the data source. It tries to infer the data source according to the arguments passed to the function. source Description Compulsory arguments Optional arguments \"asc\" Load an asc file. The name of the attribute will be b0. file as, ... \"csv\" Load from a Comma-separated value (.csv) file. Each column will become an attribute. It requires at least two attributes: x and y. file as, geometry, sep, source, ... \"directory\" Reads a set of tif files within a given directory. The name of the tif files will be the name of the attributes in the Cells. directory as, ... \"geojson\" Load a GeoJSON file. file as, ... \"nc\" Load a nc file. The name of the attribute will be b0. It only works in Windows. file \"pgm\" Load from a text file where Cells are stored as numbers with its attribute value. as, attrname, sep, ... \"proj\" Load from a layer within a GIS project. See the documentation of package gis for more information. layer, project as, geometry, missing, source, ... \"shp\" Load data from a shapefile. It requires three files with the same name and different extensions: .shp, .shx, and .dbf. The argument file must end with \".shp\". As default, each Cell will have its (x, y) location according to the attributes (row, col) from the shapefile. file as, geometry, missing, source, xy, zero, ... \"tif\" Load a tif file. The name of the attributes will be b0, b1, etc., according to the number of bands in the file. file as, ... \"virtual\" Create a rectangular CellularSpace from scratch. Cells will be instantiated with only two attributes, x and y, starting from (0, 0). xdim as, geometry, ydim, ... xdim : Number of columns, in the case of creating a CellularSpace without needing to load from a database. xy : An optional table with two strings describing the names of the column and row attributes, in this order. The default value is {\"col\", \"row\"}, representing the attribute names created by TerraLib for CellularSpaces. A Map can only be created from a CellularSpace if each Cell has a (x, y) location. This argument can also be a function that gets a Cell as argument and returns two values with the (x, y) location. ydim : Number of lines, in the case of creating a CellularSpace without needing to load from a database. The default value is equal to xdim. zero : A string value describing where the zero in the y axis starts. The default value is \"bottom\". When one uses argument xy, the default value is \"top\", which is the most common representation in different data formats. When zero is \"bottom\", the y values of each cell is inverted according to the maximum and minimum values: newy = y maximum - y + y minimum. All cellular data created using package gis will have their y values inverted. ... : Any other attribute or function for the CellularSpace. Attributes Some attributes of CellularSpace have internal semantics. They can be used as read-only by the modeler. cells : A vector of Cells pointed by the CellularSpace. cObj_ : A pointer to a C++ representation of the CellularSpace. Never use this object. parent : The Environment it belongs. xMax : The maximum value of the attribute x of its Cells. xMin : The minimum value of the attribute x of its Cells. yMax : The maximum value of the attribute y of its Cells. yMin : The minimum value of the attribute y of its Cells. Usage cs = CellularSpace{ xdim = 20, ydim = 25 } states = CellularSpace{ file = filePath(\"brazilstates.shp\", \"base\") } cabecadeboi = CellularSpace{ file = filePath(\"cabecadeboi.shp\") } Functions add Add a new Cell to the CellularSpace. createNeighborhood Create a Neighborhood for each Cell of the CellularSpace. cut Cut the CellularSpace according to maximum and minimum coordinates. get Return a Cell from the CellularSpace, given its unique identifier or its location. load Load the CellularSpace from the database. loadNeighborhood Load a Neighborhood stored in an external source. notify Notify every Observer connected to the CellularSpace. sample Return a random Cell from the CellularSpace. save Save the attributes of a CellularSpace into Project (gis package) or a tif file. split Split the CellularSpace into a table of Trajectories according to a classification strategy. synchronize Synchronize the CellularSpace, calling the function synchronize() for each of its Cells . # Return the number of Cells in the CellularSpace. add Add a new Cell to the CellularSpace. It will be the last Cell of the CellularSpace when one uses forEachCell() . Arguments #1 : A Cell. Usage cs = CellularSpace{ xdim = 10 } cell = Cell{x = 10, y = 11} cs:add(cell) createNeighborhood Create a Neighborhood for each Cell of the CellularSpace. Most of the available strategies require that each Cell has attributes with (x, y) locations. It is possible to set the attributes that represent (x, y) locations while creating the CellularSpace. Arguments filter : A function(Cell, Cell)->bool, where the first argument is the Cell itself and the other represent a possible neighbor. It returns true when the neighbor will be included in the relation. In the case of two CellularSpaces, this function is called twice for e ach pair of Cells, first filter(c1, c2) and then filter(c2, c1), where c1 belongs to cs1 and c2 belongs to cs2. The default value is a function that returns true. inmemory : If true (default), a Neighborhood will be built and stored for each Cell of the CellularSpace. The Neighborhoods will change only if the modeler add or remove neighbors explicitly. If false, a Neighborhood will be computed every time the simulation calls Cell:getNeighborhood() , for example when using forEachNeighbor() . In this case, if any of the attributes the Neighborhood is based on changes then the resulting Neighborhood might be different. Neighborhoods not in memory also help the simulation to run with larger datasets, as they are not explicitly represented, but they consume more time as they need to be built again and again along the simulation. m : Number of columns. If m is even then it will be increased by one to keep the Cell in the center of the Neighborhood. The default value is 3. n : Number of rows. If n is even then it will be increased by one to keep the Cell in the center of the Neighborhood. The default value is m. name : A string with the name of the Neighborhood to be created. The default value is \"1\". self : Add the Cell as neighbor of itself? The default value is false. Note that the functions that do not require this argument always depend on a filter function, which will define whether the Cell can be neighbor of itself. strategy : A string with the strategy to be used for creating the Neighborhood. See the table below. Strategy Description Compulsory Arguments Optional Arguments \"3x3\" A 3x3 (Couclelis) Neighborhood (Deprecated. Use mxn instead). filter, inmemory, name, weight \"coord\" A bidirected relation between two CellularSpaces connecting Cells with the same (x, y) coordinates. target inmemory, name \"diagonal\" Connect each Cell to its (at most) four diagonal neighbors. inmemory, name, self, wrap \"function\" A Neighborhood based on a function where any other Cell can be a neighbor. filter inmemory, name, weight \"moore\"(default) A Moore (queen) Neighborhood, connecting each Cell to its (at most) eight touching Cells. inmemory, name, self, wrap \"mxn\" A m (columns) by n (rows) Neighborhood within the CellularSpace or between two CellularSpaces if target is used. filter, inmemory, m, n, name, target, weight, wrap \"vonneumann\" A von Neumann (rook) Neighborhood, connecting each Cell to its (at most) four ortogonally surrounding Cells. inmemory, name, self, wrap target : Another CellularSpace whose Cells will be used to create neighborhoods. weight : A function (Cell, Cell)->number, where the first argument is the Cell itself and the other represent its neighbor. It returns the weight of the relation. This function will be called only if filter returns true. wrap : Will the Cells in the borders be connected to the Cells in the opposite border? The default value is false. Usage cell = Cell{ height = Random{min = 0, max = 100} } cs = CellularSpace{ xdim = 10, instance = cell } cs:createNeighborhood() -- moore cs:createNeighborhood{ name = \"moore\" } cs:createNeighborhood{ strategy = \"vonneumann\", name = \"vonneumann\", self = true } cs:createNeighborhood{ strategy = \"mxn\", m = 5, name = \"5\", filter = function(cell, candidate) return cell.height > candidate.height end, weight = function(cell, candidate) return (cell.height - candidate.height) / 100 end } cs2 = CellularSpace{ xdim = 10 } cs:createNeighborhood{ strategy = \"mxn\", target = cs2, m = 5, name = \"spatialCoupling\" } cut Cut the CellularSpace according to maximum and minimum coordinates. It returns a Trajectory with the selected Cells . Arguments xmax : A number with the maximum value of x. xmin : A number with the minimum value of x. ymax : A number with the maximum value of y. ymin : A number with the minimum value of y. Usage cs = CellularSpace{xdim = 10} cs2 = cs:cut{xmin = 3, ymax = 8} print(#cs2) get Return a Cell from the CellularSpace, given its unique identifier or its location. If the Cell does not belong to the CellularSpace then it will return nil. Arguments #1 : A number indicating an x coordinate. It can also be a string with the object id. #2 : A number indicating a y coordinate. This argument is unnecessary when the first argument is a string. Usage cs = CellularSpace{xdim = 10} cell = cs:get(2, 2) print(cell.x) print(cell.y) cell = cs:get(\"5\") print(cell:getId()) load Load the CellularSpace from the database. TerraME automatically executes this function when the CellularSpace is created, but one can execute this to load the attributes again, erasing all attributes and relations created by the modeler. Usage cs = CellularSpace{xdim = 10} cs:load() loadNeighborhood Load a Neighborhood stored in an external source. Each Cell receives its own set of neighbors. Arguments check : A boolean value indicating whether this function should match the layer name of the CellularSpace with the one described in the file. The default value is true. file : A File or a string with the location of the Neighborhood file to be loaded. name : A string with the name of the Neighborhood to be loaded within TerraME. The default value is \"1\". Extension Description \"gal\" Load a Neighborhood from contiguity relationships described as a GAL file. \"gwt\" Load a Neighborhood from a GWT (generalized weights) file. \"gpm\" Load a Neighborhood from a GPM (generalized proximity matrix) file. Usage cs = CellularSpace{ file = filePath(\"cabecadeboi800.shp\", \"base\") } cs:loadNeighborhood{file = filePath(\"cabecadeboi-neigh.gpm\", \"base\")} notify Notify every Observer connected to the CellularSpace. Arguments #1 : A number representing the notification time. The default value is zero. It is also possible to use an Event as argument. In this case, it will use the result of Event:getTime() . Usage cs = CellularSpace{ xdim = 10, value = 5 } Chart{target = cs} cs:notify(1) cs:notify(2) sample Return a random Cell from the CellularSpace. Usage cs = CellularSpace{ xdim = 10 } cell = cs:sample() print(type(cell)) save Save the attributes of a CellularSpace into Project (gis package) or a tif file. Arguments #1 : Name of the Layer (gis package) or a tif file to store the saved attributes. If the original data comes from a shapefile layer, it will create another shapefile using the name of the new layer as file name and will save it in the same directory where the original shapefile is stored. If the data comes from a PostGIS database, it will create another table with name equals to the the layer's name. If the data come from a tif directory, it must be used a file with '.tif' extension. #2 : A vector with the names of the attributes to be saved. If the data come from a layer, these attributes should be only the attributes that were created or modified. The other attributes of the layer will also be saved in the new output. If the data come from a tif directory, it is only possible save one attribute at a time. The attribute value saved will have the same type of the loaded tif files, it means, if the tif is 8 bits the new tif will be 8 bits as well. When saving a single attribute, you can use a string \"attribute\" instead of a table {\"attribute\"}. Usage import(\"gis\") proj = Project{ file = \"amazonia.tview\", clean = true, amazonia = filePath(\"amazonia.shp\") } cs = CellularSpace{ project = proj, layer = \"amazonia\" } forEachCell(cs, function(cell) cell.distweight = 1 / cell.distroad end) cs:save(\"myamazonia\", \"distweight\") split Split the CellularSpace into a table of Trajectories according to a classification strategy. The Trajectories will have empty intersection and union equal to the whole CellularSpace (unless function below returns nil for some Cell ). It works according to the type of its only and compulsory argument. Arguments #1 : A string or a function, as follows: Type of argument Description string The argument must represent the name of one attribute of the Cells of the CellularSpace. Split then creates one Trajectory for each possible value of the attribute using the value as name and fills them with the Cells that have the respective attribute value. If the CellularSpace has an instance and the respective attribute in the instance is a Random value with discrete or categorical strategy, it will use the possible values to create Trajectories, which means that the returning Trajectories can have size zero in this case. function The argument is a function that gets a Cell as argument and returns a name for the Cell, which can be a number, string, or boolean value. Trajectories are then named according to the returning value. Usage cell = Cell{ cover = Random{\"pasture\", \"forest\"}, forest = Random{min = 0, max = 1} } cs = CellularSpace{ xdim = 20, instance = cell } ts = cs:split(\"cover\") print(#ts.forest) -- can be zero because it comes from an instance print(#ts.pasture) -- also ts2 = cs:split(function(cell) if cell.forest > 0.5 then return \"gt\" else return \"lt\" end end) if ts2.gt then -- might not exist as it does not come from an instance print(#ts2.gt) end synchronize Synchronize the CellularSpace, calling the function synchronize() for each of its Cells . Arguments #1 : A string or a vector of strings with the attributes to be synchronized. If empty, TerraME synchronizes every attribute of the Cells but the (x, y) coordinates. If the CellularSpace has an instance and it implements Cell:on_synchronize() then it will be called for each Cell. Usage cell = Cell{ forest = Random{min = 0, max = 1} } cs = CellularSpace{ xdim = 10, instance = cell } cs:synchronize() c = cs:sample() print(c.forest) print(c.past.forest) # Return the number of Cells in the CellularSpace. Usage cs = CellularSpace{xdim = 5} print(#cs)","title":"CellularSpace"},{"location":"base/types/cellularSpace/#cellularspace","text":"A multivalued set of Cells . It can be retrieved from databases, files, or created directly within TerraME. Each spatial object read from a data source becomes a Cell, be it a point, a polygon, a line, or a pixel. If the Cells have attributes \"row\" and \"col\" (the name can be set by argument xy, as shown below), they can be used to createNeighborhood() and to draw the CellularSpace in the screen by using a Map . The Cell with lower (row, col) represents the upper left location (see argument zero below). See the table below with the description and the arguments of each data source. Calling forEachCell() traverses CellularSpaces.","title":"CellularSpace"},{"location":"base/types/cellularSpace/#arguments","text":"as : A table with string indexes and values. It renames the loaded attributes of the CellularSpace from the values to its indexes. attrname : A string with an attribute name. It is useful for files that have only one attribute value for each cell but no attribute name. The default value is the name of the file being read. directory : A directory. It opens a set of tif files using the file names as attribute names. The directory must contains at least two tif files and they must have the same number of columns and rows. file : A string with a file name (if it is stored in the current directory), or the complete path to a given file. geometry : A boolean value indicating whether the geometry should also be loaded. The default value is true. If true, each cell will have an attribute called geom with a TerraLib object. instance : A Cell with the description of attributes and functions. When using this argument, each Cell will have attributes and functions according to the instance. It also calls Cell:init() from the instance for each of its Cells. Every attribute from the Cell that is a Random will be converted into Random:sample() . Additional functions are also created to the CellularSpace, according to the attributes of the instance. For each attribute of the instance, one function is created in the CellularSpace with the same name (note that attributes declared exclusively in Cell:init() will not be mapped, as they do not belong to the instance). The table below describes how each attribute is mapped: Type of attribute Function within the CellularSpace function Call the function of each of its Cells. number Return the sum of the number in each of its Cells. boolean Return the quantity of true values in its Cells. string Return a table with positions equal to the unique strings and values equal to the number of occurrences in each of its Cells. layer : A string with the name of the layer stored in a GIS project, or a Layer (gis package) . missing : An optional number that replaces all numeric attributes read from a data source that do not have any value. If this argument is not set and TerraME finds some attribute without a value, the simulation will stop with an error. project : A string with the name of the GIS project to be used. It can also be a Project (gis package) . sep : A string with the file separator. The default value is \",\". source : A string with the name of the data source. It tries to infer the data source according to the arguments passed to the function. source Description Compulsory arguments Optional arguments \"asc\" Load an asc file. The name of the attribute will be b0. file as, ... \"csv\" Load from a Comma-separated value (.csv) file. Each column will become an attribute. It requires at least two attributes: x and y. file as, geometry, sep, source, ... \"directory\" Reads a set of tif files within a given directory. The name of the tif files will be the name of the attributes in the Cells. directory as, ... \"geojson\" Load a GeoJSON file. file as, ... \"nc\" Load a nc file. The name of the attribute will be b0. It only works in Windows. file \"pgm\" Load from a text file where Cells are stored as numbers with its attribute value. as, attrname, sep, ... \"proj\" Load from a layer within a GIS project. See the documentation of package gis for more information. layer, project as, geometry, missing, source, ... \"shp\" Load data from a shapefile. It requires three files with the same name and different extensions: .shp, .shx, and .dbf. The argument file must end with \".shp\". As default, each Cell will have its (x, y) location according to the attributes (row, col) from the shapefile. file as, geometry, missing, source, xy, zero, ... \"tif\" Load a tif file. The name of the attributes will be b0, b1, etc., according to the number of bands in the file. file as, ... \"virtual\" Create a rectangular CellularSpace from scratch. Cells will be instantiated with only two attributes, x and y, starting from (0, 0). xdim as, geometry, ydim, ... xdim : Number of columns, in the case of creating a CellularSpace without needing to load from a database. xy : An optional table with two strings describing the names of the column and row attributes, in this order. The default value is {\"col\", \"row\"}, representing the attribute names created by TerraLib for CellularSpaces. A Map can only be created from a CellularSpace if each Cell has a (x, y) location. This argument can also be a function that gets a Cell as argument and returns two values with the (x, y) location. ydim : Number of lines, in the case of creating a CellularSpace without needing to load from a database. The default value is equal to xdim. zero : A string value describing where the zero in the y axis starts. The default value is \"bottom\". When one uses argument xy, the default value is \"top\", which is the most common representation in different data formats. When zero is \"bottom\", the y values of each cell is inverted according to the maximum and minimum values: newy = y maximum - y + y minimum. All cellular data created using package gis will have their y values inverted. ... : Any other attribute or function for the CellularSpace.","title":"Arguments"},{"location":"base/types/cellularSpace/#attributes","text":"Some attributes of CellularSpace have internal semantics. They can be used as read-only by the modeler. cells : A vector of Cells pointed by the CellularSpace. cObj_ : A pointer to a C++ representation of the CellularSpace. Never use this object. parent : The Environment it belongs. xMax : The maximum value of the attribute x of its Cells. xMin : The minimum value of the attribute x of its Cells. yMax : The maximum value of the attribute y of its Cells. yMin : The minimum value of the attribute y of its Cells.","title":"Attributes"},{"location":"base/types/cellularSpace/#usage","text":"cs = CellularSpace{ xdim = 20, ydim = 25 } states = CellularSpace{ file = filePath(\"brazilstates.shp\", \"base\") } cabecadeboi = CellularSpace{ file = filePath(\"cabecadeboi.shp\") }","title":"Usage"},{"location":"base/types/cellularSpace/#functions","text":"add Add a new Cell to the CellularSpace. createNeighborhood Create a Neighborhood for each Cell of the CellularSpace. cut Cut the CellularSpace according to maximum and minimum coordinates. get Return a Cell from the CellularSpace, given its unique identifier or its location. load Load the CellularSpace from the database. loadNeighborhood Load a Neighborhood stored in an external source. notify Notify every Observer connected to the CellularSpace. sample Return a random Cell from the CellularSpace. save Save the attributes of a CellularSpace into Project (gis package) or a tif file. split Split the CellularSpace into a table of Trajectories according to a classification strategy. synchronize Synchronize the CellularSpace, calling the function synchronize() for each of its Cells . # Return the number of Cells in the CellularSpace.","title":"Functions"},{"location":"base/types/cellularSpace/#add","text":"Add a new Cell to the CellularSpace. It will be the last Cell of the CellularSpace when one uses forEachCell() .","title":"add"},{"location":"base/types/cellularSpace/#arguments_1","text":"#1 : A Cell.","title":"Arguments"},{"location":"base/types/cellularSpace/#usage_1","text":"cs = CellularSpace{ xdim = 10 } cell = Cell{x = 10, y = 11} cs:add(cell)","title":"Usage"},{"location":"base/types/cellularSpace/#createneighborhood","text":"Create a Neighborhood for each Cell of the CellularSpace. Most of the available strategies require that each Cell has attributes with (x, y) locations. It is possible to set the attributes that represent (x, y) locations while creating the CellularSpace.","title":"createNeighborhood"},{"location":"base/types/cellularSpace/#arguments_2","text":"filter : A function(Cell, Cell)->bool, where the first argument is the Cell itself and the other represent a possible neighbor. It returns true when the neighbor will be included in the relation. In the case of two CellularSpaces, this function is called twice for e ach pair of Cells, first filter(c1, c2) and then filter(c2, c1), where c1 belongs to cs1 and c2 belongs to cs2. The default value is a function that returns true. inmemory : If true (default), a Neighborhood will be built and stored for each Cell of the CellularSpace. The Neighborhoods will change only if the modeler add or remove neighbors explicitly. If false, a Neighborhood will be computed every time the simulation calls Cell:getNeighborhood() , for example when using forEachNeighbor() . In this case, if any of the attributes the Neighborhood is based on changes then the resulting Neighborhood might be different. Neighborhoods not in memory also help the simulation to run with larger datasets, as they are not explicitly represented, but they consume more time as they need to be built again and again along the simulation. m : Number of columns. If m is even then it will be increased by one to keep the Cell in the center of the Neighborhood. The default value is 3. n : Number of rows. If n is even then it will be increased by one to keep the Cell in the center of the Neighborhood. The default value is m. name : A string with the name of the Neighborhood to be created. The default value is \"1\". self : Add the Cell as neighbor of itself? The default value is false. Note that the functions that do not require this argument always depend on a filter function, which will define whether the Cell can be neighbor of itself. strategy : A string with the strategy to be used for creating the Neighborhood. See the table below. Strategy Description Compulsory Arguments Optional Arguments \"3x3\" A 3x3 (Couclelis) Neighborhood (Deprecated. Use mxn instead). filter, inmemory, name, weight \"coord\" A bidirected relation between two CellularSpaces connecting Cells with the same (x, y) coordinates. target inmemory, name \"diagonal\" Connect each Cell to its (at most) four diagonal neighbors. inmemory, name, self, wrap \"function\" A Neighborhood based on a function where any other Cell can be a neighbor. filter inmemory, name, weight \"moore\"(default) A Moore (queen) Neighborhood, connecting each Cell to its (at most) eight touching Cells. inmemory, name, self, wrap \"mxn\" A m (columns) by n (rows) Neighborhood within the CellularSpace or between two CellularSpaces if target is used. filter, inmemory, m, n, name, target, weight, wrap \"vonneumann\" A von Neumann (rook) Neighborhood, connecting each Cell to its (at most) four ortogonally surrounding Cells. inmemory, name, self, wrap target : Another CellularSpace whose Cells will be used to create neighborhoods. weight : A function (Cell, Cell)->number, where the first argument is the Cell itself and the other represent its neighbor. It returns the weight of the relation. This function will be called only if filter returns true. wrap : Will the Cells in the borders be connected to the Cells in the opposite border? The default value is false.","title":"Arguments"},{"location":"base/types/cellularSpace/#usage_2","text":"cell = Cell{ height = Random{min = 0, max = 100} } cs = CellularSpace{ xdim = 10, instance = cell } cs:createNeighborhood() -- moore cs:createNeighborhood{ name = \"moore\" } cs:createNeighborhood{ strategy = \"vonneumann\", name = \"vonneumann\", self = true } cs:createNeighborhood{ strategy = \"mxn\", m = 5, name = \"5\", filter = function(cell, candidate) return cell.height > candidate.height end, weight = function(cell, candidate) return (cell.height - candidate.height) / 100 end } cs2 = CellularSpace{ xdim = 10 } cs:createNeighborhood{ strategy = \"mxn\", target = cs2, m = 5, name = \"spatialCoupling\" }","title":"Usage"},{"location":"base/types/cellularSpace/#cut","text":"Cut the CellularSpace according to maximum and minimum coordinates. It returns a Trajectory with the selected Cells .","title":"cut"},{"location":"base/types/cellularSpace/#arguments_3","text":"xmax : A number with the maximum value of x. xmin : A number with the minimum value of x. ymax : A number with the maximum value of y. ymin : A number with the minimum value of y.","title":"Arguments"},{"location":"base/types/cellularSpace/#usage_3","text":"cs = CellularSpace{xdim = 10} cs2 = cs:cut{xmin = 3, ymax = 8} print(#cs2)","title":"Usage"},{"location":"base/types/cellularSpace/#get","text":"Return a Cell from the CellularSpace, given its unique identifier or its location. If the Cell does not belong to the CellularSpace then it will return nil.","title":"get"},{"location":"base/types/cellularSpace/#arguments_4","text":"#1 : A number indicating an x coordinate. It can also be a string with the object id. #2 : A number indicating a y coordinate. This argument is unnecessary when the first argument is a string.","title":"Arguments"},{"location":"base/types/cellularSpace/#usage_4","text":"cs = CellularSpace{xdim = 10} cell = cs:get(2, 2) print(cell.x) print(cell.y) cell = cs:get(\"5\") print(cell:getId())","title":"Usage"},{"location":"base/types/cellularSpace/#load","text":"Load the CellularSpace from the database. TerraME automatically executes this function when the CellularSpace is created, but one can execute this to load the attributes again, erasing all attributes and relations created by the modeler.","title":"load"},{"location":"base/types/cellularSpace/#usage_5","text":"cs = CellularSpace{xdim = 10} cs:load()","title":"Usage"},{"location":"base/types/cellularSpace/#loadneighborhood","text":"Load a Neighborhood stored in an external source. Each Cell receives its own set of neighbors.","title":"loadNeighborhood"},{"location":"base/types/cellularSpace/#arguments_5","text":"check : A boolean value indicating whether this function should match the layer name of the CellularSpace with the one described in the file. The default value is true. file : A File or a string with the location of the Neighborhood file to be loaded. name : A string with the name of the Neighborhood to be loaded within TerraME. The default value is \"1\". Extension Description \"gal\" Load a Neighborhood from contiguity relationships described as a GAL file. \"gwt\" Load a Neighborhood from a GWT (generalized weights) file. \"gpm\" Load a Neighborhood from a GPM (generalized proximity matrix) file.","title":"Arguments"},{"location":"base/types/cellularSpace/#usage_6","text":"cs = CellularSpace{ file = filePath(\"cabecadeboi800.shp\", \"base\") } cs:loadNeighborhood{file = filePath(\"cabecadeboi-neigh.gpm\", \"base\")}","title":"Usage"},{"location":"base/types/cellularSpace/#notify","text":"Notify every Observer connected to the CellularSpace.","title":"notify"},{"location":"base/types/cellularSpace/#arguments_6","text":"#1 : A number representing the notification time. The default value is zero. It is also possible to use an Event as argument. In this case, it will use the result of Event:getTime() .","title":"Arguments"},{"location":"base/types/cellularSpace/#usage_7","text":"cs = CellularSpace{ xdim = 10, value = 5 } Chart{target = cs} cs:notify(1) cs:notify(2)","title":"Usage"},{"location":"base/types/cellularSpace/#sample","text":"Return a random Cell from the CellularSpace.","title":"sample"},{"location":"base/types/cellularSpace/#usage_8","text":"cs = CellularSpace{ xdim = 10 } cell = cs:sample() print(type(cell))","title":"Usage"},{"location":"base/types/cellularSpace/#save","text":"Save the attributes of a CellularSpace into Project (gis package) or a tif file.","title":"save"},{"location":"base/types/cellularSpace/#arguments_7","text":"#1 : Name of the Layer (gis package) or a tif file to store the saved attributes. If the original data comes from a shapefile layer, it will create another shapefile using the name of the new layer as file name and will save it in the same directory where the original shapefile is stored. If the data comes from a PostGIS database, it will create another table with name equals to the the layer's name. If the data come from a tif directory, it must be used a file with '.tif' extension. #2 : A vector with the names of the attributes to be saved. If the data come from a layer, these attributes should be only the attributes that were created or modified. The other attributes of the layer will also be saved in the new output. If the data come from a tif directory, it is only possible save one attribute at a time. The attribute value saved will have the same type of the loaded tif files, it means, if the tif is 8 bits the new tif will be 8 bits as well. When saving a single attribute, you can use a string \"attribute\" instead of a table {\"attribute\"}.","title":"Arguments"},{"location":"base/types/cellularSpace/#usage_9","text":"import(\"gis\") proj = Project{ file = \"amazonia.tview\", clean = true, amazonia = filePath(\"amazonia.shp\") } cs = CellularSpace{ project = proj, layer = \"amazonia\" } forEachCell(cs, function(cell) cell.distweight = 1 / cell.distroad end) cs:save(\"myamazonia\", \"distweight\")","title":"Usage"},{"location":"base/types/cellularSpace/#split","text":"Split the CellularSpace into a table of Trajectories according to a classification strategy. The Trajectories will have empty intersection and union equal to the whole CellularSpace (unless function below returns nil for some Cell ). It works according to the type of its only and compulsory argument.","title":"split"},{"location":"base/types/cellularSpace/#arguments_8","text":"#1 : A string or a function, as follows: Type of argument Description string The argument must represent the name of one attribute of the Cells of the CellularSpace. Split then creates one Trajectory for each possible value of the attribute using the value as name and fills them with the Cells that have the respective attribute value. If the CellularSpace has an instance and the respective attribute in the instance is a Random value with discrete or categorical strategy, it will use the possible values to create Trajectories, which means that the returning Trajectories can have size zero in this case. function The argument is a function that gets a Cell as argument and returns a name for the Cell, which can be a number, string, or boolean value. Trajectories are then named according to the returning value.","title":"Arguments"},{"location":"base/types/cellularSpace/#usage_10","text":"cell = Cell{ cover = Random{\"pasture\", \"forest\"}, forest = Random{min = 0, max = 1} } cs = CellularSpace{ xdim = 20, instance = cell } ts = cs:split(\"cover\") print(#ts.forest) -- can be zero because it comes from an instance print(#ts.pasture) -- also ts2 = cs:split(function(cell) if cell.forest > 0.5 then return \"gt\" else return \"lt\" end end) if ts2.gt then -- might not exist as it does not come from an instance print(#ts2.gt) end","title":"Usage"},{"location":"base/types/cellularSpace/#synchronize","text":"Synchronize the CellularSpace, calling the function synchronize() for each of its Cells .","title":"synchronize"},{"location":"base/types/cellularSpace/#arguments_9","text":"#1 : A string or a vector of strings with the attributes to be synchronized. If empty, TerraME synchronizes every attribute of the Cells but the (x, y) coordinates. If the CellularSpace has an instance and it implements Cell:on_synchronize() then it will be called for each Cell.","title":"Arguments"},{"location":"base/types/cellularSpace/#usage_11","text":"cell = Cell{ forest = Random{min = 0, max = 1} } cs = CellularSpace{ xdim = 10, instance = cell } cs:synchronize() c = cs:sample() print(c.forest) print(c.past.forest)","title":"Usage"},{"location":"base/types/cellularSpace/#_1","text":"Return the number of Cells in the CellularSpace.","title":"#"},{"location":"base/types/cellularSpace/#usage_12","text":"cs = CellularSpace{xdim = 5} print(#cs)","title":"Usage"},{"location":"base/types/chart/","text":"Chart Create a line chart showing the variation of one or more attributes (y axis) of an object. As default, x axis values come from the single argument of update() . A Chart behaves according to its target's type. See the table below. Type of the target Behavior Compulsory Unnecessary \" Agent \", \" Cell \", instance of a Model Plots how attributes change over time. target value \" CellularSpace \" If the selected attributes belong to the CellularSpace , it plots how attributes change over time. If only one attribute is selected and it belongs to the Cells , then it plots the sum of the attribute values in the whole CellularSpace. select, target \" Map \" Works as a Chart created from a CellularSpace , copying the values of arguments target, select, value, color, and label from the Map to itself. It only works if the Map was created using grouping \"uniquevalue\". If some of the colors is white, the respective attribute value will be ignored by the Chart. target color, label, select, value \" Environment \" Plot how a given attribute from different Models . select, target value \" Society \" Plot how attributes change over time. If no attribute is selected, it will plot the amount of Agents along the simulation. target \" DataFrame \" Plot a set of values at once, without needing to call Chart:update() . target value Arguments color : An optional table where each position is a color for the respective attribute, described as strings (\"red\", \"green\", \"blue\", \"white\", \"black\", \"yellow\", \"brown\", \"cyan\", \"gray\", \"magenta\", \"orange\", \"purple\", and their light and dark compositions, such as \"lightGray\" and \"darkGray\"), or as tables with three integer numbers representing RGB compositions. label : Vector of the same size of select that indicates the labels for each line of the Chart. The default value is the name of the attributes using toLabel() . pen : The pen style for drawing lines. It can be one of \"solid\" (default), \"dash\", \"dot\", \"dashdot\", or \"dashdotdot\". It can be a vector or a single value. select : A vector of strings with the name of the attributes to be observed. If it is only a single value then it can also be described as a string. As default, it selects all the user-defined number attributes of the target. In the case of Society , if it does not have any numeric attributes then it will use the number of agents in the Society as attribute. The positions of the vector define the plot order. It draws starting from the first until the last position. When using an Environment as target, it is possible to use only one attribute name. The selected attribute must belong to the Model instances it contains. Chart will then create one line for each Model instance. In this case, the selected attribute will be the default title for the Chart and the default labels will be the names of the Model instances in the Environment (if they are named) or else their Model:title() values. size : The size of the symbol, in pixels. It can be a number to be used by all lines. or a vector of numbers, describing the size for each line. The default value is 7. style : The style of each line to be drawn. It can be a string, indicating that all lines will have the same style, or a vector of strings describing each line. The possible values are: \"lines\", \"dots\", \"none\", \"steps\", and \"sticks\". The default value is \"lines\" for all lines. symbol : The symbol to be used to draw the points of the Chart. It can be a string to be used by all lines, or a vector of strings, describing the symbol for each line. The available values are: \"square\", \"diamond\", \"triangle\", \"ltriangle\" (left), \"dtriangle\" (downwards triangle), \"rtriangle\" (right), \"cross\", \"vcross\" (vertical cross), \"hline\", \"vline\", \"asterisk\", \"star\", \"hexagon\", and \"none\" (default). target : The object to be observed. title : An overall title to the Chart. The default value is \"\". In the case of instances of Models, the default is Model:title() . When the title is a Model instance, it automatically uses the Model:title() as its value. value : A vector of strings with the values to be observed. It is necessary when observing automatic functions from CellularSpace or Society that are created from string attributes. In this case, Chart will plot the quantity of each value described in this argument. width : The width of the lines to be drawn. It can be a number, indicating that all lines will be drawn with the same width, or a vector describing each line. The default value is width one for all lines. xAxis : Name of the attribute to be used as x axis (instead of time). In this case, notify() will not need its single argument for plotting Charts. xLabel : Name of the x-axis. It shows \"Time\" as default. yLabel : Name of the y-axis. It does not show any label as default. Usage cs = CellularSpace{ xdim = 10, value1 = 5, value2 = 7 } chart = Chart{target = cs} print(type(chart)) world = Cell{ susceptible = 498, recovered = 0, infected = 2 } Chart{ target = world, width = 2, select = {\"susceptible\", \"infected\", \"recovered\"}, style = {\"dots\", \"steps\", \"sticks\"}, color = {\"red\", \"green\", \"blue\"} } data = DataFrame{ first = 2000, step = 10, demand = {7, 8, 9, 10}, limit = {0.1, 0.04, 0.3, 0.07} } Chart{ target = data, select = \"limit\", color = \"blue\" } Functions clear Clear the Chart. getData Return a DataFrame with the values got from all its updates. restart Restart the Chart keeping the old plots. save Save a Chart into a file. update Update the Chart with the latest values of its target. clear Clear the Chart. Usage cell = Cell{value = 1} chart = Chart{target = cell} chart:update(1) chart:update(2) chart:clear() getData Return a DataFrame with the values got from all its updates. Usage cs = CellularSpace{ xdim = 10, value1 = 5, value2 = 7 } chart = Chart{target = cs} chart:update(1) chart:update(2) chart:update(3) data = chart:getData() print(tostring(data)) restart Restart the Chart keeping the old plots. Usage cell = Cell{value = 1} chart = Chart{target = cell} chart:update(1) chart:update(2) chart:restart() chart:update(2) chart:update(3) save Save a Chart into a file. Supported extensions are bmp, jpg, png, and tiff. Arguments #1 : A string with the file name. Usage cs = CellularSpace{ xdim = 10, value1 = 5, value2 = 7 } chart = Chart{target = cs} chart:update(1) chart:update(2) chart:update(3) chart:save(\"file.bmp\") File(\"file.bmp\"):delete() update Update the Chart with the latest values of its target. It is usually recommended to use the Chart as action of an Event instead of calling this function explicitly. Arguments #1 : A number with the current time or an Event. Usage cell = Cell{value = 1} chart = Chart{target = cell} chart:update(0) chart:update(1) chart:update(2)","title":"Chart"},{"location":"base/types/chart/#chart","text":"Create a line chart showing the variation of one or more attributes (y axis) of an object. As default, x axis values come from the single argument of update() . A Chart behaves according to its target's type. See the table below. Type of the target Behavior Compulsory Unnecessary \" Agent \", \" Cell \", instance of a Model Plots how attributes change over time. target value \" CellularSpace \" If the selected attributes belong to the CellularSpace , it plots how attributes change over time. If only one attribute is selected and it belongs to the Cells , then it plots the sum of the attribute values in the whole CellularSpace. select, target \" Map \" Works as a Chart created from a CellularSpace , copying the values of arguments target, select, value, color, and label from the Map to itself. It only works if the Map was created using grouping \"uniquevalue\". If some of the colors is white, the respective attribute value will be ignored by the Chart. target color, label, select, value \" Environment \" Plot how a given attribute from different Models . select, target value \" Society \" Plot how attributes change over time. If no attribute is selected, it will plot the amount of Agents along the simulation. target \" DataFrame \" Plot a set of values at once, without needing to call Chart:update() . target value","title":"Chart"},{"location":"base/types/chart/#arguments","text":"color : An optional table where each position is a color for the respective attribute, described as strings (\"red\", \"green\", \"blue\", \"white\", \"black\", \"yellow\", \"brown\", \"cyan\", \"gray\", \"magenta\", \"orange\", \"purple\", and their light and dark compositions, such as \"lightGray\" and \"darkGray\"), or as tables with three integer numbers representing RGB compositions. label : Vector of the same size of select that indicates the labels for each line of the Chart. The default value is the name of the attributes using toLabel() . pen : The pen style for drawing lines. It can be one of \"solid\" (default), \"dash\", \"dot\", \"dashdot\", or \"dashdotdot\". It can be a vector or a single value. select : A vector of strings with the name of the attributes to be observed. If it is only a single value then it can also be described as a string. As default, it selects all the user-defined number attributes of the target. In the case of Society , if it does not have any numeric attributes then it will use the number of agents in the Society as attribute. The positions of the vector define the plot order. It draws starting from the first until the last position. When using an Environment as target, it is possible to use only one attribute name. The selected attribute must belong to the Model instances it contains. Chart will then create one line for each Model instance. In this case, the selected attribute will be the default title for the Chart and the default labels will be the names of the Model instances in the Environment (if they are named) or else their Model:title() values. size : The size of the symbol, in pixels. It can be a number to be used by all lines. or a vector of numbers, describing the size for each line. The default value is 7. style : The style of each line to be drawn. It can be a string, indicating that all lines will have the same style, or a vector of strings describing each line. The possible values are: \"lines\", \"dots\", \"none\", \"steps\", and \"sticks\". The default value is \"lines\" for all lines. symbol : The symbol to be used to draw the points of the Chart. It can be a string to be used by all lines, or a vector of strings, describing the symbol for each line. The available values are: \"square\", \"diamond\", \"triangle\", \"ltriangle\" (left), \"dtriangle\" (downwards triangle), \"rtriangle\" (right), \"cross\", \"vcross\" (vertical cross), \"hline\", \"vline\", \"asterisk\", \"star\", \"hexagon\", and \"none\" (default). target : The object to be observed. title : An overall title to the Chart. The default value is \"\". In the case of instances of Models, the default is Model:title() . When the title is a Model instance, it automatically uses the Model:title() as its value. value : A vector of strings with the values to be observed. It is necessary when observing automatic functions from CellularSpace or Society that are created from string attributes. In this case, Chart will plot the quantity of each value described in this argument. width : The width of the lines to be drawn. It can be a number, indicating that all lines will be drawn with the same width, or a vector describing each line. The default value is width one for all lines. xAxis : Name of the attribute to be used as x axis (instead of time). In this case, notify() will not need its single argument for plotting Charts. xLabel : Name of the x-axis. It shows \"Time\" as default. yLabel : Name of the y-axis. It does not show any label as default.","title":"Arguments"},{"location":"base/types/chart/#usage","text":"cs = CellularSpace{ xdim = 10, value1 = 5, value2 = 7 } chart = Chart{target = cs} print(type(chart)) world = Cell{ susceptible = 498, recovered = 0, infected = 2 } Chart{ target = world, width = 2, select = {\"susceptible\", \"infected\", \"recovered\"}, style = {\"dots\", \"steps\", \"sticks\"}, color = {\"red\", \"green\", \"blue\"} } data = DataFrame{ first = 2000, step = 10, demand = {7, 8, 9, 10}, limit = {0.1, 0.04, 0.3, 0.07} } Chart{ target = data, select = \"limit\", color = \"blue\" }","title":"Usage"},{"location":"base/types/chart/#functions","text":"clear Clear the Chart. getData Return a DataFrame with the values got from all its updates. restart Restart the Chart keeping the old plots. save Save a Chart into a file. update Update the Chart with the latest values of its target.","title":"Functions"},{"location":"base/types/chart/#clear","text":"Clear the Chart.","title":"clear"},{"location":"base/types/chart/#usage_1","text":"cell = Cell{value = 1} chart = Chart{target = cell} chart:update(1) chart:update(2) chart:clear()","title":"Usage"},{"location":"base/types/chart/#getdata","text":"Return a DataFrame with the values got from all its updates.","title":"getData"},{"location":"base/types/chart/#usage_2","text":"cs = CellularSpace{ xdim = 10, value1 = 5, value2 = 7 } chart = Chart{target = cs} chart:update(1) chart:update(2) chart:update(3) data = chart:getData() print(tostring(data))","title":"Usage"},{"location":"base/types/chart/#restart","text":"Restart the Chart keeping the old plots.","title":"restart"},{"location":"base/types/chart/#usage_3","text":"cell = Cell{value = 1} chart = Chart{target = cell} chart:update(1) chart:update(2) chart:restart() chart:update(2) chart:update(3)","title":"Usage"},{"location":"base/types/chart/#save","text":"Save a Chart into a file. Supported extensions are bmp, jpg, png, and tiff.","title":"save"},{"location":"base/types/chart/#arguments_1","text":"#1 : A string with the file name.","title":"Arguments"},{"location":"base/types/chart/#usage_4","text":"cs = CellularSpace{ xdim = 10, value1 = 5, value2 = 7 } chart = Chart{target = cs} chart:update(1) chart:update(2) chart:update(3) chart:save(\"file.bmp\") File(\"file.bmp\"):delete()","title":"Usage"},{"location":"base/types/chart/#update","text":"Update the Chart with the latest values of its target. It is usually recommended to use the Chart as action of an Event instead of calling this function explicitly.","title":"update"},{"location":"base/types/chart/#arguments_2","text":"#1 : A number with the current time or an Event.","title":"Arguments"},{"location":"base/types/chart/#usage_5","text":"cell = Cell{value = 1} chart = Chart{target = cell} chart:update(0) chart:update(1) chart:update(2)","title":"Usage"},{"location":"base/types/choice/","text":"Choice Type to define options to be used by the modeler. It can get a vector a argument or named arguments as follows. This type is useful to define parameters of a Model . Arguments default : The default value for the choice. The default value for this argument depends on the other arguments used. If using min then it is the default value. Otherwise, if using max then it is the default value. If using a vector as argument, the default value is the first element of the table. max : The maximum value (optional). min : The minimum value (optional). slices : An optional argument with the number of values between minimum and maximum. It must be an integer number greater than two. When using this argument, min and max become mandatory. step : An optional argument with the step from minimum to maximum. Note that max should be equals to min plus k times step, where k is an integer number. When using this argument, min and max become mandatory. Attributes Some attributes of Choice have internal semantics. They can be used as read-only by the modeler. values : A vector with the possible values for the Choice. Usage c1 = Choice{1, 2, 3} c2 = Choice{\"low\", \"medium\", \"high\"} c3 = Choice{min = 2, max = 5, step = 0.1} c4 = Choice{min = 2, max = 20, slices = 4} Functions sample Return a random element from the available options. sample Return a random element from the available options. If the Choice was built from a vector or it has a step, it returns a random value following a discrete uniform distribution. If it has maximum and minimum then it returns a random value using a continuous uniform distribution. When sampling from Choices that have maximum but not minimum, or minimum but not maximum, it uses 2^52 as maximum or -2^52 as minimum. Usage c = Choice{1, 2, 5, 6} c:sample()","title":"Choice"},{"location":"base/types/choice/#choice","text":"Type to define options to be used by the modeler. It can get a vector a argument or named arguments as follows. This type is useful to define parameters of a Model .","title":"Choice"},{"location":"base/types/choice/#arguments","text":"default : The default value for the choice. The default value for this argument depends on the other arguments used. If using min then it is the default value. Otherwise, if using max then it is the default value. If using a vector as argument, the default value is the first element of the table. max : The maximum value (optional). min : The minimum value (optional). slices : An optional argument with the number of values between minimum and maximum. It must be an integer number greater than two. When using this argument, min and max become mandatory. step : An optional argument with the step from minimum to maximum. Note that max should be equals to min plus k times step, where k is an integer number. When using this argument, min and max become mandatory.","title":"Arguments"},{"location":"base/types/choice/#attributes","text":"Some attributes of Choice have internal semantics. They can be used as read-only by the modeler. values : A vector with the possible values for the Choice.","title":"Attributes"},{"location":"base/types/choice/#usage","text":"c1 = Choice{1, 2, 3} c2 = Choice{\"low\", \"medium\", \"high\"} c3 = Choice{min = 2, max = 5, step = 0.1} c4 = Choice{min = 2, max = 20, slices = 4}","title":"Usage"},{"location":"base/types/choice/#functions","text":"sample Return a random element from the available options.","title":"Functions"},{"location":"base/types/choice/#sample","text":"Return a random element from the available options. If the Choice was built from a vector or it has a step, it returns a random value following a discrete uniform distribution. If it has maximum and minimum then it returns a random value using a continuous uniform distribution. When sampling from Choices that have maximum but not minimum, or minimum but not maximum, it uses 2^52 as maximum or -2^52 as minimum.","title":"sample"},{"location":"base/types/choice/#usage_1","text":"c = Choice{1, 2, 5, 6} c:sample()","title":"Usage"},{"location":"base/types/clock/","text":"Clock Create a display with the current time and Event queue of a given Timer . Arguments target : A Timer. Usage timer = Timer{ Event{action = function() end}, Event{period = 2, action = function() end} } Clock{target = timer} timer:run(3) timer:notify() Functions save Save a Clock into a file. update Update the Clock with the latest values of its target. save Save a Clock into a file. Supported extensions are bmp, jpg, png, and tiff. Arguments #1 : A string with the file name. Usage timer = Timer{ Event{action = function() end} } clock = Clock{target = timer} clock:save(\"file.bmp\") File(\"file.bmp\"):delete() update Update the Clock with the latest values of its target. It is usually recommended to use the Clock as action of an Event instead of calling this function explicitly. Usage timer = Timer{ Event{action = function() end} } clock = Clock{target = timer} clock:update()","title":"Clock"},{"location":"base/types/clock/#clock","text":"Create a display with the current time and Event queue of a given Timer .","title":"Clock"},{"location":"base/types/clock/#arguments","text":"target : A Timer.","title":"Arguments"},{"location":"base/types/clock/#usage","text":"","title":"Usage"},{"location":"base/types/clock/#timer-timer-eventaction-function-end-eventperiod-2-action-function-end-clocktarget-timer-timerrun3-timernotify","text":"","title":"timer = Timer{ Event{action = function() end}, Event{period = 2, action = function() end} } Clock{target = timer} timer:run(3) timer:notify()"},{"location":"base/types/clock/#functions","text":"save Save a Clock into a file. update Update the Clock with the latest values of its target.","title":"Functions"},{"location":"base/types/clock/#save","text":"Save a Clock into a file. Supported extensions are bmp, jpg, png, and tiff.","title":"save"},{"location":"base/types/clock/#arguments_1","text":"#1 : A string with the file name.","title":"Arguments"},{"location":"base/types/clock/#usage_1","text":"timer = Timer{ Event{action = function() end} } clock = Clock{target = timer} clock:save(\"file.bmp\") File(\"file.bmp\"):delete()","title":"Usage"},{"location":"base/types/clock/#update","text":"Update the Clock with the latest values of its target. It is usually recommended to use the Clock as action of an Event instead of calling this function explicitly.","title":"update"},{"location":"base/types/clock/#usage_2","text":"timer = Timer{ Event{action = function() end} } clock = Clock{target = timer} clock:update()","title":"Usage"},{"location":"base/types/dataFrame/","text":"DataFrame A two dimensional table. DataFrames can be accessed by row or by column, independently on the way it was created. Arguments file : A string or a File . It must have extension '.lua'. first : A number with the first index. instance : An optional object used as meta table for the rows of the DataFrame. and only used to check whether it is equals to first plus step times the size of the data vectors. last : A number with the last index. This argument is optional. step : A number with the interval between two indexes. ... : Values for the DataFrame. It can be a vector of named tables or a named table with whose values are vectors. Usage -- named table with vectors df = DataFrame{ x = {1, 1, 2, 2}, y = {1, 2, 1, 2} } print(df.x[1]) -- 1 print(df[1].x) -- 1 -- vector of named tables df = DataFrame{ {x = 1, y = 1}, {x = 1, y = 2}, {x = 2, y = 1}, {x = 2, y = 2}, first = 2000, step = 10 } print(df.y[2030]) -- 2 print(df[2010].y) -- 2 Functions add Add a new row. columns Return the columns of the DataFrame. remove Remove a given row. rows Return the rows of the DataFrame. save Save the DataFrame to a given file. # Return the number of rows in the DataFrame. [] Return a row or a column of the DataFrame. add Add a new row. Arguments #1 : A named table with the values of the row to be added. #2 : An optional number describing the position of the row. As default, this function adds the new row after the last one. Usage df = DataFrame{ {x = 1, y = 1} } df:add{x = 5, y = 2} df:add{x = 4, y = 2} print(df[3].x) -- 4 print(df.y[2]) -- 2 columns Return the columns of the DataFrame. It is a named table whose indexes are the column names and the values are true. Usage df = DataFrame{x = {1}, y = {2}} print(vardump(df:columns())) -- {x = true, y = true} remove Remove a given row. This function only works properly when the rows are numbered from one to the quantity of elements in the DataFrame. Arguments #1 : A number with the position to be removed. Usage df = DataFrame{ {x = 1, y = 1}, {x = 2, y = 1}, {x = 3, y = 2}, {x = 4, y = 2}, {x = 5, y = 2} } df:remove(3) print(#df) -- 4 print(df[3].x) -- 4 rows Return the rows of the DataFrame. It is a named table whose indexes are the rows positions and the values are true. Usage df = DataFrame{x = {1}, y = {2}} print(vardump(df:rows())) -- {true} save Save the DataFrame to a given file. Arguments #1 : A mandatory string with the file name or a File . It can be a Lua file (.lua) or a CSV (.csv). Usage filename = \"dump.lua\" df = DataFrame{x = {1}, y = {2}} df:save(filename) File(filename):deleteIfExists() # Return the number of rows in the DataFrame. Usage df = DataFrame{ x = {1, 1, 2, 2}, y = {1, 2, 1, 2} } print(#df) -- 4 [] Return a row or a column of the DataFrame. Arguments #1 : An index. If it is a number this function returns the given row as a named table. If it is a string this function returns the entire column as a vector. Usage df = DataFrame{ x = {1, 1, 2, 2}, y = {1, 2, 1, 2} } print(df.x[1]) -- 1 df.x[1] = 5 df[1].x = df[1].x + 1 print(df.x[1]) -- 6","title":"DataFrame"},{"location":"base/types/dataFrame/#dataframe","text":"A two dimensional table. DataFrames can be accessed by row or by column, independently on the way it was created.","title":"DataFrame"},{"location":"base/types/dataFrame/#arguments","text":"file : A string or a File . It must have extension '.lua'. first : A number with the first index. instance : An optional object used as meta table for the rows of the DataFrame. and only used to check whether it is equals to first plus step times the size of the data vectors. last : A number with the last index. This argument is optional. step : A number with the interval between two indexes. ... : Values for the DataFrame. It can be a vector of named tables or a named table with whose values are vectors.","title":"Arguments"},{"location":"base/types/dataFrame/#usage","text":"-- named table with vectors df = DataFrame{ x = {1, 1, 2, 2}, y = {1, 2, 1, 2} } print(df.x[1]) -- 1 print(df[1].x) -- 1 -- vector of named tables df = DataFrame{ {x = 1, y = 1}, {x = 1, y = 2}, {x = 2, y = 1}, {x = 2, y = 2}, first = 2000, step = 10 } print(df.y[2030]) -- 2 print(df[2010].y) -- 2","title":"Usage"},{"location":"base/types/dataFrame/#functions","text":"add Add a new row. columns Return the columns of the DataFrame. remove Remove a given row. rows Return the rows of the DataFrame. save Save the DataFrame to a given file. # Return the number of rows in the DataFrame. [] Return a row or a column of the DataFrame.","title":"Functions"},{"location":"base/types/dataFrame/#add","text":"Add a new row.","title":"add"},{"location":"base/types/dataFrame/#arguments_1","text":"#1 : A named table with the values of the row to be added. #2 : An optional number describing the position of the row. As default, this function adds the new row after the last one.","title":"Arguments"},{"location":"base/types/dataFrame/#usage_1","text":"df = DataFrame{ {x = 1, y = 1} } df:add{x = 5, y = 2} df:add{x = 4, y = 2} print(df[3].x) -- 4 print(df.y[2]) -- 2","title":"Usage"},{"location":"base/types/dataFrame/#columns","text":"Return the columns of the DataFrame. It is a named table whose indexes are the column names and the values are true.","title":"columns"},{"location":"base/types/dataFrame/#usage_2","text":"df = DataFrame{x = {1}, y = {2}} print(vardump(df:columns())) -- {x = true, y = true}","title":"Usage"},{"location":"base/types/dataFrame/#remove","text":"Remove a given row. This function only works properly when the rows are numbered from one to the quantity of elements in the DataFrame.","title":"remove"},{"location":"base/types/dataFrame/#arguments_2","text":"#1 : A number with the position to be removed.","title":"Arguments"},{"location":"base/types/dataFrame/#usage_3","text":"df = DataFrame{ {x = 1, y = 1}, {x = 2, y = 1}, {x = 3, y = 2}, {x = 4, y = 2}, {x = 5, y = 2} } df:remove(3) print(#df) -- 4 print(df[3].x) -- 4","title":"Usage"},{"location":"base/types/dataFrame/#rows","text":"Return the rows of the DataFrame. It is a named table whose indexes are the rows positions and the values are true.","title":"rows"},{"location":"base/types/dataFrame/#usage_4","text":"df = DataFrame{x = {1}, y = {2}} print(vardump(df:rows())) -- {true}","title":"Usage"},{"location":"base/types/dataFrame/#save","text":"Save the DataFrame to a given file.","title":"save"},{"location":"base/types/dataFrame/#arguments_3","text":"#1 : A mandatory string with the file name or a File . It can be a Lua file (.lua) or a CSV (.csv).","title":"Arguments"},{"location":"base/types/dataFrame/#usage_5","text":"filename = \"dump.lua\" df = DataFrame{x = {1}, y = {2}} df:save(filename) File(filename):deleteIfExists()","title":"Usage"},{"location":"base/types/dataFrame/#_1","text":"Return the number of rows in the DataFrame.","title":"#"},{"location":"base/types/dataFrame/#usage_6","text":"df = DataFrame{ x = {1, 1, 2, 2}, y = {1, 2, 1, 2} } print(#df) -- 4","title":"Usage"},{"location":"base/types/dataFrame/#_2","text":"Return a row or a column of the DataFrame.","title":"[]"},{"location":"base/types/dataFrame/#arguments_4","text":"#1 : An index. If it is a number this function returns the given row as a named table. If it is a string this function returns the entire column as a vector.","title":"Arguments"},{"location":"base/types/dataFrame/#usage_7","text":"df = DataFrame{ x = {1, 1, 2, 2}, y = {1, 2, 1, 2} } print(df.x[1]) -- 1 df.x[1] = 5 df[1].x = df[1].x + 1 print(df.x[1]) -- 6","title":"Usage"},{"location":"base/types/directory/","text":"Directory An abstract representation of a directory. When creating an instance of a Directory, it does not mean that such directory will be created. It only verifies if the directory has a valid name. Directory also converts backslashes into slashes to make sure paths are represented in the same way in different operational systems. This type provides a set of operations to handle directories, such as to verify if it exists, create, and remove. Arguments name : A mandatory string with the directory name. It can also be a File . In this case, its value will be File:path() . This argument can be used as a first argument in a call to Directory without named arguments, as in the example below. tmp : An optional boolean value indicating whether the directory should be temporary. The default value is false. When creating a temporary directory, the end of its name must contain X's, which are going to be replaced by random alphanumerical values in order to guarantee that the created directory will not replace a previous one. Usage dir = Directory(\"/my/path/my_dir\") tmpDir = Directory{ name = \"mytmpdir_XXX\", tmp = true } print(tmpDir) Functions attributes Return a table with the file attributes corresponding to filepath (or nil followed by an error message in case of error). create Create the directory. delete Remove an existing directory. exists Return whether the directory is stored in the computer. list Return a vector of strings with the content of the directory. name Return the name of a given directory. path Return the path of a given directory. relativePath Return a relative path given a small path. setCurrentDir Set the current working directory with the directory path. .. Concatenate the directory. attributes Return a table with the file attributes corresponding to filepath (or nil followed by an error message in case of error). If the second optional argument is given, then only the value of the named attribute is returned. The attributes are described as follows; attribute mode is a string, all the others are numbers, and the time related attributes use the same time reference of os.time. This function uses stat internally thus if the given filepath is a symbolic link, it is followed (if it points to another link the chain is followed recursively) and the information is about the file it refers to. Arguments #1 : A string with the name of the attribute to be read. Attribute Description \"dev\" on Unix systems, this represents the device that the inode resides on. On Windows systems, represents the drive number of the disk containing the file \"ino\" on Unix systems, this represents the inode number. On Windows systems this has no meaning \"mode\" string representing the associated protection mode (the values could be file, directory, link, socket, named pipe, char device, block device or other) \"nlink\" number of hard links to the file \"uid\" user-id of owner (Unix only, always 0 on Windows) \"gid\" group-id of owner (Unix only, always 0 on Windows) \"rdev\" on Unix systems, represents the device type, for special file inodes. On Windows systems represents the same as dev \"access\" time of last access \"modification\" time of last data modification \"change\" time of last file status change \"size\" file size, in bytes \"blocks\" block allocated for file; (Unix only) \"blksize\" optimal file system I/O blocksize; (Unix only) Usage Directory(packageInfo(\"base\").path..\"data\"):attributes(\"mode\") create Create the directory. Returns true if the operation was successful. In case of error, it returns nil plus an error string. Usage dir = Directory(\"mydirectory\") dir:create() print(dir) tmpDir = Directory{ name = \"mytmpdir_XXX\", tmp = true } print(tmpDir) dir:delete() tmpDir:delete() delete Remove an existing directory. It removes all internal files and directories recursively. If the directory does not exist or it cannot be removed, this function stops with an error. Usage dir = Directory(\"mydirectory\") dir:create() dir:delete() exists Return whether the directory is stored in the computer. Usage if Directory(\"C:\\\\TerraME\\\\bin\"):exists() then print(\"is dir\") end list Return a vector of strings with the content of the directory. Arguments #1 : A boolean value indicating whether hidden files should be returned. The default value is false. Usage files = packageInfo(\"base\").data:list() forEachElement(files, function(_, file) print(file) end) name Return the name of a given directory. It is the last directory name given a full path. Usage print(Directory(\"c:\\\\terrame\\\\bin\\\\\"):name()) -- \"bin\" print(Directory(\"/usr/local/bin\"):name()) -- \"bin\" path Return the path of a given directory. In windows, it converts all backslashes into slashes. Usage print(Directory(\"c:\\\\terrame\\\\bin\\\\\"):path()) -- \"c:/terrame\" print(Directory(\"/usr/local/bin\"):path()) -- \"/usr/local\" relativePath Return a relative path given a small path. Arguments #1 : A Directory or a string with a shorter path. Usage d = Directory(\"/my/full/path\") print(d:relativePath(\"/my\")) -- \"full/path\" setCurrentDir Set the current working directory with the directory path. Returns true in case of success or nil plus an error string. Usage Directory(\"c:\\\\tests\"):setCurrentDir() .. Concatenate the directory. It adds a path separator whenever needed. Arguments #1 : A string or an object that can be concatenated. Usage path = sessionInfo().path..\"data\"","title":"Directory"},{"location":"base/types/directory/#directory","text":"An abstract representation of a directory. When creating an instance of a Directory, it does not mean that such directory will be created. It only verifies if the directory has a valid name. Directory also converts backslashes into slashes to make sure paths are represented in the same way in different operational systems. This type provides a set of operations to handle directories, such as to verify if it exists, create, and remove.","title":"Directory"},{"location":"base/types/directory/#arguments","text":"name : A mandatory string with the directory name. It can also be a File . In this case, its value will be File:path() . This argument can be used as a first argument in a call to Directory without named arguments, as in the example below. tmp : An optional boolean value indicating whether the directory should be temporary. The default value is false. When creating a temporary directory, the end of its name must contain X's, which are going to be replaced by random alphanumerical values in order to guarantee that the created directory will not replace a previous one.","title":"Arguments"},{"location":"base/types/directory/#usage","text":"dir = Directory(\"/my/path/my_dir\") tmpDir = Directory{ name = \"mytmpdir_XXX\", tmp = true } print(tmpDir)","title":"Usage"},{"location":"base/types/directory/#functions","text":"attributes Return a table with the file attributes corresponding to filepath (or nil followed by an error message in case of error). create Create the directory. delete Remove an existing directory. exists Return whether the directory is stored in the computer. list Return a vector of strings with the content of the directory. name Return the name of a given directory. path Return the path of a given directory. relativePath Return a relative path given a small path. setCurrentDir Set the current working directory with the directory path. .. Concatenate the directory.","title":"Functions"},{"location":"base/types/directory/#attributes","text":"Return a table with the file attributes corresponding to filepath (or nil followed by an error message in case of error). If the second optional argument is given, then only the value of the named attribute is returned. The attributes are described as follows; attribute mode is a string, all the others are numbers, and the time related attributes use the same time reference of os.time. This function uses stat internally thus if the given filepath is a symbolic link, it is followed (if it points to another link the chain is followed recursively) and the information is about the file it refers to.","title":"attributes"},{"location":"base/types/directory/#arguments_1","text":"#1 : A string with the name of the attribute to be read. Attribute Description \"dev\" on Unix systems, this represents the device that the inode resides on. On Windows systems, represents the drive number of the disk containing the file \"ino\" on Unix systems, this represents the inode number. On Windows systems this has no meaning \"mode\" string representing the associated protection mode (the values could be file, directory, link, socket, named pipe, char device, block device or other) \"nlink\" number of hard links to the file \"uid\" user-id of owner (Unix only, always 0 on Windows) \"gid\" group-id of owner (Unix only, always 0 on Windows) \"rdev\" on Unix systems, represents the device type, for special file inodes. On Windows systems represents the same as dev \"access\" time of last access \"modification\" time of last data modification \"change\" time of last file status change \"size\" file size, in bytes \"blocks\" block allocated for file; (Unix only) \"blksize\" optimal file system I/O blocksize; (Unix only)","title":"Arguments"},{"location":"base/types/directory/#usage_1","text":"Directory(packageInfo(\"base\").path..\"data\"):attributes(\"mode\")","title":"Usage"},{"location":"base/types/directory/#create","text":"Create the directory. Returns true if the operation was successful. In case of error, it returns nil plus an error string.","title":"create"},{"location":"base/types/directory/#usage_2","text":"dir = Directory(\"mydirectory\") dir:create() print(dir) tmpDir = Directory{ name = \"mytmpdir_XXX\", tmp = true } print(tmpDir) dir:delete() tmpDir:delete()","title":"Usage"},{"location":"base/types/directory/#delete","text":"Remove an existing directory. It removes all internal files and directories recursively. If the directory does not exist or it cannot be removed, this function stops with an error.","title":"delete"},{"location":"base/types/directory/#usage_3","text":"dir = Directory(\"mydirectory\") dir:create() dir:delete()","title":"Usage"},{"location":"base/types/directory/#exists","text":"Return whether the directory is stored in the computer.","title":"exists"},{"location":"base/types/directory/#usage_4","text":"if Directory(\"C:\\\\TerraME\\\\bin\"):exists() then print(\"is dir\") end","title":"Usage"},{"location":"base/types/directory/#list","text":"Return a vector of strings with the content of the directory.","title":"list"},{"location":"base/types/directory/#arguments_2","text":"#1 : A boolean value indicating whether hidden files should be returned. The default value is false.","title":"Arguments"},{"location":"base/types/directory/#usage_5","text":"files = packageInfo(\"base\").data:list() forEachElement(files, function(_, file) print(file) end)","title":"Usage"},{"location":"base/types/directory/#name","text":"Return the name of a given directory. It is the last directory name given a full path.","title":"name"},{"location":"base/types/directory/#usage_6","text":"print(Directory(\"c:\\\\terrame\\\\bin\\\\\"):name()) -- \"bin\" print(Directory(\"/usr/local/bin\"):name()) -- \"bin\"","title":"Usage"},{"location":"base/types/directory/#path","text":"Return the path of a given directory. In windows, it converts all backslashes into slashes.","title":"path"},{"location":"base/types/directory/#usage_7","text":"print(Directory(\"c:\\\\terrame\\\\bin\\\\\"):path()) -- \"c:/terrame\" print(Directory(\"/usr/local/bin\"):path()) -- \"/usr/local\"","title":"Usage"},{"location":"base/types/directory/#relativepath","text":"Return a relative path given a small path.","title":"relativePath"},{"location":"base/types/directory/#arguments_3","text":"#1 : A Directory or a string with a shorter path.","title":"Arguments"},{"location":"base/types/directory/#usage_8","text":"d = Directory(\"/my/full/path\") print(d:relativePath(\"/my\")) -- \"full/path\"","title":"Usage"},{"location":"base/types/directory/#setcurrentdir","text":"Set the current working directory with the directory path. Returns true in case of success or nil plus an error string.","title":"setCurrentDir"},{"location":"base/types/directory/#usage_9","text":"Directory(\"c:\\\\tests\"):setCurrentDir()","title":"Usage"},{"location":"base/types/directory/#_1","text":"Concatenate the directory. It adds a path separator whenever needed.","title":".."},{"location":"base/types/directory/#arguments_4","text":"#1 : A string or an object that can be concatenated.","title":"Arguments"},{"location":"base/types/directory/#usage_10","text":"path = sessionInfo().path..\"data\"","title":"Usage"},{"location":"base/types/environment/","text":"Environment A container that encapsulates space, time, behavior, and other Environments. Objects can be added directly when the Environment is declared or after it has been instantiated. It can control the simulation engine, synchronizing all the Timers within it, or instantiate relations between sets of objects. Calling forEachElement() traverses each object of an Environment. If the Environment has a set of Model instances, it is possible to call forEachModel() to traverse them. Arguments ... : Agents , Automatons , Cells , CellularSpaces , Societies , Trajectories , Groups , Timers, Environments, or instances of Models. Attributes Some attributes of Environment have internal semantics. They can be used as read-only by the modeler. cObj_ : A pointer to a C++ representation of the Environment. Never use this object. Usage environment = Environment{ cs1 = CellularSpace{xdim = 10}, ag1 = Agent{}, t1 = Timer{} } Functions add Add an element to the Environment. createPlacement Create relations between behavioural entities ( Agents ) and spatial entities ( Cells ). getTime Return the older simulation time of its Timers . loadNeighborhood Load a Neighborhood between two different CellularSpaces . notify Notify every Observer connected to the Environment. run Run the Environment until a given time. add Add an element to the Environment. Arguments #1 : An Agent , Automaton , Cell , CellularSpace , Society , Trajectory , Group , Event , Timer , Environment, or table. When adding a table, this function converts the table into an Event. When adding an Event, this function converts the Event into a Timer that contains the Event itself. Usage environment = Environment{} cs1 = CellularSpace{xdim = 10} ag1 = Agent{} t1 = Timer{} environment:add(cs1) environment:add(ag1) environment:add(t1) createPlacement Create relations between behavioural entities ( Agents ) and spatial entities ( Cells ). It is possible to have more than one behavioural entity within the Environment, but it must have only one CellularSpace , Trajectory , or Cell. When distributing Agents over a Trajectory or a Cell, the Agents will be able to move over the whole CellularSpace. Note that this function uses rules that will be used only to build the placement. It is up to the modeler to implement such rules for the rest of the simulation if needed. For example, one can use argument max equals to one to indicate that the placement must have at most one Agent per Cell, but it works only to create the placement, having no effect along the simulation. Arguments max : A number representing the maximum number of Agents that can enter in the same Cell when creating the placement. As default it will add at most one Agent per Cell. Note that using this argument does not ensure a maximum number of agents inside Cells along the simulation - controlling the maximum is always up to the modeler. name : A string with the name of the relation. The default value is \"placement\", which means that the modeler can use Agent:enter() , Agent:move() , and Agent:leave() without needing to refer to the name of the placement. If the name is different from the default value, the modeler will have to use the last argument of these functions with the name of the placement. strategy : A string containing the strategy to be used to create a placement between Agents and Cells. See the options below: Strategy Description Arguments \"random\"(default) Choose a Cell randomly and put max agents also chosen randomly. Repeat this process until allocate all Agents. The last Cell chosen might have less than max Agents. All the Cells that were not chosen in this process will remain empty. max, name \"spread\" Choose a Cell randomly and put one agent also chosen randomly. Repeat this process until allocate all Agents. This strategy guarantees that the quantity of agents in each cell is up to max Agents. max, name \"uniform\" Create placements uniformly. The first Agent enters in the first Cell, the second one in the second Cell, and so on. If it reaches the last Cell of the CellularSpace or Trajectory then it starts again in the first Cell. The last Cells will contain fewer Agents if the number of Agents is not proportional to the number of Cells. For example, placing a Society with four Agents into a CellularSpace of three Cells will put two Agents in the first Cell and one in the other two Cells. name \"void\" This strategy creates an empty placement in each Cell and Agent. It is necessary to use this strategy if the modeler needs to establish the relations between Agents and Cells by himself/herself. In this case, Agents cannot use Agent:move() or Agent:walk() before calling Agent:enter() explicitly. name Usage ag = Agent{} soc = Society{ instance = ag, quantity = 20 } cs = CellularSpace{xdim = 10} env = Environment{soc, cs} env:createPlacement() getTime Return the older simulation time of its Timers . Usage env = Environment{ Timer{Event{action = function() end}} } env:run(10) print(env:getTime()) loadNeighborhood Load a Neighborhood between two different CellularSpaces . Arguments bidirect : A boolean value. If true then, for each relation from Cell a to Cell b loaded from the file, it will also create a relation from b to a. The default value is false. file : A File or a string with the name of the file to be loaded. name : A string with the name of the relation to be created. The default value is \"1\". Usage river = CellularSpace{ file = filePath(\"river.shp\") } emas = CellularSpace{ file = filePath(\"emas.shp\") } env = Environment{emas, river} env:loadNeighborhood{file = filePath(\"gpmlinesDbEmas.gpm\", \"base\")} See also filePath (Package) notify Notify every Observer connected to the Environment. Arguments #1 : A number representing the notification time. The default value is zero. It is also possible to use an Event as argument. In this case, it will use the result of Event:getTime() . Usage env = Environment{} env:notify() run Run the Environment until a given time. It activates the Timers it contains, the Timers of the Environments it contains, and so on. Arguments #1 : A number representing the final time. This funcion will stop when there is no Event scheduled to a time less or equal to the final time. When using instances of Models within the Environment (to simulate them at the same time), this argument is optional. In this case, the default value is the greater final time amongst all instances. Usage env = Environment{ Timer{Event{action = function() print(\"execute 1\") end}}, Timer{Event{action = function() print(\"execute 2\") end}} } env:run(10)","title":"Environment"},{"location":"base/types/environment/#environment","text":"A container that encapsulates space, time, behavior, and other Environments. Objects can be added directly when the Environment is declared or after it has been instantiated. It can control the simulation engine, synchronizing all the Timers within it, or instantiate relations between sets of objects. Calling forEachElement() traverses each object of an Environment. If the Environment has a set of Model instances, it is possible to call forEachModel() to traverse them.","title":"Environment"},{"location":"base/types/environment/#arguments","text":"... : Agents , Automatons , Cells , CellularSpaces , Societies , Trajectories , Groups , Timers, Environments, or instances of Models.","title":"Arguments"},{"location":"base/types/environment/#attributes","text":"Some attributes of Environment have internal semantics. They can be used as read-only by the modeler. cObj_ : A pointer to a C++ representation of the Environment. Never use this object.","title":"Attributes"},{"location":"base/types/environment/#usage","text":"environment = Environment{ cs1 = CellularSpace{xdim = 10}, ag1 = Agent{}, t1 = Timer{} }","title":"Usage"},{"location":"base/types/environment/#functions","text":"add Add an element to the Environment. createPlacement Create relations between behavioural entities ( Agents ) and spatial entities ( Cells ). getTime Return the older simulation time of its Timers . loadNeighborhood Load a Neighborhood between two different CellularSpaces . notify Notify every Observer connected to the Environment. run Run the Environment until a given time.","title":"Functions"},{"location":"base/types/environment/#add","text":"Add an element to the Environment.","title":"add"},{"location":"base/types/environment/#arguments_1","text":"#1 : An Agent , Automaton , Cell , CellularSpace , Society , Trajectory , Group , Event , Timer , Environment, or table. When adding a table, this function converts the table into an Event. When adding an Event, this function converts the Event into a Timer that contains the Event itself.","title":"Arguments"},{"location":"base/types/environment/#usage_1","text":"environment = Environment{} cs1 = CellularSpace{xdim = 10} ag1 = Agent{} t1 = Timer{} environment:add(cs1) environment:add(ag1) environment:add(t1)","title":"Usage"},{"location":"base/types/environment/#createplacement","text":"Create relations between behavioural entities ( Agents ) and spatial entities ( Cells ). It is possible to have more than one behavioural entity within the Environment, but it must have only one CellularSpace , Trajectory , or Cell. When distributing Agents over a Trajectory or a Cell, the Agents will be able to move over the whole CellularSpace. Note that this function uses rules that will be used only to build the placement. It is up to the modeler to implement such rules for the rest of the simulation if needed. For example, one can use argument max equals to one to indicate that the placement must have at most one Agent per Cell, but it works only to create the placement, having no effect along the simulation.","title":"createPlacement"},{"location":"base/types/environment/#arguments_2","text":"max : A number representing the maximum number of Agents that can enter in the same Cell when creating the placement. As default it will add at most one Agent per Cell. Note that using this argument does not ensure a maximum number of agents inside Cells along the simulation - controlling the maximum is always up to the modeler. name : A string with the name of the relation. The default value is \"placement\", which means that the modeler can use Agent:enter() , Agent:move() , and Agent:leave() without needing to refer to the name of the placement. If the name is different from the default value, the modeler will have to use the last argument of these functions with the name of the placement. strategy : A string containing the strategy to be used to create a placement between Agents and Cells. See the options below: Strategy Description Arguments \"random\"(default) Choose a Cell randomly and put max agents also chosen randomly. Repeat this process until allocate all Agents. The last Cell chosen might have less than max Agents. All the Cells that were not chosen in this process will remain empty. max, name \"spread\" Choose a Cell randomly and put one agent also chosen randomly. Repeat this process until allocate all Agents. This strategy guarantees that the quantity of agents in each cell is up to max Agents. max, name \"uniform\" Create placements uniformly. The first Agent enters in the first Cell, the second one in the second Cell, and so on. If it reaches the last Cell of the CellularSpace or Trajectory then it starts again in the first Cell. The last Cells will contain fewer Agents if the number of Agents is not proportional to the number of Cells. For example, placing a Society with four Agents into a CellularSpace of three Cells will put two Agents in the first Cell and one in the other two Cells. name \"void\" This strategy creates an empty placement in each Cell and Agent. It is necessary to use this strategy if the modeler needs to establish the relations between Agents and Cells by himself/herself. In this case, Agents cannot use Agent:move() or Agent:walk() before calling Agent:enter() explicitly. name","title":"Arguments"},{"location":"base/types/environment/#usage_2","text":"ag = Agent{} soc = Society{ instance = ag, quantity = 20 } cs = CellularSpace{xdim = 10} env = Environment{soc, cs} env:createPlacement()","title":"Usage"},{"location":"base/types/environment/#gettime","text":"Return the older simulation time of its Timers .","title":"getTime"},{"location":"base/types/environment/#usage_3","text":"env = Environment{ Timer{Event{action = function() end}} } env:run(10) print(env:getTime())","title":"Usage"},{"location":"base/types/environment/#loadneighborhood","text":"Load a Neighborhood between two different CellularSpaces .","title":"loadNeighborhood"},{"location":"base/types/environment/#arguments_3","text":"bidirect : A boolean value. If true then, for each relation from Cell a to Cell b loaded from the file, it will also create a relation from b to a. The default value is false. file : A File or a string with the name of the file to be loaded. name : A string with the name of the relation to be created. The default value is \"1\".","title":"Arguments"},{"location":"base/types/environment/#usage_4","text":"river = CellularSpace{ file = filePath(\"river.shp\") } emas = CellularSpace{ file = filePath(\"emas.shp\") } env = Environment{emas, river} env:loadNeighborhood{file = filePath(\"gpmlinesDbEmas.gpm\", \"base\")}","title":"Usage"},{"location":"base/types/environment/#see-also","text":"filePath (Package)","title":"See also"},{"location":"base/types/environment/#notify","text":"Notify every Observer connected to the Environment.","title":"notify"},{"location":"base/types/environment/#arguments_4","text":"#1 : A number representing the notification time. The default value is zero. It is also possible to use an Event as argument. In this case, it will use the result of Event:getTime() .","title":"Arguments"},{"location":"base/types/environment/#usage_5","text":"env = Environment{} env:notify()","title":"Usage"},{"location":"base/types/environment/#run","text":"Run the Environment until a given time. It activates the Timers it contains, the Timers of the Environments it contains, and so on.","title":"run"},{"location":"base/types/environment/#arguments_5","text":"#1 : A number representing the final time. This funcion will stop when there is no Event scheduled to a time less or equal to the final time. When using instances of Models within the Environment (to simulate them at the same time), this argument is optional. In this case, the default value is the greater final time amongst all instances.","title":"Arguments"},{"location":"base/types/environment/#usage_6","text":"env = Environment{ Timer{Event{action = function() print(\"execute 1\") end}}, Timer{Event{action = function() print(\"execute 2\") end}} } env:run(10)","title":"Usage"},{"location":"base/types/event/","text":"Event An Event represents a time instant when the simulation engine must execute some computation. In order to be executed, Events must belong to a Timer . An Event is usually rescheduled to be executed again according to its period, unless its action explicitly returns false. Arguments action : A function that will be executed when the Event is activated. It has one single argument, the Event itself. If the action returns false, the Event is removed from the Timer and will not be executed again. When the action will execute a single function of a TerraME object, it is possible to use call() . Action can also be a TerraME object. In this case, each type has its own set of functions that will be activated by the Event. See below how the objects are activated. Arrows indicate the execution order: Object Function(s) activated by the Event Default priority Agent / Automaton execute 0 (\"medium\") CellularSpace / Cell synchronize and then execute (if exists) -5 (\"high\") Chart / Map / Clock / Log / InternetSender / VisualTable / TextScreen update 10 (\"verylow\") function the function itself 0 (\"medium\") Model execute (if exists) 0 (\"medium\") Society synchronize and then execute (if exists) 0 (\"medium\") Trajectory / Group rebuild and then execute (if exists) 0 (\"medium\") period : A positive number representing the periodicity of the Event. The default value is 1. If it is zero or false, the Event will execute only once and then it will be removed from its Timer. priority : A number with the priority of the Event over other Events. Smaller values have higher priority. The default value depends on the type of its action. Priorities can also be defined as strings: Value Priority \"verylow\" 10 \"low\" 5 \"medium\" 0 \"high\" -5 \"veryhigh\" -10 start : A number representing the time instant when the Event will occur for the first time. The default value is one, except when using graphics (Chart, Map, Clock, etc.) as action. In this case the default value is zero, plotting the initial state of the simulation. Usage event = Event {start = 1985, period = 2, priority = -1, action = function(event) print(event:getTime()) end} agent = Agent{ execute = function() print(\"executing\") end } event2 = Event{ start = 2000, action = agent } timer = Timer{event, event2} timer:run(10) Functions config Change the attributes of the Event. getParent Return the Timer that contains the Event. getPeriod Return the period of the Event. getPriority Return the priority of the Event. getTime Return the current simulation time, according to the Timer it belongs. config Change the attributes of the Event. It will be rescheduled according to its new attributes if this function is called while the action is being executed. Be careful when using this function outside the events's action, because the scheduler will not update its queue. In this case, it is recommended to replace the Event by another one. Arguments period : The new periodicity of the Event. priority : The new priority of the Event. time : The time instant the Event will occur. Usage event = Event{start = 2, action = function() end} event:config{priority = -1} event:config{time = 10, period = 2} getParent Return the Timer that contains the Event. Usage event = Event {action = function(event) print(event:getTime()) end} timer = Timer{event} parent = event:getParent() if parent == timer then print(\"equal\") end getPeriod Return the period of the Event. Usage event = Event {start = 1985, period = 2, priority = -1, action = function(event) print(event:getTime()) end} period = event:getPeriod() print(period) getPriority Return the priority of the Event. Usage event = Event {start = 1985, period = 2, priority = -1, action = function(event) print(event:getTime()) end} priority = event:getPriority() print(priority) getTime Return the current simulation time, according to the Timer it belongs. Usage event = Event {start = 1985, period = 2, priority = -1, action = function(event) print(event:getTime()) end} time = event:getTime() print(time)","title":"Event"},{"location":"base/types/event/#event","text":"An Event represents a time instant when the simulation engine must execute some computation. In order to be executed, Events must belong to a Timer . An Event is usually rescheduled to be executed again according to its period, unless its action explicitly returns false.","title":"Event"},{"location":"base/types/event/#arguments","text":"action : A function that will be executed when the Event is activated. It has one single argument, the Event itself. If the action returns false, the Event is removed from the Timer and will not be executed again. When the action will execute a single function of a TerraME object, it is possible to use call() . Action can also be a TerraME object. In this case, each type has its own set of functions that will be activated by the Event. See below how the objects are activated. Arrows indicate the execution order: Object Function(s) activated by the Event Default priority Agent / Automaton execute 0 (\"medium\") CellularSpace / Cell synchronize and then execute (if exists) -5 (\"high\") Chart / Map / Clock / Log / InternetSender / VisualTable / TextScreen update 10 (\"verylow\") function the function itself 0 (\"medium\") Model execute (if exists) 0 (\"medium\") Society synchronize and then execute (if exists) 0 (\"medium\") Trajectory / Group rebuild and then execute (if exists) 0 (\"medium\") period : A positive number representing the periodicity of the Event. The default value is 1. If it is zero or false, the Event will execute only once and then it will be removed from its Timer. priority : A number with the priority of the Event over other Events. Smaller values have higher priority. The default value depends on the type of its action. Priorities can also be defined as strings: Value Priority \"verylow\" 10 \"low\" 5 \"medium\" 0 \"high\" -5 \"veryhigh\" -10 start : A number representing the time instant when the Event will occur for the first time. The default value is one, except when using graphics (Chart, Map, Clock, etc.) as action. In this case the default value is zero, plotting the initial state of the simulation.","title":"Arguments"},{"location":"base/types/event/#usage","text":"event = Event {start = 1985, period = 2, priority = -1, action = function(event) print(event:getTime()) end} agent = Agent{ execute = function() print(\"executing\") end } event2 = Event{ start = 2000, action = agent } timer = Timer{event, event2} timer:run(10)","title":"Usage"},{"location":"base/types/event/#functions","text":"config Change the attributes of the Event. getParent Return the Timer that contains the Event. getPeriod Return the period of the Event. getPriority Return the priority of the Event. getTime Return the current simulation time, according to the Timer it belongs.","title":"Functions"},{"location":"base/types/event/#config","text":"Change the attributes of the Event. It will be rescheduled according to its new attributes if this function is called while the action is being executed. Be careful when using this function outside the events's action, because the scheduler will not update its queue. In this case, it is recommended to replace the Event by another one.","title":"config"},{"location":"base/types/event/#arguments_1","text":"period : The new periodicity of the Event. priority : The new priority of the Event. time : The time instant the Event will occur.","title":"Arguments"},{"location":"base/types/event/#usage_1","text":"event = Event{start = 2, action = function() end} event:config{priority = -1} event:config{time = 10, period = 2}","title":"Usage"},{"location":"base/types/event/#getparent","text":"Return the Timer that contains the Event.","title":"getParent"},{"location":"base/types/event/#usage_2","text":"event = Event {action = function(event) print(event:getTime()) end} timer = Timer{event} parent = event:getParent() if parent == timer then print(\"equal\") end","title":"Usage"},{"location":"base/types/event/#getperiod","text":"Return the period of the Event.","title":"getPeriod"},{"location":"base/types/event/#usage_3","text":"event = Event {start = 1985, period = 2, priority = -1, action = function(event) print(event:getTime()) end} period = event:getPeriod() print(period)","title":"Usage"},{"location":"base/types/event/#getpriority","text":"Return the priority of the Event.","title":"getPriority"},{"location":"base/types/event/#usage_4","text":"event = Event {start = 1985, period = 2, priority = -1, action = function(event) print(event:getTime()) end} priority = event:getPriority() print(priority)","title":"Usage"},{"location":"base/types/event/#gettime","text":"Return the current simulation time, according to the Timer it belongs.","title":"getTime"},{"location":"base/types/event/#usage_5","text":"event = Event {start = 1985, period = 2, priority = -1, action = function(event) print(event:getTime()) end} time = event:getTime() print(time)","title":"Usage"},{"location":"base/types/file/","text":"File An abstract representation of a file. Whenever an instance of File is created, it only verifies whether it is possible to have a file with the given name and if its directory exists (in case of explicitly specified). It will not stop with an error if the file does not exist. The file is only opened when a read function is called. The file is only created if a write function is called. Arguments name : A string with the file name. This argument is mandatory. Usage file = File(\"agents.csv\") Functions attributes Return a table with the file attributes corresponding to filepath (or nil followed by an error message in case of error). close Close an opened file. copy Copy the file to a given destination. delete Remove an existing file. deleteIfExists Remove a file if it exists. exists Return whether the file stored in the computer. extension Return the extension of the file. hasExtension Return a boolean value if the file has an extension. name Return the file name removing its path. open Open the file for reading or writing. path Return the path to the file. read Read a file. readLine Read a line from the file. split Split the path, name, and extension of the file into three returning values. touch Set access and modification times for the file. write Write a given DataFrame into the file. writeLine Write a given string or table into the file. .. Concatenate the file. attributes Return a table with the file attributes corresponding to filepath (or nil followed by an error message in case of error). The attributes are described as follows; attribute mode is a string, all the others are numbers, and the time related attributes use the same time reference of os.time. This function uses stat internally thus if the given filepath is a symbolic link, it is followed (if it points to another link the chain is followed recursively) and the information is about the file it refers to. Arguments #1 : A string with the name of the attribute to be read. Attribute Description \"dev\" on Unix systems, this represents the device that the inode resides on. On Windows systems, represents the drive number of the disk containing the file \"ino\" on Unix systems, this represents the inode number. On Windows systems this has no meaning \"mode\" string representing the associated protection mode (the values could be file, directory, link, socket, named pipe, char device, block device or other) \"nlink\" number of hard links to the file \"uid\" user-id of owner (Unix only, always 0 on Windows) \"gid\" group-id of owner (Unix only, always 0 on Windows) \"rdev\" on Unix systems, represents the device type, for special file inodes. On Windows systems represents the same as dev \"access\" time of last access \"modification\" time of last data modification \"change\" time of last file status change \"size\" file size, in bytes \"blocks\" block allocated for file; (Unix only) \"blksize\" optimal file system I/O blocksize; (Unix only) Usage filePath(\"river.shp\"):attributes(\"mode\") close Close an opened file. Usage file = File(\"abc.txt\") file:close() copy Copy the file to a given destination. Arguments #1 : A Directory or a string with the destination path. It can also be a File with the destination. If the file to be copied is a shapefile, it also copies the respective dbf, shx, prj, and qix files if they exist. Usage path = Directory(\"c:/mypath\") file = File(path..\"file.lua\") file:copy(File(path..\"file2.lua\")) -- from c:/mypath/file.lua to c:/mypath/file2.lua delete Remove an existing file. If the file does not exist or it cannot be removed, this function stops with an error. If the file to be removed is a shapefile, it also removes the respective dbf, shx, prj, and qix files if they exist. Usage filename = \"myfile.txt\" file = File(filename) file:writeLine(\"Some text..\") file:close() file:delete() deleteIfExists Remove a file if it exists. It does not stop with an error when the file does not exist. This function returns the File itself. Usage filename = \"myfile.txt\" file = File(filename) file:writeLine(\"Some text..\") file:close() file:deleteIfExists() file = File(filename):deleteIfExists() -- ensure that \"myfile.txt\" does not exist when 'file' is created exists Return whether the file stored in the computer. Usage file = filePath(\"agents.csv\", \"base\") print(file:exists()) extension Return the extension of the file. It returns the substring after the last dot. If it does not have a dot, an empty string is returned. Usage file = filePath(\"agents.csv\", \"base\") print(file:extension()) -- \"csv\" hasExtension Return a boolean value if the file has an extension. Usage file = filePath(\"agents.csv\", \"base\") print(file:hasExtension()) -- true name Return the file name removing its path. Usage file = filePath(\"agents.csv\", \"base\") print(file:name()) -- \"agents.csv\" open Open the file for reading or writing. An opened file must be closed after being used. Arguments #1 : A string with the mode. It can be \"w\" for writing or \"r\" for reading. Usage file = File(\"myfile.txt\") file:open() See also close path Return the path to the file. Usage file = filePath(\"agents.csv\", \"base\") print(file:path()) read Read a file. It returns a vector (whose indexes are line numbers) containing named tables (whose indexes are attribute names). The first line of the file list the attribute names. This function automatically closes the file. Arguments #1 : A string with the separator. The default value is ','. Usage file = filePath(\"agents.csv\", \"base\") csv = file:read() print(csv[1].age) -- 20 readLine Read a line from the file. It stores the position of the line internally in case of some error occur. Therefore no line number will be used as argument for this function. Arguments #1 : A string with the separator. Parse a single CSV line. It returns a vector of strings with the i-th value in the position i. This function was taken from http://lua-users.org/wiki/LuaCsv. Usage file = filePath(\"agents.csv\", \"base\") line = file:readLine(\",\") print(line[1]) -- john print(line[2]) -- 20 print(line[3]) -- 200 line = file:readLine() print(line) -- \"mary\",18,100,3,1,false split Split the path, name, and extension of the file into three returning values. Usage file = filePath(\"agents.csv\", \"base\") directory, name, extension = file:split() print(directory) -- \"/base/data/\" print(name) -- \"agents\", print(extension) -- \"csv\" touch Set access and modification times for the file. Times are provided in seconds (which should be generated with Lua standard function os.time). If the modification time is omitted, the access time provided is used; if both times are omitted, the current time is used. Returns true if the operation was successful; in case of error, it returns nil plus an error string. Arguments #1 : The new access time (in seconds). #2 : The new modification time (in seconds). Usage filePath(\"river.shp\"):touch(0, 0) write Write a given DataFrame into the file. It automatically closes the file after writing it. Arguments #1 : A DataFrame. #2 : A string with the separator. The default value is ','. Usage mytable = DataFrame{ {age = 1, wealth = 10, vision = 2}, {age = 3, wealth = 8, vision = 1}, {age = 3, wealth = 15, vision = 2} } file = File(\"file.csv\") file:write(mytable, \";\") file:deleteIfExists() writeLine Write a given string or table into the file. The file must be closed afterwards. It automatically adds an end of line to the file after the string. Arguments #1 : A string or table to be saved. A table it must be a vector with the values to be saved in a given line. #2 : A string with the separator. The default value is ','. Usage mytable = {\"x\", \"y\", \"z\"} file = File(\"file.csv\") file:writeLine(mytable, \";\") file:writeLine(\"Some text..\") file:close() file:deleteIfExists() .. Concatenate the file. Arguments #1 : A string or an object that can be concatenated. Usage print(File(\"abcd1234\")..\" does not exist.\")","title":"File"},{"location":"base/types/file/#file","text":"An abstract representation of a file. Whenever an instance of File is created, it only verifies whether it is possible to have a file with the given name and if its directory exists (in case of explicitly specified). It will not stop with an error if the file does not exist. The file is only opened when a read function is called. The file is only created if a write function is called.","title":"File"},{"location":"base/types/file/#arguments","text":"name : A string with the file name. This argument is mandatory.","title":"Arguments"},{"location":"base/types/file/#usage","text":"file = File(\"agents.csv\")","title":"Usage"},{"location":"base/types/file/#functions","text":"attributes Return a table with the file attributes corresponding to filepath (or nil followed by an error message in case of error). close Close an opened file. copy Copy the file to a given destination. delete Remove an existing file. deleteIfExists Remove a file if it exists. exists Return whether the file stored in the computer. extension Return the extension of the file. hasExtension Return a boolean value if the file has an extension. name Return the file name removing its path. open Open the file for reading or writing. path Return the path to the file. read Read a file. readLine Read a line from the file. split Split the path, name, and extension of the file into three returning values. touch Set access and modification times for the file. write Write a given DataFrame into the file. writeLine Write a given string or table into the file. .. Concatenate the file.","title":"Functions"},{"location":"base/types/file/#attributes","text":"Return a table with the file attributes corresponding to filepath (or nil followed by an error message in case of error). The attributes are described as follows; attribute mode is a string, all the others are numbers, and the time related attributes use the same time reference of os.time. This function uses stat internally thus if the given filepath is a symbolic link, it is followed (if it points to another link the chain is followed recursively) and the information is about the file it refers to.","title":"attributes"},{"location":"base/types/file/#arguments_1","text":"#1 : A string with the name of the attribute to be read. Attribute Description \"dev\" on Unix systems, this represents the device that the inode resides on. On Windows systems, represents the drive number of the disk containing the file \"ino\" on Unix systems, this represents the inode number. On Windows systems this has no meaning \"mode\" string representing the associated protection mode (the values could be file, directory, link, socket, named pipe, char device, block device or other) \"nlink\" number of hard links to the file \"uid\" user-id of owner (Unix only, always 0 on Windows) \"gid\" group-id of owner (Unix only, always 0 on Windows) \"rdev\" on Unix systems, represents the device type, for special file inodes. On Windows systems represents the same as dev \"access\" time of last access \"modification\" time of last data modification \"change\" time of last file status change \"size\" file size, in bytes \"blocks\" block allocated for file; (Unix only) \"blksize\" optimal file system I/O blocksize; (Unix only)","title":"Arguments"},{"location":"base/types/file/#usage_1","text":"filePath(\"river.shp\"):attributes(\"mode\")","title":"Usage"},{"location":"base/types/file/#close","text":"Close an opened file.","title":"close"},{"location":"base/types/file/#usage_2","text":"file = File(\"abc.txt\") file:close()","title":"Usage"},{"location":"base/types/file/#copy","text":"Copy the file to a given destination.","title":"copy"},{"location":"base/types/file/#arguments_2","text":"#1 : A Directory or a string with the destination path. It can also be a File with the destination. If the file to be copied is a shapefile, it also copies the respective dbf, shx, prj, and qix files if they exist.","title":"Arguments"},{"location":"base/types/file/#usage_3","text":"path = Directory(\"c:/mypath\") file = File(path..\"file.lua\") file:copy(File(path..\"file2.lua\")) -- from c:/mypath/file.lua to c:/mypath/file2.lua","title":"Usage"},{"location":"base/types/file/#delete","text":"Remove an existing file. If the file does not exist or it cannot be removed, this function stops with an error. If the file to be removed is a shapefile, it also removes the respective dbf, shx, prj, and qix files if they exist.","title":"delete"},{"location":"base/types/file/#usage_4","text":"filename = \"myfile.txt\" file = File(filename) file:writeLine(\"Some text..\") file:close() file:delete()","title":"Usage"},{"location":"base/types/file/#deleteifexists","text":"Remove a file if it exists. It does not stop with an error when the file does not exist. This function returns the File itself.","title":"deleteIfExists"},{"location":"base/types/file/#usage_5","text":"filename = \"myfile.txt\" file = File(filename) file:writeLine(\"Some text..\") file:close() file:deleteIfExists() file = File(filename):deleteIfExists() -- ensure that \"myfile.txt\" does not exist when 'file' is created","title":"Usage"},{"location":"base/types/file/#exists","text":"Return whether the file stored in the computer.","title":"exists"},{"location":"base/types/file/#usage_6","text":"file = filePath(\"agents.csv\", \"base\") print(file:exists())","title":"Usage"},{"location":"base/types/file/#extension","text":"Return the extension of the file. It returns the substring after the last dot. If it does not have a dot, an empty string is returned.","title":"extension"},{"location":"base/types/file/#usage_7","text":"file = filePath(\"agents.csv\", \"base\") print(file:extension()) -- \"csv\"","title":"Usage"},{"location":"base/types/file/#hasextension","text":"Return a boolean value if the file has an extension.","title":"hasExtension"},{"location":"base/types/file/#usage_8","text":"file = filePath(\"agents.csv\", \"base\") print(file:hasExtension()) -- true","title":"Usage"},{"location":"base/types/file/#name","text":"Return the file name removing its path.","title":"name"},{"location":"base/types/file/#usage_9","text":"file = filePath(\"agents.csv\", \"base\") print(file:name()) -- \"agents.csv\"","title":"Usage"},{"location":"base/types/file/#open","text":"Open the file for reading or writing. An opened file must be closed after being used.","title":"open"},{"location":"base/types/file/#arguments_3","text":"#1 : A string with the mode. It can be \"w\" for writing or \"r\" for reading.","title":"Arguments"},{"location":"base/types/file/#usage_10","text":"file = File(\"myfile.txt\") file:open()","title":"Usage"},{"location":"base/types/file/#see-also","text":"close","title":"See also"},{"location":"base/types/file/#path","text":"Return the path to the file.","title":"path"},{"location":"base/types/file/#usage_11","text":"file = filePath(\"agents.csv\", \"base\") print(file:path())","title":"Usage"},{"location":"base/types/file/#read","text":"Read a file. It returns a vector (whose indexes are line numbers) containing named tables (whose indexes are attribute names). The first line of the file list the attribute names. This function automatically closes the file.","title":"read"},{"location":"base/types/file/#arguments_4","text":"#1 : A string with the separator. The default value is ','.","title":"Arguments"},{"location":"base/types/file/#usage_12","text":"file = filePath(\"agents.csv\", \"base\") csv = file:read() print(csv[1].age) -- 20","title":"Usage"},{"location":"base/types/file/#readline","text":"Read a line from the file. It stores the position of the line internally in case of some error occur. Therefore no line number will be used as argument for this function.","title":"readLine"},{"location":"base/types/file/#arguments_5","text":"#1 : A string with the separator. Parse a single CSV line. It returns a vector of strings with the i-th value in the position i. This function was taken from http://lua-users.org/wiki/LuaCsv.","title":"Arguments"},{"location":"base/types/file/#usage_13","text":"file = filePath(\"agents.csv\", \"base\") line = file:readLine(\",\") print(line[1]) -- john print(line[2]) -- 20 print(line[3]) -- 200 line = file:readLine() print(line) -- \"mary\",18,100,3,1,false","title":"Usage"},{"location":"base/types/file/#split","text":"Split the path, name, and extension of the file into three returning values.","title":"split"},{"location":"base/types/file/#usage_14","text":"file = filePath(\"agents.csv\", \"base\") directory, name, extension = file:split() print(directory) -- \"/base/data/\" print(name) -- \"agents\", print(extension) -- \"csv\"","title":"Usage"},{"location":"base/types/file/#touch","text":"Set access and modification times for the file. Times are provided in seconds (which should be generated with Lua standard function os.time). If the modification time is omitted, the access time provided is used; if both times are omitted, the current time is used. Returns true if the operation was successful; in case of error, it returns nil plus an error string.","title":"touch"},{"location":"base/types/file/#arguments_6","text":"#1 : The new access time (in seconds). #2 : The new modification time (in seconds).","title":"Arguments"},{"location":"base/types/file/#usage_15","text":"filePath(\"river.shp\"):touch(0, 0)","title":"Usage"},{"location":"base/types/file/#write","text":"Write a given DataFrame into the file. It automatically closes the file after writing it.","title":"write"},{"location":"base/types/file/#arguments_7","text":"#1 : A DataFrame. #2 : A string with the separator. The default value is ','.","title":"Arguments"},{"location":"base/types/file/#usage_16","text":"mytable = DataFrame{ {age = 1, wealth = 10, vision = 2}, {age = 3, wealth = 8, vision = 1}, {age = 3, wealth = 15, vision = 2} } file = File(\"file.csv\") file:write(mytable, \";\") file:deleteIfExists()","title":"Usage"},{"location":"base/types/file/#writeline","text":"Write a given string or table into the file. The file must be closed afterwards. It automatically adds an end of line to the file after the string.","title":"writeLine"},{"location":"base/types/file/#arguments_8","text":"#1 : A string or table to be saved. A table it must be a vector with the values to be saved in a given line. #2 : A string with the separator. The default value is ','.","title":"Arguments"},{"location":"base/types/file/#usage_17","text":"mytable = {\"x\", \"y\", \"z\"} file = File(\"file.csv\") file:writeLine(mytable, \";\") file:writeLine(\"Some text..\") file:close() file:deleteIfExists()","title":"Usage"},{"location":"base/types/file/#_1","text":"Concatenate the file.","title":".."},{"location":"base/types/file/#arguments_9","text":"#1 : A string or an object that can be concatenated.","title":"Arguments"},{"location":"base/types/file/#usage_18","text":"print(File(\"abcd1234\")..\" does not exist.\")","title":"Usage"},{"location":"base/types/flow/","text":"Flow A Flow describes the behavior of an automaton or Agent in a given State . Arguments 1st : A function(ev, agent, cell), where the arguments are: an Event that activated the Flow, the Automaton or Agent that owns the Flow, and the Cell over which the Flow will be evaluated. Usage Flow{function(ev, agent, cell) agent.value = agent.value + 2 end}","title":"Flow"},{"location":"base/types/flow/#flow","text":"A Flow describes the behavior of an automaton or Agent in a given State .","title":"Flow"},{"location":"base/types/flow/#arguments","text":"1st : A function(ev, agent, cell), where the arguments are: an Event that activated the Flow, the Automaton or Agent that owns the Flow, and the Cell over which the Flow will be evaluated.","title":"Arguments"},{"location":"base/types/flow/#usage","text":"Flow{function(ev, agent, cell) agent.value = agent.value + 2 end}","title":"Usage"},{"location":"base/types/group/","text":"Group (inherits Society ) Type that defines an ordered selection over a Society . It inherits Society; therefore it is possible to apply all functions of such type to a Group. For instance, calling forEachAgent() also traverses Groups. Arguments build : A boolean value indicating whether the Group should be computed when created. The default value is true. greater : A function ( Agent , Agent)->boolean to sort the Group. Such function must return true if the first Agent has priority over the second one. When using this argument, Group compares each pair of Agents to establish an execution order to be used by forEachAgent() . As default, the Group will not be ordered and so forEachCell() will run in the order the Agents were pushed into the Society. See greaterByAttribute() for predefined options for this argument. random : A boolean value indicating that the Group must be shuffled. The Group will be shuffled every time one calls rebuild() or when the Group is an action of an Event . This argument cannot be combined with argument greater. select : A function (Agent)->boolean indicating whether an Agent of the Society should belong to the Group. If this function returns anything but false or nil for a given Agent, it will be added to the Group. If this argument is missing, all Agents will be included in the Group. target : The Society over which the Group will take place. Attributes Some attributes of Group have internal semantics. They can be used as read-only by the modeler. agents : A vector with Agents of the Group. greater : The last function used to sort the Group. parent : The Society used by the Group (its target). select : The last function used to filter the Group. Usage agent = Agent{ age = Random{min = 10, max = 50, step = 1} } soc = Society{ instance = agent, quantity = 20 } group = Group{ target = society, select = function(agent) return agent.age > 20 end } groupBySize = Group{ target = society, greater = function(a1, a2) return a1.age > a2.age end } Functions add Add a new Agent to the Group. clone Return a copy of the Group. filter Apply the filter again over the Society used as target for the Group. randomize Randomize the Agents of the Group. rebuild Rebuild the Group. sort Sort the current Society subset. # Return the number of Agents in the Group. add Add a new Agent to the Group. It will be added to the end of the list of Agents. Arguments #1 : An Agent. Usage agent = Agent{} group = Group{} group:add(agent) clone Return a copy of the Group. It has the same parent, select, greater and Agents . Any change in the cloned Group will not affect the original one. Usage agent = Agent{ age = Random{min = 0, max = 50, step = 1} } soc = Society{ instance = agent, quantity = 20 } group = Group{ target = soc, select = function(agent) return agent.age < 10 end } group2 = group:clone() print(#group) print(#group2) filter Apply the filter again over the Society used as target for the Group. Agents that belong to the Society but do not belong to the Group are ignored. This way, this function creates a subset over the subset of the Society. Usage agent = Agent{ age = Random{min = 0, max = 50, step = 1}, execute = function(self) self.age = self.age + 1 end } soc = Society{ instance = agent, quantity = 20 } group = Group{target = soc, select = function(agent) return agent.age >= 18 end} group:execute() group:filter() randomize Randomize the Agents of the Group. It will change the traversing order used by forEachAgent() . Usage agent = Agent{ age = Random{min = 0, max = 50, step = 1} } soc = Society{ instance = agent, quantity = 20 } group = Group{ target = soc } group:randomize() rebuild Rebuild the Group. It works as if the Group was declared again with the same arguments. Usage agent = Agent{ age = Random{min = 0, max = 50, step = 1} } soc = Society{ instance = agent, quantity = 20 } group = Group{ target = soc, select = function(agent) return agent.age < 10 end, greater = function(a1, a2) return a1.age > a2.age end } forEachAgent(group, function(agent) agent.age = agent.age + 5 end) group:rebuild() sort Sort the current Society subset. It updates the traversing order of the Group. Usage agent = Agent{ age = Random{min = 0, max = 50, step = 1}, execute = function(self) self.age = self.age + Random{min = 0, max = 2}:sample() end } soc = Society{ instance = agent, quantity = 20 } group = Group{target = soc, greater = function(ag1, ag2) return ag1.age > ag2.age end} group:execute() group:sort() # Return the number of Agents in the Group. Usage agent = Agent{ age = Random{min = 0, max = 50, step = 1} } soc = Society{ instance = agent, quantity = 20 } group = Group{ target = soc, select = function(agent) return agent.age < 10 end } print(#group)","title":"Group"},{"location":"base/types/group/#group-inherits-society","text":"Type that defines an ordered selection over a Society . It inherits Society; therefore it is possible to apply all functions of such type to a Group. For instance, calling forEachAgent() also traverses Groups.","title":"Group (inherits Society)"},{"location":"base/types/group/#arguments","text":"build : A boolean value indicating whether the Group should be computed when created. The default value is true. greater : A function ( Agent , Agent)->boolean to sort the Group. Such function must return true if the first Agent has priority over the second one. When using this argument, Group compares each pair of Agents to establish an execution order to be used by forEachAgent() . As default, the Group will not be ordered and so forEachCell() will run in the order the Agents were pushed into the Society. See greaterByAttribute() for predefined options for this argument. random : A boolean value indicating that the Group must be shuffled. The Group will be shuffled every time one calls rebuild() or when the Group is an action of an Event . This argument cannot be combined with argument greater. select : A function (Agent)->boolean indicating whether an Agent of the Society should belong to the Group. If this function returns anything but false or nil for a given Agent, it will be added to the Group. If this argument is missing, all Agents will be included in the Group. target : The Society over which the Group will take place.","title":"Arguments"},{"location":"base/types/group/#attributes","text":"Some attributes of Group have internal semantics. They can be used as read-only by the modeler. agents : A vector with Agents of the Group. greater : The last function used to sort the Group. parent : The Society used by the Group (its target). select : The last function used to filter the Group.","title":"Attributes"},{"location":"base/types/group/#usage","text":"agent = Agent{ age = Random{min = 10, max = 50, step = 1} } soc = Society{ instance = agent, quantity = 20 } group = Group{ target = society, select = function(agent) return agent.age > 20 end } groupBySize = Group{ target = society, greater = function(a1, a2) return a1.age > a2.age end }","title":"Usage"},{"location":"base/types/group/#functions","text":"add Add a new Agent to the Group. clone Return a copy of the Group. filter Apply the filter again over the Society used as target for the Group. randomize Randomize the Agents of the Group. rebuild Rebuild the Group. sort Sort the current Society subset. # Return the number of Agents in the Group.","title":"Functions"},{"location":"base/types/group/#add","text":"Add a new Agent to the Group. It will be added to the end of the list of Agents.","title":"add"},{"location":"base/types/group/#arguments_1","text":"#1 : An Agent.","title":"Arguments"},{"location":"base/types/group/#usage_1","text":"agent = Agent{} group = Group{} group:add(agent)","title":"Usage"},{"location":"base/types/group/#clone","text":"Return a copy of the Group. It has the same parent, select, greater and Agents . Any change in the cloned Group will not affect the original one.","title":"clone"},{"location":"base/types/group/#usage_2","text":"agent = Agent{ age = Random{min = 0, max = 50, step = 1} } soc = Society{ instance = agent, quantity = 20 } group = Group{ target = soc, select = function(agent) return agent.age < 10 end } group2 = group:clone() print(#group) print(#group2)","title":"Usage"},{"location":"base/types/group/#filter","text":"Apply the filter again over the Society used as target for the Group. Agents that belong to the Society but do not belong to the Group are ignored. This way, this function creates a subset over the subset of the Society.","title":"filter"},{"location":"base/types/group/#usage_3","text":"agent = Agent{ age = Random{min = 0, max = 50, step = 1}, execute = function(self) self.age = self.age + 1 end } soc = Society{ instance = agent, quantity = 20 } group = Group{target = soc, select = function(agent) return agent.age >= 18 end} group:execute() group:filter()","title":"Usage"},{"location":"base/types/group/#randomize","text":"Randomize the Agents of the Group. It will change the traversing order used by forEachAgent() .","title":"randomize"},{"location":"base/types/group/#usage_4","text":"agent = Agent{ age = Random{min = 0, max = 50, step = 1} } soc = Society{ instance = agent, quantity = 20 } group = Group{ target = soc } group:randomize()","title":"Usage"},{"location":"base/types/group/#rebuild","text":"Rebuild the Group. It works as if the Group was declared again with the same arguments.","title":"rebuild"},{"location":"base/types/group/#usage_5","text":"agent = Agent{ age = Random{min = 0, max = 50, step = 1} } soc = Society{ instance = agent, quantity = 20 } group = Group{ target = soc, select = function(agent) return agent.age < 10 end, greater = function(a1, a2) return a1.age > a2.age end } forEachAgent(group, function(agent) agent.age = agent.age + 5 end) group:rebuild()","title":"Usage"},{"location":"base/types/group/#sort","text":"Sort the current Society subset. It updates the traversing order of the Group.","title":"sort"},{"location":"base/types/group/#usage_6","text":"agent = Agent{ age = Random{min = 0, max = 50, step = 1}, execute = function(self) self.age = self.age + Random{min = 0, max = 2}:sample() end } soc = Society{ instance = agent, quantity = 20 } group = Group{target = soc, greater = function(ag1, ag2) return ag1.age > ag2.age end} group:execute() group:sort()","title":"Usage"},{"location":"base/types/group/#_1","text":"Return the number of Agents in the Group.","title":"#"},{"location":"base/types/group/#usage_7","text":"agent = Agent{ age = Random{min = 0, max = 50, step = 1} } soc = Society{ instance = agent, quantity = 20 } group = Group{ target = soc, select = function(agent) return agent.age < 10 end } print(#group)","title":"Usage"},{"location":"base/types/internetSender/","text":"InternetSender An Internet connection to send attribute values of an object through a TCP or UDP protocol. Every call to notify (for example, Agent:notify() ) in the target activates the InternetSender. Arguments compress : Compress the data to be transfered? It might be interesting not to compress when the connection is on the localhost, or when there is a very fast connection, to make the simulation faster. The default value is true. host : A string with the host name to transfer the data. The default value is \"localhost\". port : A number greater or equal to 50000 indicating the port of the host to transfer the data. The default value is 456456. protocol : A string with the protocol to be used. It can be \"tcp\" (default) or \"udp\". select : A vector of strings with the name of the attributes to be observed. If it is a single value then it can also be described as a string. As default, it selects all the user-defined attributes of an object. When using a CellularSpace as subject, the values in select are related to its Cells and this argument is mandatory. In the case of Society , if it does not have any numeric attributes then it will use the number of agents in the Society as attribute. target : An Agent , Cell, CellularSpace, or Society. visible : A boolean value indicating whether InternetSender will create a window to display the transferred data. The default value is true. Usage cell = Cell{ value = 5 } InternetSender{ target = cell, select = \"value\", protocol = \"tcp\", compress = false }","title":"InternetSender"},{"location":"base/types/internetSender/#internetsender","text":"An Internet connection to send attribute values of an object through a TCP or UDP protocol. Every call to notify (for example, Agent:notify() ) in the target activates the InternetSender.","title":"InternetSender"},{"location":"base/types/internetSender/#arguments","text":"compress : Compress the data to be transfered? It might be interesting not to compress when the connection is on the localhost, or when there is a very fast connection, to make the simulation faster. The default value is true. host : A string with the host name to transfer the data. The default value is \"localhost\". port : A number greater or equal to 50000 indicating the port of the host to transfer the data. The default value is 456456. protocol : A string with the protocol to be used. It can be \"tcp\" (default) or \"udp\". select : A vector of strings with the name of the attributes to be observed. If it is a single value then it can also be described as a string. As default, it selects all the user-defined attributes of an object. When using a CellularSpace as subject, the values in select are related to its Cells and this argument is mandatory. In the case of Society , if it does not have any numeric attributes then it will use the number of agents in the Society as attribute. target : An Agent , Cell, CellularSpace, or Society. visible : A boolean value indicating whether InternetSender will create a window to display the transferred data. The default value is true.","title":"Arguments"},{"location":"base/types/internetSender/#usage","text":"cell = Cell{ value = 5 } InternetSender{ target = cell, select = \"value\", protocol = \"tcp\", compress = false }","title":"Usage"},{"location":"base/types/jump/","text":"Jump Control a discrete transition between States . If the method in the first argument returns true, the target becomes the new active State. Arguments 1st : a function that returns a boolean value and takes as arguments an Event , an Agent or Automaton , and a Cell , respectively. target : a string with another State id. Usage Jump{ function(ev, agent, c) return c.water > c.capInf end, target = \"wet\" }","title":"Jump"},{"location":"base/types/jump/#jump","text":"Control a discrete transition between States . If the method in the first argument returns true, the target becomes the new active State.","title":"Jump"},{"location":"base/types/jump/#arguments","text":"1st : a function that returns a boolean value and takes as arguments an Event , an Agent or Automaton , and a Cell , respectively. target : a string with another State id.","title":"Arguments"},{"location":"base/types/jump/#usage","text":"Jump{ function(ev, agent, c) return c.water > c.capInf end, target = \"wet\" }","title":"Usage"},{"location":"base/types/log/","text":"Log A log file to save attributes of an object. The saved file uses the csv standard: The first line contains the attribute names and the following lines contains values according to the calls to notify(). Arguments file : A string with the file name to be saved. The default value is \"result.csv\". overwrite : A boolean value indicating whether the file should be overwritten. The default value is true. select : A vector of strings with the name of the attributes to be observed. If it is only a single value then it can also be described as a string. As default, it selects all the user-defined attributes of an object. In the case of Society , if it does not have any numeric attributes then it will use the number of agents in the Society as attribute. separator : A string with the separator. The default value is \",\". target : An Agent , Cell , CellularSpace , Society. Usage agent = Agent{ age = 3 } Log{ target = agent, file = \"agent.csv\", separator = \";\" } Functions update Update the Log with the latest values of its target. update Update the Log with the latest values of its target. It is usually recommended to use the Log as action of an Event instead of calling this function explicitly. Usage agent = Agent{ age = 3 } log = Log{ target = agent, file = \"agent.csv\", separator = \";\" } log:update() File(\"agent.csv\"):delete()","title":"Log"},{"location":"base/types/log/#log","text":"A log file to save attributes of an object. The saved file uses the csv standard: The first line contains the attribute names and the following lines contains values according to the calls to notify().","title":"Log"},{"location":"base/types/log/#arguments","text":"file : A string with the file name to be saved. The default value is \"result.csv\". overwrite : A boolean value indicating whether the file should be overwritten. The default value is true. select : A vector of strings with the name of the attributes to be observed. If it is only a single value then it can also be described as a string. As default, it selects all the user-defined attributes of an object. In the case of Society , if it does not have any numeric attributes then it will use the number of agents in the Society as attribute. separator : A string with the separator. The default value is \",\". target : An Agent , Cell , CellularSpace , Society.","title":"Arguments"},{"location":"base/types/log/#usage","text":"agent = Agent{ age = 3 } Log{ target = agent, file = \"agent.csv\", separator = \";\" }","title":"Usage"},{"location":"base/types/log/#functions","text":"update Update the Log with the latest values of its target.","title":"Functions"},{"location":"base/types/log/#update","text":"Update the Log with the latest values of its target. It is usually recommended to use the Log as action of an Event instead of calling this function explicitly.","title":"update"},{"location":"base/types/log/#usage_1","text":"agent = Agent{ age = 3 } log = Log{ target = agent, file = \"agent.csv\", separator = \";\" } log:update() File(\"agent.csv\"):delete()","title":"Usage"},{"location":"base/types/mandatory/","text":"Mandatory Type to define a mandatory argument for a given Model . Arguments #1 : A string with the type of the argument. It cannot be boolean, string, nor userdata. Note that Mandatory does not get named arguments as the other TerraME types. Attributes Some attributes of Mandatory have internal semantics. They can be used as read-only by the modeler. value : The required type. Usage Mandatory(\"number\")","title":"Mandatory"},{"location":"base/types/mandatory/#mandatory","text":"Type to define a mandatory argument for a given Model .","title":"Mandatory"},{"location":"base/types/mandatory/#arguments","text":"#1 : A string with the type of the argument. It cannot be boolean, string, nor userdata. Note that Mandatory does not get named arguments as the other TerraME types.","title":"Arguments"},{"location":"base/types/mandatory/#attributes","text":"Some attributes of Mandatory have internal semantics. They can be used as read-only by the modeler. value : The required type.","title":"Attributes"},{"location":"base/types/mandatory/#usage","text":"Mandatory(\"number\")","title":"Usage"},{"location":"base/types/map/","text":"Map Create a map with the spatial distribution of a given CellularSpace , Agent , or Society . It draws each element into the screen, according a given attribute. Each notify() draws the Map again in the screen. Arguments background : A Map that can be used as background to plot a Society. It can also be a string with a color to be used as background. color : A table with the colors for the attributes. Colors can be described as strings (\"red\", \"green\", \"blue\", \"white\", \"black\", \"yellow\", \"brown\", \"cyan\", \"gray\", \"magenta\", \"orange\", \"purple\", and their light and dark compositions, such as \"lightGray\" and \"darkGray\"), as tables with three integer numbers representing RGB compositions, such as {0, 0, 0}, or even as a string with a ColorBrewer format (see http://colorbrewer2.org/ ). The colors available and the maximum number of slices for each of them are: Name Max Accent, Dark, Pastel2, Set2 8 Pastel1, Set1 9 BrBG, PRGn, RdYlGn, Spectral 11 PiYG, PuOr, RdBu, RdGy, RdYlBu 11 Paired, Set3 12 Blues, BuGn, BuPu, GnBu, Greens, Greys, Oranges, OrRd, PuBu, PuBuGn, PuRd, Purples, RdPu, Reds, YlGn, YlGnBu, YlOrBr, YlOrRd 20 font : A string with a font name to draw Agents. grid : Draw a grid around the Cells ? The default value is false. grouping : A string with the strategy to slice and color the data. See below. Grouping Description Compulsory arguments Optional arguments \"equalsteps\" The values are divided into a set of slices with the same range. Each slice is associated to a given color. Equalsteps require only two colors in the argument color, one for the minimum and the other for the maximum value. The other colors are computed from a linear interpolation of the two colors. color, max, min, select, slices, target grid, invert, precision, title \"placement\" Observe a CellularSpace showing the number of Agents in each Cell. Values can be grouped in the same way of uniquevalue or equalsteps. color, target grid, max, min, slices, title, value \"quantil\" Aggregate the values into slices with approximately the same size. Values are ordered from lower to higher and then sliced. This strategy uses two colors in the same way of equalsteps. color, max, min, select, slices, target grid, invert, precision, title \"stdeviation\" Define slices according to the distribution of a given attribute. Values with similar positive or negative distances to the average will belong to the same slice. color, select, stdColor, target grid, precision, stdDeviation, title \"uniquevalue\" Associate each attribute value to a given color. Attributes with type string can only be sliced with this strategy. It can be used for CellularSpaces as well as for Society. color, select, target, value background, font, grid, label, size, symbol, title \"none\" Does not execute any color slicing. It can be used for CellularSpaces as well as for Society. background, color, font, grid, size, symbol, target, title invert : Invert the order of the colors when using ColorBrewer. The default value is false. label : A table with the labels for the attributes. max : The maximum value of the attribute (used only for numbers). min : The minimum value of the attribute (used only for numbers). precision : The number of decimal digits for slicing. It must be an integer number greater than zero. It indicates that differences less than 10^(-digits) will not be considered. It means that, for instance, if a slice is in the interval [1.0, 2.0] and precision is 2 (0.01), a value 0.99 might belong to such slice. select : A string with the name of the attribute to be visualized. size : The size of the font to be used to draw agents in space. slices : Number of colors to be used for plotting. It must be an integer number greater than one. stdColor : A table just as argument color. It is needed only when standard deviation is the chosen strategy. stdDeviation : When the grouping mode is stddeviation, it has to be one of \"full\", \"half\" \"quarter\", or \"none\". symbol : A string to be used to draw Agents in space. They can be any string, but there are some predefined symbols available. See the link Font in the left menu. target : A CellularSpace, Agent, or Society. title : A title for the Map to be shown on the top of the screen. Whenever the argument select is used, it is the default value for title. value : A table with the possible values for the selected attributes. Usage cell = Cell{ temperature = Random{min = 0, max = 50}, seggregation = Random{0, 1, 2}, forest = Random{min = 0, max = 1} } cs = CellularSpace{ xdim = 10, instance = cell } Map{ target = cs, select = \"temperature\", min = 0, max = 50, slices = 10, color = {\"blue\", \"red\"} } Map{ target = cs, select = \"seggregation\", value = {0, 1, 2}, color = {\"blue\", \"green\", \"red\"}, label = {\"low\", \"medium\", \"high\"} } Map{ target = cs, select = \"forest\", color = \"RdYlGn\", min = 0, max = 1, slices = 10 } -- Visualizing the result of a functiont.md cell = Cell{ cover = function(cell) if Random():number() > 0.2 then return \"pasture\" else return \"soil\" end end } cs = CellularSpace{ xdim = 30, instance = cell } Map{ target = cs, select = \"cover\", value = {\"soil\", \"pasture\"}, color = {\"brown\", \"green\"} } -- Visualizing the agents of a Society soc = Society{ instance = Agent{}, quantity = 20 } cs = CellularSpace{ xdim = 10 } e = Environment{ cs, soc } e:createPlacement{} m = Map{ target = soc, symbol = \"smile\", color = \"yellow\", background = \"darkGreen\", grid = true, size = 25 } Functions save Save a Map into a file. update Update the Map with the latest values of its target. save Save a Map into a file. Supported extensions are bmp, jpg, png, and tiff. Arguments #1 : A string with the file name. Usage cs = CellularSpace{ xdim = 10 } map = Map{ target = cs, select = \"x\", min = 0, max = 10, slices = 4, color = \"Blues\" } map:save(\"file.bmp\") File(\"file.bmp\"):delete() update Update the Map with the latest values of its target. It is usually recommended to use the Map as action of an Event instead of calling this function explicitly. Arguments #1 : An optional argument that can be a number with the current time or an Event. Usage cs = CellularSpace{ xdim = 10 } map = Map{ target = cs, select = \"x\", min = 0, max = 10, slices = 4, color = \"Blues\" } map:update()","title":"Map"},{"location":"base/types/map/#map","text":"Create a map with the spatial distribution of a given CellularSpace , Agent , or Society . It draws each element into the screen, according a given attribute. Each notify() draws the Map again in the screen.","title":"Map"},{"location":"base/types/map/#arguments","text":"background : A Map that can be used as background to plot a Society. It can also be a string with a color to be used as background. color : A table with the colors for the attributes. Colors can be described as strings (\"red\", \"green\", \"blue\", \"white\", \"black\", \"yellow\", \"brown\", \"cyan\", \"gray\", \"magenta\", \"orange\", \"purple\", and their light and dark compositions, such as \"lightGray\" and \"darkGray\"), as tables with three integer numbers representing RGB compositions, such as {0, 0, 0}, or even as a string with a ColorBrewer format (see http://colorbrewer2.org/ ). The colors available and the maximum number of slices for each of them are: Name Max Accent, Dark, Pastel2, Set2 8 Pastel1, Set1 9 BrBG, PRGn, RdYlGn, Spectral 11 PiYG, PuOr, RdBu, RdGy, RdYlBu 11 Paired, Set3 12 Blues, BuGn, BuPu, GnBu, Greens, Greys, Oranges, OrRd, PuBu, PuBuGn, PuRd, Purples, RdPu, Reds, YlGn, YlGnBu, YlOrBr, YlOrRd 20 font : A string with a font name to draw Agents. grid : Draw a grid around the Cells ? The default value is false. grouping : A string with the strategy to slice and color the data. See below. Grouping Description Compulsory arguments Optional arguments \"equalsteps\" The values are divided into a set of slices with the same range. Each slice is associated to a given color. Equalsteps require only two colors in the argument color, one for the minimum and the other for the maximum value. The other colors are computed from a linear interpolation of the two colors. color, max, min, select, slices, target grid, invert, precision, title \"placement\" Observe a CellularSpace showing the number of Agents in each Cell. Values can be grouped in the same way of uniquevalue or equalsteps. color, target grid, max, min, slices, title, value \"quantil\" Aggregate the values into slices with approximately the same size. Values are ordered from lower to higher and then sliced. This strategy uses two colors in the same way of equalsteps. color, max, min, select, slices, target grid, invert, precision, title \"stdeviation\" Define slices according to the distribution of a given attribute. Values with similar positive or negative distances to the average will belong to the same slice. color, select, stdColor, target grid, precision, stdDeviation, title \"uniquevalue\" Associate each attribute value to a given color. Attributes with type string can only be sliced with this strategy. It can be used for CellularSpaces as well as for Society. color, select, target, value background, font, grid, label, size, symbol, title \"none\" Does not execute any color slicing. It can be used for CellularSpaces as well as for Society. background, color, font, grid, size, symbol, target, title invert : Invert the order of the colors when using ColorBrewer. The default value is false. label : A table with the labels for the attributes. max : The maximum value of the attribute (used only for numbers). min : The minimum value of the attribute (used only for numbers). precision : The number of decimal digits for slicing. It must be an integer number greater than zero. It indicates that differences less than 10^(-digits) will not be considered. It means that, for instance, if a slice is in the interval [1.0, 2.0] and precision is 2 (0.01), a value 0.99 might belong to such slice. select : A string with the name of the attribute to be visualized. size : The size of the font to be used to draw agents in space. slices : Number of colors to be used for plotting. It must be an integer number greater than one. stdColor : A table just as argument color. It is needed only when standard deviation is the chosen strategy. stdDeviation : When the grouping mode is stddeviation, it has to be one of \"full\", \"half\" \"quarter\", or \"none\". symbol : A string to be used to draw Agents in space. They can be any string, but there are some predefined symbols available. See the link Font in the left menu. target : A CellularSpace, Agent, or Society. title : A title for the Map to be shown on the top of the screen. Whenever the argument select is used, it is the default value for title. value : A table with the possible values for the selected attributes.","title":"Arguments"},{"location":"base/types/map/#usage","text":"cell = Cell{ temperature = Random{min = 0, max = 50}, seggregation = Random{0, 1, 2}, forest = Random{min = 0, max = 1} } cs = CellularSpace{ xdim = 10, instance = cell } Map{ target = cs, select = \"temperature\", min = 0, max = 50, slices = 10, color = {\"blue\", \"red\"} } Map{ target = cs, select = \"seggregation\", value = {0, 1, 2}, color = {\"blue\", \"green\", \"red\"}, label = {\"low\", \"medium\", \"high\"} } Map{ target = cs, select = \"forest\", color = \"RdYlGn\", min = 0, max = 1, slices = 10 } -- Visualizing the result of a functiont.md cell = Cell{ cover = function(cell) if Random():number() > 0.2 then return \"pasture\" else return \"soil\" end end } cs = CellularSpace{ xdim = 30, instance = cell } Map{ target = cs, select = \"cover\", value = {\"soil\", \"pasture\"}, color = {\"brown\", \"green\"} } -- Visualizing the agents of a Society soc = Society{ instance = Agent{}, quantity = 20 } cs = CellularSpace{ xdim = 10 } e = Environment{ cs, soc } e:createPlacement{} m = Map{ target = soc, symbol = \"smile\", color = \"yellow\", background = \"darkGreen\", grid = true, size = 25 }","title":"Usage"},{"location":"base/types/map/#functions","text":"save Save a Map into a file. update Update the Map with the latest values of its target.","title":"Functions"},{"location":"base/types/map/#save","text":"Save a Map into a file. Supported extensions are bmp, jpg, png, and tiff.","title":"save"},{"location":"base/types/map/#arguments_1","text":"#1 : A string with the file name.","title":"Arguments"},{"location":"base/types/map/#usage_1","text":"cs = CellularSpace{ xdim = 10 } map = Map{ target = cs, select = \"x\", min = 0, max = 10, slices = 4, color = \"Blues\" } map:save(\"file.bmp\") File(\"file.bmp\"):delete()","title":"Usage"},{"location":"base/types/map/#update","text":"Update the Map with the latest values of its target. It is usually recommended to use the Map as action of an Event instead of calling this function explicitly.","title":"update"},{"location":"base/types/map/#arguments_2","text":"#1 : An optional argument that can be a number with the current time or an Event.","title":"Arguments"},{"location":"base/types/map/#usage_2","text":"cs = CellularSpace{ xdim = 10 } map = Map{ target = cs, select = \"x\", min = 0, max = 10, slices = 4, color = \"Blues\" } map:update()","title":"Usage"},{"location":"base/types/model/","text":"Model Type that defines a model. The user can use Model to describe the arguments of a model and how it can be built. The returning value of a Model is an object that can be used directly to simulate (as long as it does not have any Mandatory parameter) or used to create as many instances as needed to simulate the Model with different parameters. A tutorial about Models in TerraME is available at http://github.com/pedro-andrade-inpe/terrame/wiki/Models. Arguments execute : An optional function to define the changes of the Model in each time step. it the Model does not have a Timer after init() but it has this function, a Timer will be automatically created and will add an Event with the Model as its action. finalTime : A number with the final time of the simulation. If the Model does not have this as argument, it must be defined within function init() . init : A mandatory function to describe how an instance of Model is created. interface. : An optional function to describe how the graphical interface is displayed. See interface() . See init() . If the Model does not have argument finalTime, this function should create the attribute finalTime to allow the Model instance to be run. random : An optional boolean value indicating that the model uses random numbers. The default value is false. ... : Arguments of the Model. The values of each argument have an associated semantic. See the table below: Attribute type Description Default value number or bool The instance has to belong to such type. The value itself. string The instance has to be a string. If it is in the format \" .a; .b;...\", it describes a file extension. The modeler then has to use a filename as argument with one of the extensions defined by this string. The value itself. Choice The instance must have a value that belongs to the Choice. The default value of the Choice. Mandatory A mandatory argument, which means that the use must use a value witht the type defined in the Mandatory to build the model instance correctly. If Mandatory is \"table\", then the model instance must have all its elements belonging to the same type. No default value. named table It will verify each attribute according to the rules above. The table itself. It is possible to define only part of the table in the instance, keeping the other default values. Attributes Some attributes of Model have internal semantics. They can be used as read-only by the modeler. parent : The Model used to create the object. This object only exists in the Model instance, but not in the Model itself. Usage Tube = Model{ initialWater = 20, flow = 1, finalTime = 20, init = function(model) model.water = model.initialWater model.chart = Chart{target = model, select = \"water\"} model:notify() model.timer = Timer{ Event{action = function() model.water = model.water - model.flow end}, Event{action = model.chart} } end } print(type(Tube)) -- \"Model\" Tube:run() -- One can run a Model directly... MyTube = Tube{initialWater = 50} -- ... or create instances using it print(type(MyTube)) -- \"Tube\" print(MyTube:title()) -- \"Initial Water = 50\" MyTube:run() pcall(function() MyTube2 = Tube{initialwater = 100} end) -- Warning: Argument 'initialwater' is unnecessary. Do you mean 'initialWater'? -- (when executing TerraME with mode=strict) _, err = pcall(function() MyTube2 = Tube{flow = false} end) print(err) -- Error: Incompatible types. Argument 'flow' expected number, got boolean. Functions configure Function to show a graphical interface to configure the parameters of a given Model. execute User-defined function to execute the Model in a given time step. getParameters Return the parameters of the Model as they were defined. init User-defined function to create the objects of the Model. interface User-defined function to define the distribution of components in the graphical interface. isRandom Return if a Model uses random numbers. notify Notify the Observers of the Model instance. run Run the Model instance. title Return a title for the Model instance according to its parameters. configure Function to show a graphical interface to configure the parameters of a given Model. This function can be used in scripts that implement a Model. If the Model belongs to a package, then it should not be called, as TerraME will do it automatically when one selects the Model to be configured. Usage Tube = Model{ initialWater = 20, flow = 1, finalTime = 20, execute = function(model) model.water = model.water - model.flow end, init = function(model) model.water = model.initialWater model.chart = Chart{target = model, select = \"water\"} model.timer = Timer{ Event{action = model}, Event{action = model.chart} } end } Tube:configure() execute User-defined function to execute the Model in a given time step. It is useful when using the Model as an action for a given Event . Usage Tube = Model{ water = 20, flow = 1, finalTime = 20, execute = function(model) model.water = model.water - model.flow end, init = function (model) model.chart = Chart{ target = model, select = \"water\" } end } getParameters Return the parameters of the Model as they were defined. The result must not be changed, otherwise it might affect the Model itself. Usage model = Model{ par1 = 3, par2 = Choice{\"low\", \"medium\", \"high\"}, par3 = {min = 3, max = 5}, finalTime = 20, init = function(model) model.timer = Timer{ Event{action = function() -- ... end} } end } params = model:getParameters() print(params.par1) print(type(params.par2)) print(params.init) -- nil init User-defined function to create the objects of the Model. It is recommended that all the created objects should be placed in the model instance itself, to guarantee the content of the Model into a single object. It is also possible to verify whether the model has correct arguments. The internal verification of Model ensures that the type of the arguments is valid, acording to the definition of the Model. See toLabel() , for using names of arguments in error messages when building a Model to work with graphical interfaces. This function is executed automatically when one instantiates a given Model. Usage Tube = Model{ initialWater = 200, flow = 20, init = function(model) verify(model.flow < model.initialWater, toLabel(\"flow\")..\" should be less than \"..toLabel(\"initialWater\")..\".\") model.finalTime = 10 model.timer = Timer{ Event{action = function() -- ... end} } end } m = Tube{initialWater = 100, flow = 10} print(m.finalTime) -- 10 See also customError (ErrorHandling) verify (ErrorHandling) interface User-defined function to define the distribution of components in the graphical interface. If this function is not implemented in the Model, the components will be distributed automatically. This function should return a table with tables composed by strings. Each position of the table describes a column of components in the interface. In the example below, the first column of the graphical interface will show the string argument in the top (\"mapFile\") and the three arguments of \"agents\" in the bottom of the first column. The second column will contain the arguments of \"block\" in the top and the boolean argument (\"showGraphics\") in the bottom. The elements that do not belong to the table will not be shown in the graphical interface (in the example, \"season\"). Note that all Compulsory arguments must belong to the graphical interface to allow instantiate Model instances properly. Usage Sugarscape = Model{ mapFile = \"sugar-map.csv\", showGraphics = true, agents = { quantity = 10, wealth = Choice{min = 5, max = 25}, metabolism = Choice{min = 1, max = 4} }, block = { xmin = 0, xmax = math.huge, ymin = 0, ymax = math.huge }, season = { summerGrowthRate = 1, winterGrowthRate = 0.125 }, interface = function() return { {\"string\", \"agents\"}, {\"block\", \"boolean\"} } end, init = function(model) model.timer = Timer{ Event{action = function() end} } end } Sugarscape:configure() isRandom Return if a Model uses random numbers. This can be configured with the argument random while creating a Model. Usage RandomModel = Model{ random = true, finalTime = 10, init = function(model) model.timer = Timer{ Event{action = function() print(Random():number()) end} } end } print(RandomModel:isRandom()) notify Notify the Observers of the Model instance. Arguments #1 : A number representing the notification time. The default value is zero. It is also possible to use an Event as argument. In this case, it will use the result of Event:getTime() . Usage Tube = Model{ water = 200, init = function(model) model.finalTime = 100 Chart{ target = model, select = \"water\" } model.timer = Timer{ Event{action = function(ev) model.water = model.water - 1 model:notify(ev) end} } end } scenario1 = Tube{water = 100} scenario1:run() run Run the Model instance. It requires that the Model instance has attribute finalTime. Usage Tube = Model{ initialWater = 200, flow = 20, init = function(model) model.finalTime = 10 model.timer = Timer{ Event{action = function() -- ... end} } end } m = Tube{initialWater = 100, flow = 10} m:run() title Return a title for the Model instance according to its parameters. It uses only the parameters that are different from the default values. If the Model was instantiated without any parameter, its title will be \"default\". Usage Tube = Model{ water = 200, init = function(model) model.finalTime = 100 Chart{ target = model, select = \"water\" } model.timer = Timer{ Event{action = function(ev) model.water = model.water - 1 model:notify(ev) end} } end } scenario1 = Tube{water = 100} print(scenario1:title()) -- \"water = 100\"","title":"Model"},{"location":"base/types/model/#model","text":"Type that defines a model. The user can use Model to describe the arguments of a model and how it can be built. The returning value of a Model is an object that can be used directly to simulate (as long as it does not have any Mandatory parameter) or used to create as many instances as needed to simulate the Model with different parameters. A tutorial about Models in TerraME is available at http://github.com/pedro-andrade-inpe/terrame/wiki/Models.","title":"Model"},{"location":"base/types/model/#arguments","text":"execute : An optional function to define the changes of the Model in each time step. it the Model does not have a Timer after init() but it has this function, a Timer will be automatically created and will add an Event with the Model as its action. finalTime : A number with the final time of the simulation. If the Model does not have this as argument, it must be defined within function init() . init : A mandatory function to describe how an instance of Model is created. interface. : An optional function to describe how the graphical interface is displayed. See interface() . See init() . If the Model does not have argument finalTime, this function should create the attribute finalTime to allow the Model instance to be run. random : An optional boolean value indicating that the model uses random numbers. The default value is false. ... : Arguments of the Model. The values of each argument have an associated semantic. See the table below: Attribute type Description Default value number or bool The instance has to belong to such type. The value itself. string The instance has to be a string. If it is in the format \" .a; .b;...\", it describes a file extension. The modeler then has to use a filename as argument with one of the extensions defined by this string. The value itself. Choice The instance must have a value that belongs to the Choice. The default value of the Choice. Mandatory A mandatory argument, which means that the use must use a value witht the type defined in the Mandatory to build the model instance correctly. If Mandatory is \"table\", then the model instance must have all its elements belonging to the same type. No default value. named table It will verify each attribute according to the rules above. The table itself. It is possible to define only part of the table in the instance, keeping the other default values.","title":"Arguments"},{"location":"base/types/model/#attributes","text":"Some attributes of Model have internal semantics. They can be used as read-only by the modeler. parent : The Model used to create the object. This object only exists in the Model instance, but not in the Model itself.","title":"Attributes"},{"location":"base/types/model/#usage","text":"Tube = Model{ initialWater = 20, flow = 1, finalTime = 20, init = function(model) model.water = model.initialWater model.chart = Chart{target = model, select = \"water\"} model:notify() model.timer = Timer{ Event{action = function() model.water = model.water - model.flow end}, Event{action = model.chart} } end } print(type(Tube)) -- \"Model\" Tube:run() -- One can run a Model directly... MyTube = Tube{initialWater = 50} -- ... or create instances using it print(type(MyTube)) -- \"Tube\" print(MyTube:title()) -- \"Initial Water = 50\" MyTube:run() pcall(function() MyTube2 = Tube{initialwater = 100} end) -- Warning: Argument 'initialwater' is unnecessary. Do you mean 'initialWater'? -- (when executing TerraME with mode=strict) _, err = pcall(function() MyTube2 = Tube{flow = false} end) print(err) -- Error: Incompatible types. Argument 'flow' expected number, got boolean.","title":"Usage"},{"location":"base/types/model/#functions","text":"configure Function to show a graphical interface to configure the parameters of a given Model. execute User-defined function to execute the Model in a given time step. getParameters Return the parameters of the Model as they were defined. init User-defined function to create the objects of the Model. interface User-defined function to define the distribution of components in the graphical interface. isRandom Return if a Model uses random numbers. notify Notify the Observers of the Model instance. run Run the Model instance. title Return a title for the Model instance according to its parameters.","title":"Functions"},{"location":"base/types/model/#configure","text":"Function to show a graphical interface to configure the parameters of a given Model. This function can be used in scripts that implement a Model. If the Model belongs to a package, then it should not be called, as TerraME will do it automatically when one selects the Model to be configured.","title":"configure"},{"location":"base/types/model/#usage_1","text":"Tube = Model{ initialWater = 20, flow = 1, finalTime = 20, execute = function(model) model.water = model.water - model.flow end, init = function(model) model.water = model.initialWater model.chart = Chart{target = model, select = \"water\"} model.timer = Timer{ Event{action = model}, Event{action = model.chart} } end } Tube:configure()","title":"Usage"},{"location":"base/types/model/#execute","text":"User-defined function to execute the Model in a given time step. It is useful when using the Model as an action for a given Event .","title":"execute"},{"location":"base/types/model/#usage_2","text":"Tube = Model{ water = 20, flow = 1, finalTime = 20, execute = function(model) model.water = model.water - model.flow end, init = function (model) model.chart = Chart{ target = model, select = \"water\" } end }","title":"Usage"},{"location":"base/types/model/#getparameters","text":"Return the parameters of the Model as they were defined. The result must not be changed, otherwise it might affect the Model itself.","title":"getParameters"},{"location":"base/types/model/#usage_3","text":"model = Model{ par1 = 3, par2 = Choice{\"low\", \"medium\", \"high\"}, par3 = {min = 3, max = 5}, finalTime = 20, init = function(model) model.timer = Timer{ Event{action = function() -- ... end} } end } params = model:getParameters() print(params.par1) print(type(params.par2)) print(params.init) -- nil","title":"Usage"},{"location":"base/types/model/#init","text":"User-defined function to create the objects of the Model. It is recommended that all the created objects should be placed in the model instance itself, to guarantee the content of the Model into a single object. It is also possible to verify whether the model has correct arguments. The internal verification of Model ensures that the type of the arguments is valid, acording to the definition of the Model. See toLabel() , for using names of arguments in error messages when building a Model to work with graphical interfaces. This function is executed automatically when one instantiates a given Model.","title":"init"},{"location":"base/types/model/#usage_4","text":"Tube = Model{ initialWater = 200, flow = 20, init = function(model) verify(model.flow < model.initialWater, toLabel(\"flow\")..\" should be less than \"..toLabel(\"initialWater\")..\".\") model.finalTime = 10 model.timer = Timer{ Event{action = function() -- ... end} } end } m = Tube{initialWater = 100, flow = 10} print(m.finalTime) -- 10","title":"Usage"},{"location":"base/types/model/#see-also","text":"customError (ErrorHandling) verify (ErrorHandling)","title":"See also"},{"location":"base/types/model/#interface","text":"User-defined function to define the distribution of components in the graphical interface. If this function is not implemented in the Model, the components will be distributed automatically. This function should return a table with tables composed by strings. Each position of the table describes a column of components in the interface. In the example below, the first column of the graphical interface will show the string argument in the top (\"mapFile\") and the three arguments of \"agents\" in the bottom of the first column. The second column will contain the arguments of \"block\" in the top and the boolean argument (\"showGraphics\") in the bottom. The elements that do not belong to the table will not be shown in the graphical interface (in the example, \"season\"). Note that all Compulsory arguments must belong to the graphical interface to allow instantiate Model instances properly.","title":"interface"},{"location":"base/types/model/#usage_5","text":"Sugarscape = Model{ mapFile = \"sugar-map.csv\", showGraphics = true, agents = { quantity = 10, wealth = Choice{min = 5, max = 25}, metabolism = Choice{min = 1, max = 4} }, block = { xmin = 0, xmax = math.huge, ymin = 0, ymax = math.huge }, season = { summerGrowthRate = 1, winterGrowthRate = 0.125 }, interface = function() return { {\"string\", \"agents\"}, {\"block\", \"boolean\"} } end, init = function(model) model.timer = Timer{ Event{action = function() end} } end } Sugarscape:configure()","title":"Usage"},{"location":"base/types/model/#israndom","text":"Return if a Model uses random numbers. This can be configured with the argument random while creating a Model.","title":"isRandom"},{"location":"base/types/model/#usage_6","text":"RandomModel = Model{ random = true, finalTime = 10, init = function(model) model.timer = Timer{ Event{action = function() print(Random():number()) end} } end } print(RandomModel:isRandom())","title":"Usage"},{"location":"base/types/model/#notify","text":"Notify the Observers of the Model instance.","title":"notify"},{"location":"base/types/model/#arguments_1","text":"#1 : A number representing the notification time. The default value is zero. It is also possible to use an Event as argument. In this case, it will use the result of Event:getTime() .","title":"Arguments"},{"location":"base/types/model/#usage_7","text":"Tube = Model{ water = 200, init = function(model) model.finalTime = 100 Chart{ target = model, select = \"water\" } model.timer = Timer{ Event{action = function(ev) model.water = model.water - 1 model:notify(ev) end} } end } scenario1 = Tube{water = 100} scenario1:run()","title":"Usage"},{"location":"base/types/model/#run","text":"Run the Model instance. It requires that the Model instance has attribute finalTime.","title":"run"},{"location":"base/types/model/#usage_8","text":"Tube = Model{ initialWater = 200, flow = 20, init = function(model) model.finalTime = 10 model.timer = Timer{ Event{action = function() -- ... end} } end } m = Tube{initialWater = 100, flow = 10} m:run()","title":"Usage"},{"location":"base/types/model/#title","text":"Return a title for the Model instance according to its parameters. It uses only the parameters that are different from the default values. If the Model was instantiated without any parameter, its title will be \"default\".","title":"title"},{"location":"base/types/model/#usage_9","text":"Tube = Model{ water = 200, init = function(model) model.finalTime = 100 Chart{ target = model, select = \"water\" } model.timer = Timer{ Event{action = function(ev) model.water = model.water - 1 model:notify(ev) end} } end } scenario1 = Tube{water = 100} print(scenario1:title()) -- \"water = 100\"","title":"Usage"},{"location":"base/types/neighborhood/","text":"Neighborhood A Neighborhood is a set of pairs (cell, weight), where cell is a neighbor Cell and weight is a number storing the relation's strength. Each Cell can have one or more Neighborhoods to represent its proximity relations. This type is used to create Neighborhoods from scratch to be used by Cell:addNeighborhood() . To create well-established Neighborhoods see CellularSpace:createNeighborhood() . Neighborhoods can also be loaded from external soures using CellularSpace:loadNeighborhood() . It is recommended that a Neighborhood should contain only Cells that belong to the same CellularSpace , as it guarantees that all its Cells have unique identifiers. Calling forEachNeighbor() from a Cell traverses one of its Neighborhoods. Usage n = Neighborhood() n = Neighborhood{} Functions add Add a new Cell to the Neighborhood. clear Remove all Cells from the Neighborhood. getWeight Return the weight of the connection to a given neighbor Cell . isEmpty Return whether the Neighborhood does not contain any Cell . isNeighbor Return whether a given Cell belongs to the Neighborhood. remove Remove a Cell from the Neighborhood. sample Return a random Cell from the Neighborhood. setWeight Update a weight of the connection to a given neighbor Cell . # Return the number of Cells in the Neighborhood. add Add a new Cell to the Neighborhood. If the Neighborhood already contains such Cell then it will stop with an error. Arguments #1 : A Cell to be added. #2 : A number representing the weight of the connection. The default value is 1. Usage n = Neighborhood() c = Cell{} n:add(c, 0.02) clear Remove all Cells from the Neighborhood. In practice, it has the same behavior as calling Neighborhood() again if the Neighborhood was not added to any Cell. Usage n = Neighborhood() n:clear() getWeight Return the weight of the connection to a given neighbor Cell . It returns nil when the Cell is not a neighbor. Arguments #1 : A Cell. Usage c = Cell{} n = Neighborhood() n:add(c, 0.5) print(n:getWeight(c)) isEmpty Return whether the Neighborhood does not contain any Cell . Usage n = Neighborhood() if n:isEmpty() then print(\"is empty\") end isNeighbor Return whether a given Cell belongs to the Neighborhood. Arguments #1 : A Cell. Usage n = Neighborhood() c = Cell{} n:add(c) if n:isNeighbor(c) then print(\"is neighbor\") end remove Remove a Cell from the Neighborhood. Arguments #1 : The Cell that is going to be removed. Usage c1 = Cell{id = \"1\"} c2 = Cell{id = \"2\"} n = Neighborhood() n:add(c1) n:add(c2) print(#n) n:remove(c1) print(#n) sample Return a random Cell from the Neighborhood. Usage c1 = Cell{id = \"1\"} c2 = Cell{id = \"2\"} n = Neighborhood() n:add(c1) n:add(c2) cell = n:sample() print(type(cell)) setWeight Update a weight of the connection to a given neighbor Cell . Arguments #1 : A Cell. #2 : A number with the new weight. Usage c = Cell{} n = Neighborhood() n:add(c, 0.5) print(n:getWeight(c)) n:setWeight(c, 0.01) print(n:getWeight(c)) # Return the number of Cells in the Neighborhood. Usage n = Neighborhood() print(#n)","title":"Neighborhood"},{"location":"base/types/neighborhood/#neighborhood","text":"A Neighborhood is a set of pairs (cell, weight), where cell is a neighbor Cell and weight is a number storing the relation's strength. Each Cell can have one or more Neighborhoods to represent its proximity relations. This type is used to create Neighborhoods from scratch to be used by Cell:addNeighborhood() . To create well-established Neighborhoods see CellularSpace:createNeighborhood() . Neighborhoods can also be loaded from external soures using CellularSpace:loadNeighborhood() . It is recommended that a Neighborhood should contain only Cells that belong to the same CellularSpace , as it guarantees that all its Cells have unique identifiers. Calling forEachNeighbor() from a Cell traverses one of its Neighborhoods.","title":"Neighborhood"},{"location":"base/types/neighborhood/#usage","text":"n = Neighborhood() n = Neighborhood{}","title":"Usage"},{"location":"base/types/neighborhood/#functions","text":"add Add a new Cell to the Neighborhood. clear Remove all Cells from the Neighborhood. getWeight Return the weight of the connection to a given neighbor Cell . isEmpty Return whether the Neighborhood does not contain any Cell . isNeighbor Return whether a given Cell belongs to the Neighborhood. remove Remove a Cell from the Neighborhood. sample Return a random Cell from the Neighborhood. setWeight Update a weight of the connection to a given neighbor Cell . # Return the number of Cells in the Neighborhood.","title":"Functions"},{"location":"base/types/neighborhood/#add","text":"Add a new Cell to the Neighborhood. If the Neighborhood already contains such Cell then it will stop with an error.","title":"add"},{"location":"base/types/neighborhood/#arguments","text":"#1 : A Cell to be added. #2 : A number representing the weight of the connection. The default value is 1.","title":"Arguments"},{"location":"base/types/neighborhood/#usage_1","text":"n = Neighborhood() c = Cell{} n:add(c, 0.02)","title":"Usage"},{"location":"base/types/neighborhood/#clear","text":"Remove all Cells from the Neighborhood. In practice, it has the same behavior as calling Neighborhood() again if the Neighborhood was not added to any Cell.","title":"clear"},{"location":"base/types/neighborhood/#usage_2","text":"n = Neighborhood() n:clear()","title":"Usage"},{"location":"base/types/neighborhood/#getweight","text":"Return the weight of the connection to a given neighbor Cell . It returns nil when the Cell is not a neighbor.","title":"getWeight"},{"location":"base/types/neighborhood/#arguments_1","text":"#1 : A Cell.","title":"Arguments"},{"location":"base/types/neighborhood/#usage_3","text":"c = Cell{} n = Neighborhood() n:add(c, 0.5) print(n:getWeight(c))","title":"Usage"},{"location":"base/types/neighborhood/#isempty","text":"Return whether the Neighborhood does not contain any Cell .","title":"isEmpty"},{"location":"base/types/neighborhood/#usage_4","text":"n = Neighborhood() if n:isEmpty() then print(\"is empty\") end","title":"Usage"},{"location":"base/types/neighborhood/#isneighbor","text":"Return whether a given Cell belongs to the Neighborhood.","title":"isNeighbor"},{"location":"base/types/neighborhood/#arguments_2","text":"#1 : A Cell.","title":"Arguments"},{"location":"base/types/neighborhood/#usage_5","text":"n = Neighborhood() c = Cell{} n:add(c) if n:isNeighbor(c) then print(\"is neighbor\") end","title":"Usage"},{"location":"base/types/neighborhood/#remove","text":"Remove a Cell from the Neighborhood.","title":"remove"},{"location":"base/types/neighborhood/#arguments_3","text":"#1 : The Cell that is going to be removed.","title":"Arguments"},{"location":"base/types/neighborhood/#usage_6","text":"c1 = Cell{id = \"1\"} c2 = Cell{id = \"2\"} n = Neighborhood() n:add(c1) n:add(c2) print(#n) n:remove(c1) print(#n)","title":"Usage"},{"location":"base/types/neighborhood/#sample","text":"Return a random Cell from the Neighborhood.","title":"sample"},{"location":"base/types/neighborhood/#usage_7","text":"c1 = Cell{id = \"1\"} c2 = Cell{id = \"2\"} n = Neighborhood() n:add(c1) n:add(c2) cell = n:sample() print(type(cell))","title":"Usage"},{"location":"base/types/neighborhood/#setweight","text":"Update a weight of the connection to a given neighbor Cell .","title":"setWeight"},{"location":"base/types/neighborhood/#arguments_4","text":"#1 : A Cell. #2 : A number with the new weight.","title":"Arguments"},{"location":"base/types/neighborhood/#usage_8","text":"c = Cell{} n = Neighborhood() n:add(c, 0.5) print(n:getWeight(c)) n:setWeight(c, 0.01) print(n:getWeight(c))","title":"Usage"},{"location":"base/types/neighborhood/#_1","text":"Return the number of Cells in the Neighborhood.","title":"#"},{"location":"base/types/neighborhood/#usage_9","text":"n = Neighborhood() print(#n)","title":"Usage"},{"location":"base/types/profiler/","text":"Profiler The type Profiler is used to measure the simulation/execution time of a model or the time to execute small blocks of a model. The user can inform Profiler how many times a block will execute. Thus it can estimate the time left to finish the execution of a block. This type also summaries all its measures and show a report containing how many times a block was executed, the time to execute all repetitions of this block and the average time of these repetitions. Usage Profiler():start(\"test\") Profiler():stop(\"test\") print(Profiler():uptime(\"test\")) Functions clean Clean the Profiler, removing all blocks and restarting its execution time. clock Return how much time of CPU was spent on the block up to last stop. count Return how many times a given block has started. current Return the current block. eta Estimate and return the time to execute all repetitions of a given block. report Show a report with the time and amount of times each block was executed. start Create and start a new block. steps Define how many times a given block will be executed. stop Stop to measure the time of a given block and return how much time was spent with the block since it was started. uptime Return how much time was spent on the block up to last stop. clean Clean the Profiler, removing all blocks and restarting its execution time. Usage Profiler():clean() clock Return how much time of CPU was spent on the block up to last stop. It returns two representations: a string with a human-like representation of the time and a number with the time in seconds. Arguments #1 : A string with the block name. If the name is not informed, then it returns the uptime of the current block. Usage Profiler():start(\"block\") Profiler():stop(\"block\") stringTime, numberTime = Profiler():clock(\"block\") count Return how many times a given block has started. Arguments #1 : A string with the block name. If the name is not informed, then it returns the count of the current block. Usage Profiler():start(\"block\") print(Profiler():count(\"block\")) -- 1 Profiler():stop(\"block\") current Return the current block. Usage Profiler():start(\"block\") print(Profiler():current().name) -- block Profiler():stop(\"block\") eta Estimate and return the time to execute all repetitions of a given block. It returns in two representations: a string with a human-like representation of the time and a number with the time in seconds. Arguments #1 : A string with the block name. If the name is not informed, then it returns the \"eta\" of the current block. Usage Profiler():steps(\"block\", 5) Profiler():start(\"block\") Profiler():stop(\"block\") eta_string, eta_number = Profiler():eta(\"block\") print(eta_string..\" left...\") print(eta_number..\" seconds to finish...\") report Show a report with the time and amount of times each block was executed. Usage Profiler():report() start Create and start a new block. Arguments #1 : A string with the block name. Usage Profiler():start(\"block\") Profiler():stop(\"block\") steps Define how many times a given block will be executed. Arguments #1 : A string with the block name. #2 : Number of steps a given block will execute. Usage Profiler():start(\"block\") Profiler():steps(\"block\", 5) Profiler():stop(\"block\") stop Stop to measure the time of a given block and return how much time was spent with the block since it was started. It returns a table with the spent time in seconds (time), a string with a human-like representation of the time (strTime), spent time of CPU in high precision (clock), a string with a human-like representation of the time of CPU (strClock). Arguments #1 : A string with the block name. If the name is not informed, then it stops and return the uptime of the current block. Usage Profiler():start(\"block\") timeTable = Profiler():stop(\"block\") time = timeTable.time clock = timeTable.clock strTime = timeTable.strTime strClock = timeTable.strClock uptime Return how much time was spent on the block up to last stop. It returns two representations: a string with a human-like representation of the time and a number with the time in seconds. Arguments #1 : A string with the block name. If the name is not informed, then it returns the uptime of the current block. Usage Profiler():start(\"block\") Profiler():stop(\"block\") stringTime, numberTime = Profiler():uptime(\"block\")","title":"Profiler"},{"location":"base/types/profiler/#profiler","text":"The type Profiler is used to measure the simulation/execution time of a model or the time to execute small blocks of a model. The user can inform Profiler how many times a block will execute. Thus it can estimate the time left to finish the execution of a block. This type also summaries all its measures and show a report containing how many times a block was executed, the time to execute all repetitions of this block and the average time of these repetitions.","title":"Profiler"},{"location":"base/types/profiler/#usage","text":"Profiler():start(\"test\") Profiler():stop(\"test\") print(Profiler():uptime(\"test\"))","title":"Usage"},{"location":"base/types/profiler/#functions","text":"clean Clean the Profiler, removing all blocks and restarting its execution time. clock Return how much time of CPU was spent on the block up to last stop. count Return how many times a given block has started. current Return the current block. eta Estimate and return the time to execute all repetitions of a given block. report Show a report with the time and amount of times each block was executed. start Create and start a new block. steps Define how many times a given block will be executed. stop Stop to measure the time of a given block and return how much time was spent with the block since it was started. uptime Return how much time was spent on the block up to last stop.","title":"Functions"},{"location":"base/types/profiler/#clean","text":"Clean the Profiler, removing all blocks and restarting its execution time.","title":"clean"},{"location":"base/types/profiler/#usage_1","text":"Profiler():clean()","title":"Usage"},{"location":"base/types/profiler/#clock","text":"Return how much time of CPU was spent on the block up to last stop. It returns two representations: a string with a human-like representation of the time and a number with the time in seconds.","title":"clock"},{"location":"base/types/profiler/#arguments","text":"#1 : A string with the block name. If the name is not informed, then it returns the uptime of the current block.","title":"Arguments"},{"location":"base/types/profiler/#usage_2","text":"Profiler():start(\"block\") Profiler():stop(\"block\") stringTime, numberTime = Profiler():clock(\"block\")","title":"Usage"},{"location":"base/types/profiler/#count","text":"Return how many times a given block has started.","title":"count"},{"location":"base/types/profiler/#arguments_1","text":"#1 : A string with the block name. If the name is not informed, then it returns the count of the current block.","title":"Arguments"},{"location":"base/types/profiler/#usage_3","text":"Profiler():start(\"block\") print(Profiler():count(\"block\")) -- 1 Profiler():stop(\"block\")","title":"Usage"},{"location":"base/types/profiler/#current","text":"Return the current block.","title":"current"},{"location":"base/types/profiler/#usage_4","text":"Profiler():start(\"block\") print(Profiler():current().name) -- block Profiler():stop(\"block\")","title":"Usage"},{"location":"base/types/profiler/#eta","text":"Estimate and return the time to execute all repetitions of a given block. It returns in two representations: a string with a human-like representation of the time and a number with the time in seconds.","title":"eta"},{"location":"base/types/profiler/#arguments_2","text":"#1 : A string with the block name. If the name is not informed, then it returns the \"eta\" of the current block.","title":"Arguments"},{"location":"base/types/profiler/#usage_5","text":"Profiler():steps(\"block\", 5) Profiler():start(\"block\") Profiler():stop(\"block\") eta_string, eta_number = Profiler():eta(\"block\") print(eta_string..\" left...\") print(eta_number..\" seconds to finish...\")","title":"Usage"},{"location":"base/types/profiler/#report","text":"Show a report with the time and amount of times each block was executed.","title":"report"},{"location":"base/types/profiler/#usage_6","text":"Profiler():report()","title":"Usage"},{"location":"base/types/profiler/#start","text":"Create and start a new block.","title":"start"},{"location":"base/types/profiler/#arguments_3","text":"#1 : A string with the block name.","title":"Arguments"},{"location":"base/types/profiler/#usage_7","text":"Profiler():start(\"block\") Profiler():stop(\"block\")","title":"Usage"},{"location":"base/types/profiler/#steps","text":"Define how many times a given block will be executed.","title":"steps"},{"location":"base/types/profiler/#arguments_4","text":"#1 : A string with the block name. #2 : Number of steps a given block will execute.","title":"Arguments"},{"location":"base/types/profiler/#usage_8","text":"Profiler():start(\"block\") Profiler():steps(\"block\", 5) Profiler():stop(\"block\")","title":"Usage"},{"location":"base/types/profiler/#stop","text":"Stop to measure the time of a given block and return how much time was spent with the block since it was started. It returns a table with the spent time in seconds (time), a string with a human-like representation of the time (strTime), spent time of CPU in high precision (clock), a string with a human-like representation of the time of CPU (strClock).","title":"stop"},{"location":"base/types/profiler/#arguments_5","text":"#1 : A string with the block name. If the name is not informed, then it stops and return the uptime of the current block.","title":"Arguments"},{"location":"base/types/profiler/#usage_9","text":"Profiler():start(\"block\") timeTable = Profiler():stop(\"block\") time = timeTable.time clock = timeTable.clock strTime = timeTable.strTime strClock = timeTable.strClock","title":"Usage"},{"location":"base/types/profiler/#uptime","text":"Return how much time was spent on the block up to last stop. It returns two representations: a string with a human-like representation of the time and a number with the time in seconds.","title":"uptime"},{"location":"base/types/profiler/#arguments_6","text":"#1 : A string with the block name. If the name is not informed, then it returns the uptime of the current block.","title":"Arguments"},{"location":"base/types/profiler/#usage_10","text":"Profiler():start(\"block\") Profiler():stop(\"block\") stringTime, numberTime = Profiler():uptime(\"block\")","title":"Usage"},{"location":"base/types/random/","text":"Random Type to generate random numbers. It uses Xorshift generators are among the fastest non-cryptographic random number generators. Xorshift random number generators are a class of pseudorandom number generators that was discovered by George Marsaglia ( http://www.jstatsoft.org/v08/i14/paper ). All the instances of Random along a given simulation have the same seed. The distribution can be inferred according to the selected arguments, as shown below. Arguments Default distribution p \"bernoulli\" lambda \"poisson\" mean (or) sd \"normal\" min, max, step \"step\" min, max \"continuous\" (set of values) \"discrete\" (set of named values) \"categorical\" Arguments alpha : Argument of beta distribution. The default value is 1. beta : Argument of beta distribution. The default value is 1. distrib : A string representing the statistical distribution to be used. See the table below. Distrib Description Compulsory Arguments Optional Arguments \"bernoulli\" A boolean distribution that returns true with probability p. p seed \"beta\" A family of continuous probability distributions defined on the interval [0, 1] parametrized by two positive shape parameters, denoted by alpha and beta, that appear as exponents of the random variable and control the shape of the distribution. alpha, beta, seed \"categorical\" A distribution that has names associated to probabilities. Each name is an argument and has a value between zero and one, indicating the probability to be selected. The sum of all probabilities must be one. ... seed \"continuous\" A continuous uniform distribition. It selects real numbers in a given interval. max, min seed \"discrete\" A discrete uniform distribition. Elements are described as a vector. ... seed \"exponential\" Generate exponentialy distributed pseudo random numbers from a uniformly distributed number in the range [0,1]. For this purpose, it uses the Inverse Transform Samplig method lambda, seed \"lognormal\" Generate log-normally distributed pseudo random numbers from a normaly distributed number in the range [0,1] using the Box-Muller (1978) method. mean, sd, seed \"none\" No distribution. This is useful only when the modeler wants only to set seed. seed \"normal\" Generate Normally (Gaussian) distributed pseudo random numbers from a uniformly distributed number in the range [0,1] using the Box-Muller (1978) method . mean, sd, seed \"poisson\" Generate Poisson distributed pseudo random numbers from a uniformly distributed number in the range [0,1]. For this purpose, it uses the Inverse Transform Samplig method. lambda, seed \"step\" A discrete uniform distribution whose values belong to a given [min, max] interval using step values. max, min, step seed \"weibull\" The Weibull distribution is a real valued distribution with two parameters a and b, producing values greater than or equals to zero. k k : The shape parameter for Weibull distribution. The default value is 1. lambda : An argument of some distributions. It might be interpreted as mean or as scale, according to the given distribution. The default value is 1. max : A number indicating the maximum value to be randomly selected. mean : A number indicating the mean value. The default value is 1. min : A number indicating the minimum value to be randomly selected. p : A number between 0 and 1 representing a probability. sd : A number indicating the standard deviation. The default value is 1. seed : A number to generate the pseudo-random numbers. The default value is the current time of the system, which means that every simulation will use different random numbers. Choosing a seed in interesting when the modeler wants to have the same simulation outcomes despite using random numbers. It is a good programming practice to set the seed in the beginning of the simulation and only once. step : The step where possible values are computed from minimum to maximum. When using this argument, min and max become mandatory. ... : Other values to build a categorical or discrete uniform distribution. Attributes Some attributes of Random have internal semantics. They can be used as read-only by the modeler. distrib : The distribution of the Random object. All the other parameters of the distribution are also attributes. Usage random = Random() bernoulli = Random{p = 0.4} print(bernoulli:sample()) range = Random{min = 3, max = 7} print(range:sample()) step = Random{min = 1, max = 9, step = 2} print(step:sample()) gender = Random{male = 0.49, female = 0.51} print(gender:sample()) age = Random{1, 2, 4, 8, 16, 32} print(age:sample()) cover = Random{\"pasture\", \"forest\", \"clearcut\"} print(cover:sample()) person = Agent{ gender = Random{male = 0.49, female = 0.51}, age = Random{mean = 20, sd = 2}, contacts = Random{lambda = 5} } soc = Society{ instance = person, quantity = 10 } print(soc:gender().male) Functions integer Return an integer random number. number Return a random real number. reSeed Set the seed to generate random numbers. sample Return a random element from the chosen distribution. integer Return an integer random number. It uses a discrete uniform distribution. Arguments #1 : An integer number. If abscent, integer() will return zero or one. If it is the only argument, it will return a number between zero and this value. #2 : An integer number. When used, integer() will return a number between the first argument and the second, inclusive. Usage random = Random() value = random:integer() -- 0 or 1 value = random:integer(10) -- from 0 to 10 value = random:integer(5, 10) -- from 5 to 10 number Return a random real number. By default number() will return a value between zero and one. Arguments #1 : A number. If it is the only argument used, it will return a number from zero to this value. #2 : A number. When used, number() will return a number between the first argument and the second. Usage random = Random() value = random:number() -- between 0 and 1 value = random:number(10) -- between 0 and 10 value = random:number(5, 10) -- between 5 and 10 reSeed Set the seed to generate random numbers. This seed will be used in new instances of Random. All Random objecs previously created will still use the previous seed. Arguments #1 : An integer number with the new seed. Usage random = Random() random:reSeed(12345) sample Return a random element from the chosen distribution. Usage random = Random{2, 3, 4, 6} random:sample()","title":"Random"},{"location":"base/types/random/#random","text":"Type to generate random numbers. It uses Xorshift generators are among the fastest non-cryptographic random number generators. Xorshift random number generators are a class of pseudorandom number generators that was discovered by George Marsaglia ( http://www.jstatsoft.org/v08/i14/paper ). All the instances of Random along a given simulation have the same seed. The distribution can be inferred according to the selected arguments, as shown below. Arguments Default distribution p \"bernoulli\" lambda \"poisson\" mean (or) sd \"normal\" min, max, step \"step\" min, max \"continuous\" (set of values) \"discrete\" (set of named values) \"categorical\"","title":"Random"},{"location":"base/types/random/#arguments","text":"alpha : Argument of beta distribution. The default value is 1. beta : Argument of beta distribution. The default value is 1. distrib : A string representing the statistical distribution to be used. See the table below. Distrib Description Compulsory Arguments Optional Arguments \"bernoulli\" A boolean distribution that returns true with probability p. p seed \"beta\" A family of continuous probability distributions defined on the interval [0, 1] parametrized by two positive shape parameters, denoted by alpha and beta, that appear as exponents of the random variable and control the shape of the distribution. alpha, beta, seed \"categorical\" A distribution that has names associated to probabilities. Each name is an argument and has a value between zero and one, indicating the probability to be selected. The sum of all probabilities must be one. ... seed \"continuous\" A continuous uniform distribition. It selects real numbers in a given interval. max, min seed \"discrete\" A discrete uniform distribition. Elements are described as a vector. ... seed \"exponential\" Generate exponentialy distributed pseudo random numbers from a uniformly distributed number in the range [0,1]. For this purpose, it uses the Inverse Transform Samplig method lambda, seed \"lognormal\" Generate log-normally distributed pseudo random numbers from a normaly distributed number in the range [0,1] using the Box-Muller (1978) method. mean, sd, seed \"none\" No distribution. This is useful only when the modeler wants only to set seed. seed \"normal\" Generate Normally (Gaussian) distributed pseudo random numbers from a uniformly distributed number in the range [0,1] using the Box-Muller (1978) method . mean, sd, seed \"poisson\" Generate Poisson distributed pseudo random numbers from a uniformly distributed number in the range [0,1]. For this purpose, it uses the Inverse Transform Samplig method. lambda, seed \"step\" A discrete uniform distribution whose values belong to a given [min, max] interval using step values. max, min, step seed \"weibull\" The Weibull distribution is a real valued distribution with two parameters a and b, producing values greater than or equals to zero. k k : The shape parameter for Weibull distribution. The default value is 1. lambda : An argument of some distributions. It might be interpreted as mean or as scale, according to the given distribution. The default value is 1. max : A number indicating the maximum value to be randomly selected. mean : A number indicating the mean value. The default value is 1. min : A number indicating the minimum value to be randomly selected. p : A number between 0 and 1 representing a probability. sd : A number indicating the standard deviation. The default value is 1. seed : A number to generate the pseudo-random numbers. The default value is the current time of the system, which means that every simulation will use different random numbers. Choosing a seed in interesting when the modeler wants to have the same simulation outcomes despite using random numbers. It is a good programming practice to set the seed in the beginning of the simulation and only once. step : The step where possible values are computed from minimum to maximum. When using this argument, min and max become mandatory. ... : Other values to build a categorical or discrete uniform distribution.","title":"Arguments"},{"location":"base/types/random/#attributes","text":"Some attributes of Random have internal semantics. They can be used as read-only by the modeler. distrib : The distribution of the Random object. All the other parameters of the distribution are also attributes.","title":"Attributes"},{"location":"base/types/random/#usage","text":"random = Random() bernoulli = Random{p = 0.4} print(bernoulli:sample()) range = Random{min = 3, max = 7} print(range:sample()) step = Random{min = 1, max = 9, step = 2} print(step:sample()) gender = Random{male = 0.49, female = 0.51} print(gender:sample()) age = Random{1, 2, 4, 8, 16, 32} print(age:sample()) cover = Random{\"pasture\", \"forest\", \"clearcut\"} print(cover:sample()) person = Agent{ gender = Random{male = 0.49, female = 0.51}, age = Random{mean = 20, sd = 2}, contacts = Random{lambda = 5} } soc = Society{ instance = person, quantity = 10 } print(soc:gender().male)","title":"Usage"},{"location":"base/types/random/#functions","text":"integer Return an integer random number. number Return a random real number. reSeed Set the seed to generate random numbers. sample Return a random element from the chosen distribution.","title":"Functions"},{"location":"base/types/random/#integer","text":"Return an integer random number. It uses a discrete uniform distribution.","title":"integer"},{"location":"base/types/random/#arguments_1","text":"#1 : An integer number. If abscent, integer() will return zero or one. If it is the only argument, it will return a number between zero and this value. #2 : An integer number. When used, integer() will return a number between the first argument and the second, inclusive.","title":"Arguments"},{"location":"base/types/random/#usage_1","text":"random = Random() value = random:integer() -- 0 or 1 value = random:integer(10) -- from 0 to 10 value = random:integer(5, 10) -- from 5 to 10","title":"Usage"},{"location":"base/types/random/#number","text":"Return a random real number. By default number() will return a value between zero and one.","title":"number"},{"location":"base/types/random/#arguments_2","text":"#1 : A number. If it is the only argument used, it will return a number from zero to this value. #2 : A number. When used, number() will return a number between the first argument and the second.","title":"Arguments"},{"location":"base/types/random/#usage_2","text":"random = Random() value = random:number() -- between 0 and 1 value = random:number(10) -- between 0 and 10 value = random:number(5, 10) -- between 5 and 10","title":"Usage"},{"location":"base/types/random/#reseed","text":"Set the seed to generate random numbers. This seed will be used in new instances of Random. All Random objecs previously created will still use the previous seed.","title":"reSeed"},{"location":"base/types/random/#arguments_3","text":"#1 : An integer number with the new seed.","title":"Arguments"},{"location":"base/types/random/#usage_3","text":"random = Random() random:reSeed(12345)","title":"Usage"},{"location":"base/types/random/#sample","text":"Return a random element from the chosen distribution.","title":"sample"},{"location":"base/types/random/#usage_4","text":"random = Random{2, 3, 4, 6} random:sample()","title":"Usage"},{"location":"base/types/socialNetwork/","text":"SocialNetwork SocialNetwork represents relations between A gents. It is a set of pairs (connection, weight), where connection is an A gent and weight is a number storing the relation's strength. This type is used to create relations from scratch to be used by Agent:addSocialNetwork() . To create well-established SocialNetworks see Society:createSocialNetwork() . It is recommended that a SocialNetwork should contain only Agents that belong to the same Society , as it guarantees that all its Agents have unique identifiers. Calling forEachConnection() from an Agent traverses one of its SocialNetworks. Attributes Some attributes of SocialNetwork have internal semantics. They can be used as read-only by the modeler. connections : The connections with the Agents of the SocialNetWork. count : The number of Agents in the SocialNetwork. weights : The weights of the Agents in the SocialNetwork. Usage sn = SocialNetwork() sn = SocialNetwork{} See also createSocialNetwork (Society) Functions add Add a new connection to the SocialNetwork. clear Remove all Agents from the SocialNetwork. getWeight Return a number with the weight of a given connection. isConnection Return whether a given Agent belongs to the SocialNetwork. isEmpty Return whether the SocialNetwork does not contain any Agent . remove Remove an Agent from the SocialNetwork. sample Return a random Agent from the SocialNetwork. setWeight Update the weight of a connection. # Retrieve the number of connections in the SocialNetwork. add Add a new connection to the SocialNetwork. Arguments #1 : An Agent . #2 : A number representing the weight of the connection). The default value is 1. Usage sn = SocialNetwork() agent1 = Agent{id = \"1\"} agent2 = Agent{id = \"2\"} sn:add(agent1) sn:add(agent2, 0.5) print(#sn) clear Remove all Agents from the SocialNetwork. In practice, it has the same behavior of calling SocialNetwork() again if the SocialNetwork was not added to any Agent. Usage sn = SocialNetwork() agent1 = Agent{id = \"1\"} agent2 = Agent{id = \"2\"} sn:add(agent1) sn:add(agent2) sn:clear() print(#sn) getWeight Return a number with the weight of a given connection. Arguments #1 : An Agent . Usage sn = SocialNetwork() agent1 = Agent{id = \"1\"} agent2 = Agent{id = \"2\"} sn:add(agent1) sn:add(agent2, 0.5) print(sn:getWeight(agent1)) print(sn:getWeight(agent2)) isConnection Return whether a given Agent belongs to the SocialNetwork. Arguments #1 : An Agent. Usage sn = SocialNetwork() agent = Agent{id = \"1\"} sn:add(agent) if sn:isConnection(agent) then print(\"connected\") end isEmpty Return whether the SocialNetwork does not contain any Agent . Usage sn = SocialNetwork() if sn:isEmpty() then print(\"empty\") end remove Remove an Agent from the SocialNetwork. Arguments #1 : An Agent. Usage sn = SocialNetwork() agent1 = Agent{id = \"1\"} agent2 = Agent{id = \"2\"} sn:add(agent1) sn:add(agent2) sn:remove(agent1) print(#sn) sample Return a random Agent from the SocialNetwork. Usage sn = SocialNetwork() agent1 = Agent{id = \"1\"} agent2 = Agent{id = \"2\"} sn:add(agent1) sn:add(agent2) agent = sn:sample() setWeight Update the weight of a connection. Arguments #1 : An Agent . #2 : A number with the new weight. Usage sn = SocialNetwork() agent1 = Agent{id = \"1\"} agent2 = Agent{id = \"2\"} sn:add(agent1) sn:add(agent2, 0.5) sn:setWeight(agent1, 0.001) print(sn:getWeight(agent1)) # Retrieve the number of connections in the SocialNetwork. Usage sn = SocialNetwork() print(#sn)","title":"SocialNetwork"},{"location":"base/types/socialNetwork/#socialnetwork","text":"SocialNetwork represents relations between A gents. It is a set of pairs (connection, weight), where connection is an A gent and weight is a number storing the relation's strength. This type is used to create relations from scratch to be used by Agent:addSocialNetwork() . To create well-established SocialNetworks see Society:createSocialNetwork() . It is recommended that a SocialNetwork should contain only Agents that belong to the same Society , as it guarantees that all its Agents have unique identifiers. Calling forEachConnection() from an Agent traverses one of its SocialNetworks.","title":"SocialNetwork"},{"location":"base/types/socialNetwork/#attributes","text":"Some attributes of SocialNetwork have internal semantics. They can be used as read-only by the modeler. connections : The connections with the Agents of the SocialNetWork. count : The number of Agents in the SocialNetwork. weights : The weights of the Agents in the SocialNetwork.","title":"Attributes"},{"location":"base/types/socialNetwork/#usage","text":"sn = SocialNetwork() sn = SocialNetwork{}","title":"Usage"},{"location":"base/types/socialNetwork/#see-also","text":"createSocialNetwork (Society)","title":"See also"},{"location":"base/types/socialNetwork/#functions","text":"add Add a new connection to the SocialNetwork. clear Remove all Agents from the SocialNetwork. getWeight Return a number with the weight of a given connection. isConnection Return whether a given Agent belongs to the SocialNetwork. isEmpty Return whether the SocialNetwork does not contain any Agent . remove Remove an Agent from the SocialNetwork. sample Return a random Agent from the SocialNetwork. setWeight Update the weight of a connection. # Retrieve the number of connections in the SocialNetwork.","title":"Functions"},{"location":"base/types/socialNetwork/#add","text":"Add a new connection to the SocialNetwork.","title":"add"},{"location":"base/types/socialNetwork/#arguments","text":"#1 : An Agent . #2 : A number representing the weight of the connection). The default value is 1.","title":"Arguments"},{"location":"base/types/socialNetwork/#usage_1","text":"sn = SocialNetwork() agent1 = Agent{id = \"1\"} agent2 = Agent{id = \"2\"} sn:add(agent1) sn:add(agent2, 0.5) print(#sn)","title":"Usage"},{"location":"base/types/socialNetwork/#clear","text":"Remove all Agents from the SocialNetwork. In practice, it has the same behavior of calling SocialNetwork() again if the SocialNetwork was not added to any Agent.","title":"clear"},{"location":"base/types/socialNetwork/#usage_2","text":"sn = SocialNetwork() agent1 = Agent{id = \"1\"} agent2 = Agent{id = \"2\"} sn:add(agent1) sn:add(agent2) sn:clear() print(#sn)","title":"Usage"},{"location":"base/types/socialNetwork/#getweight","text":"Return a number with the weight of a given connection.","title":"getWeight"},{"location":"base/types/socialNetwork/#arguments_1","text":"#1 : An Agent .","title":"Arguments"},{"location":"base/types/socialNetwork/#usage_3","text":"sn = SocialNetwork() agent1 = Agent{id = \"1\"} agent2 = Agent{id = \"2\"} sn:add(agent1) sn:add(agent2, 0.5) print(sn:getWeight(agent1)) print(sn:getWeight(agent2))","title":"Usage"},{"location":"base/types/socialNetwork/#isconnection","text":"Return whether a given Agent belongs to the SocialNetwork.","title":"isConnection"},{"location":"base/types/socialNetwork/#arguments_2","text":"#1 : An Agent.","title":"Arguments"},{"location":"base/types/socialNetwork/#usage_4","text":"sn = SocialNetwork() agent = Agent{id = \"1\"} sn:add(agent) if sn:isConnection(agent) then print(\"connected\") end","title":"Usage"},{"location":"base/types/socialNetwork/#isempty","text":"Return whether the SocialNetwork does not contain any Agent .","title":"isEmpty"},{"location":"base/types/socialNetwork/#usage_5","text":"sn = SocialNetwork() if sn:isEmpty() then print(\"empty\") end","title":"Usage"},{"location":"base/types/socialNetwork/#remove","text":"Remove an Agent from the SocialNetwork.","title":"remove"},{"location":"base/types/socialNetwork/#arguments_3","text":"#1 : An Agent.","title":"Arguments"},{"location":"base/types/socialNetwork/#usage_6","text":"sn = SocialNetwork() agent1 = Agent{id = \"1\"} agent2 = Agent{id = \"2\"} sn:add(agent1) sn:add(agent2) sn:remove(agent1) print(#sn)","title":"Usage"},{"location":"base/types/socialNetwork/#sample","text":"Return a random Agent from the SocialNetwork.","title":"sample"},{"location":"base/types/socialNetwork/#usage_7","text":"sn = SocialNetwork() agent1 = Agent{id = \"1\"} agent2 = Agent{id = \"2\"} sn:add(agent1) sn:add(agent2) agent = sn:sample()","title":"Usage"},{"location":"base/types/socialNetwork/#setweight","text":"Update the weight of a connection.","title":"setWeight"},{"location":"base/types/socialNetwork/#arguments_4","text":"#1 : An Agent . #2 : A number with the new weight.","title":"Arguments"},{"location":"base/types/socialNetwork/#usage_8","text":"sn = SocialNetwork() agent1 = Agent{id = \"1\"} agent2 = Agent{id = \"2\"} sn:add(agent1) sn:add(agent2, 0.5) sn:setWeight(agent1, 0.001) print(sn:getWeight(agent1))","title":"Usage"},{"location":"base/types/socialNetwork/#_1","text":"Retrieve the number of connections in the SocialNetwork.","title":"#"},{"location":"base/types/socialNetwork/#usage_9","text":"sn = SocialNetwork() print(#sn)","title":"Usage"},{"location":"base/types/society/","text":"Society Type to create and manipulate a set of Agents . Each Agent within a Society has a unique id, which is initialized while creating the Society. There are different ways to create a Society. See the argument source for the options. Calling forEachAgent() traverses Societies. Arguments file : A File or a string with the name of the file where data related to the Agents is stored. id : The unique identifier attribute used when reading the Society from a file. instance : An Agent with the description of attributes and functions. When using this argument, each Agent of the Society will have attributes and functions according to the instance. The attributes of the instance will be copyed to the Agent and Society calls Agent:init() for each of its Agents. Every attribute from the Agent that is a Random will be converted into a Random:sample() . When using this argument, additional functions are also created to the Society. For each attribute of the its Agents (after calling Agent:init() ), one function is created in the Society with the same name. The table below describes how each attribute is mapped from the Agent to the Society: Type of attribute Function within the Society function Call the function of each of its Agents. number Return the sum of the number in each of its Agents. boolean Return the quantity of true values in its Agents. string Return a table with positions equal to the unique strings and values equal to the number of occurrences in each of its Agents. quantity : Number of Agents to be created. It is used when the Society will not be loaded from a file or database. sep : A string with the file separator for reading a CSV (default is \",\"). source : A string with the name of the source the Society will be read from. TerraME always converts this string to lower case. See the table below: source Description Compulsory arguments Optional arguments \"volatile\" Create agents from scratch. This is the default value when using the argument quantity. instance, quantity ... \"shp\" Load agents from a shapefile. file, instance ... \"csv\" Load agents from a csv file. This is the default value when value of argument database ends with \".csv\". file, id, instance sep, ... ... : Any other attribute or function for the Society. Attributes Some attributes of Society have internal semantics. They can be used as read-only by the modeler. agents : A vector of Agents pointed by the Society. autoincrement : unique identifier used to represent the last Agent added to the Society. The next Agent will have 'autoincrement + 1' as id. cObj_ : A pointer to a C++ representation of the Society. Never use this object. instance : The Agent that describes attributes and functions of each Agent belonging to the Society. This Agent must not be executed. messages : A vector that contains the delayed messages. parent : The Environment it belongs. placements : A vector with the names of the placements created using this object (see Environment:createPlacement() ). Usage instance = Agent{ execute = function() end, run = function() end, age = Random{min = 1, max = 50, step = 1} } s = Society{ instance = instance, quantity = 20 } s:execute() -- call execute for each agent s:run() -- call run for each agent print(s:age()) -- sum of the ages of each agent print(#s) instance = Agent{ execute = function() end } s = Society{ instance = instance, file = filePath(\"agents.csv\", \"base\") } print(#s) Functions add Add a new Agent to the Society. clear Remove all the Agents from the Society. createSocialNetwork Create a directed SocialNetwork for each Agent of the Society. get Return a given Agent based on its position. notify Notify all the Agents of the Society. remove Remove a given Agent from the Society. sample Return a random Agent from the Society. split Split the Society into a set of Groups according to a classification strategy. synchronize Deliver asynchronous messages sent by Agents belonging to the Society. # Return the number of Agents in the Society. add Add a new Agent to the Society. It will be the last Agent of the Society when one uses forEachAgent() . Arguments #1 : The new Agent that will be added to the Society. If nil, the Society will add a copy of its instance. In this case, the Society converts Random values into samples and executes Agent:init() . Usage ag = Agent{ age = Random{min = 1, max = 50, step = 1} } soc = Society{ instance = ag, quantity = 2 } soc:add() print(#soc) agent = soc:add() print(agent.age) See also init (Agent) clear Remove all the Agents from the Society. Usage ag = Agent{} soc = Society{ instance = ag, quantity = 2 } print(#soc) soc:clear() print(#soc) createSocialNetwork Create a directed SocialNetwork for each Agent of the Society. Arguments filter : A function (Agent, Agent)->boolean that returns true if the first Agent will have the second Agent in its SocialNetwork. When using this argument, the default value of strategy becomes \"function\". inmemory : If true (default), a SocialNetwork will be built and stored for each Agent of the Society. The SocialNetworks will change only if the modeler add or remove connections explicitly. If false, a SocialNetwork will be computed every time the simulation calls Agent:getSocialNetwork() , for example when using forEachConnection() . In this case, if any of the attributes the SocialNetwork is based on changes then the resulting SocialNetwork might be different. For instance, if the SocialNetwork of an Agent is based on its Neighborhood and the Agent walks to another Cell , a SocialNetwork not inmemory will also be updated. SocialNetworks not inmemory also help the simulation to run with larger datasets, as they are not explicitly represented, but they consume more time as they need to be built again and again along the simulation. Note that not inmemory relations cannot be changed manually (for example by using SocialNetwork:add() ), because the relation is recomputed every time it is needed. name : Name of the relation. neighborhood : A string with the name of the Neighborhood that will be used to create the SocialNetwork. The default value is \"1\". placement : A string with the name of the placement that will be used to create the SocialNetwork. The default value is \"placement\". probability : A number between 0 and 1 indicating a probability. The semantics associated to the probability depends on the argument strategy. When using this argument, the default value of strategy becomes \"probability\". quantity : A number indicating a quantity of connections. The semantics associated to this value depends on the argument strategy. When using this argument, the default value of strategy becomes \"quantity\". self : A boolean value indicating whether the Agent can be connected to itself. The default value is false. start : The number of agents without any connection in the initial group. New agents are connected to agents in this group and then added to the group. This argument is useful only for \"barabasi\" strategy. strategy : A string with the strategy to be used for creating the SocialNetwork. See the table below. Strategy Description Compulsory arguments Optional arguments \"barabasi\" Create a SocialNetwork according to the strategy proposed by Barabasi and Albert \"Emergence of scaling in random networks\" Science 286 509-512 (1999). quantity, start, strategy name \"cell\" Create a dynamic SocialNetwork for each Agent of the Society with every Agent within the same Cell the Agent belongs. inmemory, name, placement, self \"erdos\" Create a SocialNetwork with a given number of random connections. This strategy implements the algorithm proposed by Erdos and Renyi (1959) \"On random graphs I\". Publicationes Mathematicae 6: 290-297 quantity, strategy name \"function\" Create a SocialNetwork according to a filter function applied to each Agent of the Society. filter inmemory, name \"neighbor\" Create a dynamic SocialNetwork for each Agent of the Society with every Agent within the neighbor Cells of the one the Agent belongs. inmemory, name, neighborhood, placement \"probability\" Applies a probability for each pair of Agents to be connected (excluding the Agent itself). probability inmemory, name, symmetric \"quantity\" Each Agent will be connected to a given number of other Agents randomly taken from the Society (excluding the Agent itself). quantity inmemory, name, symmetric \"void\" Create an empty SocialNetwork for each Agent of the Society. name \"watts\" Create a SocialNetwork according to the strategy proposed by Watts and Strogarz (1998) Collective dynamics of 'small-world' networks. Nature 393, 440-442. probability, quantity, strategy name symmetric : A boolean value indicating that, if Agent a is connected to Agent b, then Agent b will be connected to Agent a. In practice, if this option is used, the number of connections double. For example, if one use this with 20% of probability, on average, Agents will be connected with 40% of probability. The default value is false. Usage ag = Agent{} soc = Society{ instance = ag, quantity = 20 } soc:createSocialNetwork{ quantity = 2 } soc:createSocialNetwork{ probability = 0.15, name = \"random\" } cs = CellularSpace{xdim = 10} cs:createNeighborhood() env = Environment{soc, cs} env:createPlacement() soc:createSocialNetwork{ strategy = \"neighbor\", name = \"byneighbor\" } get Return a given Agent based on its position. Arguments #1 : The position of the Agent that will be returned. It can be a number (with the position of the Agent in the vector of Agents) or a string (with the id of the Agent). Usage ag = Agent{} soc = Society{ instance = ag, quantity = 2 } agent = soc:get(\"1\") print(agent.id) notify Notify all the Agents of the Society. Arguments #1 : A positive number representing the notification time. The default value is 0. It is also possible to use an Event as argument. In this case, it will use the result of Event:getTime() . Usage ag = Agent{} soc = Society{ instance = ag, quantity = 2 } soc:notify() soc:add() soc:add() soc:notify() remove Remove a given Agent from the Society. Arguments #1 : The Agent that will be removed, or a function that takes an Agent as argument and returns true if the Agent must be removed. Usage ag = Agent{} soc = Society{ instance = ag, quantity = 2 } print(#soc) soc:remove(soc:sample()) print(#soc) sample Return a random Agent from the Society. Usage agent = Agent{} soc = Society{ instance = agent, quantity = 10 } sample = soc:sample() split Split the Society into a set of Groups according to a classification strategy. The Groups will have empty intersection and union equal to the whole Society (unless function below returns nil for some Agent ). It works according to the type of its only and compulsory argument. Arguments #1 : A string or a function, working as follows: Type of argument Description string The argument must represent the name of one attribute of the Agents of the Society. Split then creates one Group for each possible value of the attribute using the value as name and fills them with the Agents that have the respective attribute value. If the Society has an instance and the respective attribute in the instance is a Random value with discrete or categorical strategy, it will use the possible values to create Groups, which means that the returning Groups can have size zero in this case. function The argument is a function that gets an Agent as argument and returns a name for the Agent, which can be a number, string, or boolean value. Groups are then named according to the returning value. Usage ag = Agent{ gender = Random{\"male\", \"female\"}, age = Random{min = 1, max = 80, step = 1} } soc = Society{ instance = ag, quantity = 50 } groups = soc:split(\"gender\") print(#groups.male) -- can be zero because it comes from an instance print(#groups.female) -- also groups2 = soc:split(function(ag) if ag.age > 60 then return \"old\" else return \"notold\" end end) if groups2.old then -- might not exist as it does not come from an instance print(#groups2.old) end synchronize Deliver asynchronous messages sent by Agents belonging to the Society. Arguments #1 : A number indicating the current delay to be delivered. Messages with delay less or equal this value are sent, while the others have their delays reduced by this value. The default value is one. Usage nonFooAgent = Agent{ received = 0, on_message = function(self) self.received = self.received + 1 end } soc = Society{ instance = nonFooAgent, quantity = 15 } soc:createSocialNetwork{quantity = 5} forEachAgent(soc, function(agent) forEachConnection(agent, function(friend) agent:message{receiver = friend, delay = 5} end) end) otheragent = soc:sample() print(otheragent.received) soc:synchronize(4) print(otheragent.received) soc:synchronize(2) print(otheragent.received) # Return the number of Agents in the Society. Usage ag = Agent{} soc = Society{ instance = ag, quantity = 2 } print(#soc)","title":"Society"},{"location":"base/types/society/#society","text":"Type to create and manipulate a set of Agents . Each Agent within a Society has a unique id, which is initialized while creating the Society. There are different ways to create a Society. See the argument source for the options. Calling forEachAgent() traverses Societies.","title":"Society"},{"location":"base/types/society/#arguments","text":"file : A File or a string with the name of the file where data related to the Agents is stored. id : The unique identifier attribute used when reading the Society from a file. instance : An Agent with the description of attributes and functions. When using this argument, each Agent of the Society will have attributes and functions according to the instance. The attributes of the instance will be copyed to the Agent and Society calls Agent:init() for each of its Agents. Every attribute from the Agent that is a Random will be converted into a Random:sample() . When using this argument, additional functions are also created to the Society. For each attribute of the its Agents (after calling Agent:init() ), one function is created in the Society with the same name. The table below describes how each attribute is mapped from the Agent to the Society: Type of attribute Function within the Society function Call the function of each of its Agents. number Return the sum of the number in each of its Agents. boolean Return the quantity of true values in its Agents. string Return a table with positions equal to the unique strings and values equal to the number of occurrences in each of its Agents. quantity : Number of Agents to be created. It is used when the Society will not be loaded from a file or database. sep : A string with the file separator for reading a CSV (default is \",\"). source : A string with the name of the source the Society will be read from. TerraME always converts this string to lower case. See the table below: source Description Compulsory arguments Optional arguments \"volatile\" Create agents from scratch. This is the default value when using the argument quantity. instance, quantity ... \"shp\" Load agents from a shapefile. file, instance ... \"csv\" Load agents from a csv file. This is the default value when value of argument database ends with \".csv\". file, id, instance sep, ... ... : Any other attribute or function for the Society.","title":"Arguments"},{"location":"base/types/society/#attributes","text":"Some attributes of Society have internal semantics. They can be used as read-only by the modeler. agents : A vector of Agents pointed by the Society. autoincrement : unique identifier used to represent the last Agent added to the Society. The next Agent will have 'autoincrement + 1' as id. cObj_ : A pointer to a C++ representation of the Society. Never use this object. instance : The Agent that describes attributes and functions of each Agent belonging to the Society. This Agent must not be executed. messages : A vector that contains the delayed messages. parent : The Environment it belongs. placements : A vector with the names of the placements created using this object (see Environment:createPlacement() ).","title":"Attributes"},{"location":"base/types/society/#usage","text":"","title":"Usage"},{"location":"base/types/society/#instance-agent-execute-function-end-run-function-end-age-randommin-1-max-50-step-1-s-society-instance-instance-quantity-20-sexecute-call-execute-for-each-agent-srun-call-run-for-each-agent-printsage-sum-of-the-ages-of-each-agent-prints-instance-agent-execute-function-end-s-society-instance-instance-file-filepathagentscsv-base-prints","text":"","title":"instance = Agent{ execute = function() end, run = function() end, age = Random{min = 1, max = 50, step = 1} } s = Society{ instance = instance, quantity = 20 } s:execute() -- call execute for each agent s:run() -- call run for each agent print(s:age()) -- sum of the ages of each agent print(#s) instance = Agent{ execute = function() end } s = Society{ instance = instance, file = filePath(&quot;agents.csv&quot;, &quot;base&quot;) } print(#s)"},{"location":"base/types/society/#functions","text":"add Add a new Agent to the Society. clear Remove all the Agents from the Society. createSocialNetwork Create a directed SocialNetwork for each Agent of the Society. get Return a given Agent based on its position. notify Notify all the Agents of the Society. remove Remove a given Agent from the Society. sample Return a random Agent from the Society. split Split the Society into a set of Groups according to a classification strategy. synchronize Deliver asynchronous messages sent by Agents belonging to the Society. # Return the number of Agents in the Society.","title":"Functions"},{"location":"base/types/society/#add","text":"Add a new Agent to the Society. It will be the last Agent of the Society when one uses forEachAgent() .","title":"add"},{"location":"base/types/society/#arguments_1","text":"#1 : The new Agent that will be added to the Society. If nil, the Society will add a copy of its instance. In this case, the Society converts Random values into samples and executes Agent:init() .","title":"Arguments"},{"location":"base/types/society/#usage_1","text":"ag = Agent{ age = Random{min = 1, max = 50, step = 1} } soc = Society{ instance = ag, quantity = 2 } soc:add() print(#soc) agent = soc:add() print(agent.age)","title":"Usage"},{"location":"base/types/society/#see-also","text":"init (Agent)","title":"See also"},{"location":"base/types/society/#clear","text":"Remove all the Agents from the Society.","title":"clear"},{"location":"base/types/society/#usage_2","text":"ag = Agent{} soc = Society{ instance = ag, quantity = 2 } print(#soc) soc:clear() print(#soc)","title":"Usage"},{"location":"base/types/society/#createsocialnetwork","text":"Create a directed SocialNetwork for each Agent of the Society.","title":"createSocialNetwork"},{"location":"base/types/society/#arguments_2","text":"filter : A function (Agent, Agent)->boolean that returns true if the first Agent will have the second Agent in its SocialNetwork. When using this argument, the default value of strategy becomes \"function\". inmemory : If true (default), a SocialNetwork will be built and stored for each Agent of the Society. The SocialNetworks will change only if the modeler add or remove connections explicitly. If false, a SocialNetwork will be computed every time the simulation calls Agent:getSocialNetwork() , for example when using forEachConnection() . In this case, if any of the attributes the SocialNetwork is based on changes then the resulting SocialNetwork might be different. For instance, if the SocialNetwork of an Agent is based on its Neighborhood and the Agent walks to another Cell , a SocialNetwork not inmemory will also be updated. SocialNetworks not inmemory also help the simulation to run with larger datasets, as they are not explicitly represented, but they consume more time as they need to be built again and again along the simulation. Note that not inmemory relations cannot be changed manually (for example by using SocialNetwork:add() ), because the relation is recomputed every time it is needed. name : Name of the relation. neighborhood : A string with the name of the Neighborhood that will be used to create the SocialNetwork. The default value is \"1\". placement : A string with the name of the placement that will be used to create the SocialNetwork. The default value is \"placement\". probability : A number between 0 and 1 indicating a probability. The semantics associated to the probability depends on the argument strategy. When using this argument, the default value of strategy becomes \"probability\". quantity : A number indicating a quantity of connections. The semantics associated to this value depends on the argument strategy. When using this argument, the default value of strategy becomes \"quantity\". self : A boolean value indicating whether the Agent can be connected to itself. The default value is false. start : The number of agents without any connection in the initial group. New agents are connected to agents in this group and then added to the group. This argument is useful only for \"barabasi\" strategy. strategy : A string with the strategy to be used for creating the SocialNetwork. See the table below. Strategy Description Compulsory arguments Optional arguments \"barabasi\" Create a SocialNetwork according to the strategy proposed by Barabasi and Albert \"Emergence of scaling in random networks\" Science 286 509-512 (1999). quantity, start, strategy name \"cell\" Create a dynamic SocialNetwork for each Agent of the Society with every Agent within the same Cell the Agent belongs. inmemory, name, placement, self \"erdos\" Create a SocialNetwork with a given number of random connections. This strategy implements the algorithm proposed by Erdos and Renyi (1959) \"On random graphs I\". Publicationes Mathematicae 6: 290-297 quantity, strategy name \"function\" Create a SocialNetwork according to a filter function applied to each Agent of the Society. filter inmemory, name \"neighbor\" Create a dynamic SocialNetwork for each Agent of the Society with every Agent within the neighbor Cells of the one the Agent belongs. inmemory, name, neighborhood, placement \"probability\" Applies a probability for each pair of Agents to be connected (excluding the Agent itself). probability inmemory, name, symmetric \"quantity\" Each Agent will be connected to a given number of other Agents randomly taken from the Society (excluding the Agent itself). quantity inmemory, name, symmetric \"void\" Create an empty SocialNetwork for each Agent of the Society. name \"watts\" Create a SocialNetwork according to the strategy proposed by Watts and Strogarz (1998) Collective dynamics of 'small-world' networks. Nature 393, 440-442. probability, quantity, strategy name symmetric : A boolean value indicating that, if Agent a is connected to Agent b, then Agent b will be connected to Agent a. In practice, if this option is used, the number of connections double. For example, if one use this with 20% of probability, on average, Agents will be connected with 40% of probability. The default value is false.","title":"Arguments"},{"location":"base/types/society/#usage_3","text":"ag = Agent{} soc = Society{ instance = ag, quantity = 20 } soc:createSocialNetwork{ quantity = 2 } soc:createSocialNetwork{ probability = 0.15, name = \"random\" } cs = CellularSpace{xdim = 10} cs:createNeighborhood() env = Environment{soc, cs} env:createPlacement() soc:createSocialNetwork{ strategy = \"neighbor\", name = \"byneighbor\" }","title":"Usage"},{"location":"base/types/society/#get","text":"Return a given Agent based on its position.","title":"get"},{"location":"base/types/society/#arguments_3","text":"#1 : The position of the Agent that will be returned. It can be a number (with the position of the Agent in the vector of Agents) or a string (with the id of the Agent).","title":"Arguments"},{"location":"base/types/society/#usage_4","text":"ag = Agent{} soc = Society{ instance = ag, quantity = 2 } agent = soc:get(\"1\") print(agent.id)","title":"Usage"},{"location":"base/types/society/#notify","text":"Notify all the Agents of the Society.","title":"notify"},{"location":"base/types/society/#arguments_4","text":"#1 : A positive number representing the notification time. The default value is 0. It is also possible to use an Event as argument. In this case, it will use the result of Event:getTime() .","title":"Arguments"},{"location":"base/types/society/#usage_5","text":"ag = Agent{} soc = Society{ instance = ag, quantity = 2 } soc:notify() soc:add() soc:add() soc:notify()","title":"Usage"},{"location":"base/types/society/#remove","text":"Remove a given Agent from the Society.","title":"remove"},{"location":"base/types/society/#arguments_5","text":"#1 : The Agent that will be removed, or a function that takes an Agent as argument and returns true if the Agent must be removed.","title":"Arguments"},{"location":"base/types/society/#usage_6","text":"ag = Agent{} soc = Society{ instance = ag, quantity = 2 } print(#soc) soc:remove(soc:sample()) print(#soc)","title":"Usage"},{"location":"base/types/society/#sample","text":"Return a random Agent from the Society.","title":"sample"},{"location":"base/types/society/#usage_7","text":"agent = Agent{} soc = Society{ instance = agent, quantity = 10 } sample = soc:sample()","title":"Usage"},{"location":"base/types/society/#split","text":"Split the Society into a set of Groups according to a classification strategy. The Groups will have empty intersection and union equal to the whole Society (unless function below returns nil for some Agent ). It works according to the type of its only and compulsory argument.","title":"split"},{"location":"base/types/society/#arguments_6","text":"#1 : A string or a function, working as follows: Type of argument Description string The argument must represent the name of one attribute of the Agents of the Society. Split then creates one Group for each possible value of the attribute using the value as name and fills them with the Agents that have the respective attribute value. If the Society has an instance and the respective attribute in the instance is a Random value with discrete or categorical strategy, it will use the possible values to create Groups, which means that the returning Groups can have size zero in this case. function The argument is a function that gets an Agent as argument and returns a name for the Agent, which can be a number, string, or boolean value. Groups are then named according to the returning value.","title":"Arguments"},{"location":"base/types/society/#usage_8","text":"ag = Agent{ gender = Random{\"male\", \"female\"}, age = Random{min = 1, max = 80, step = 1} } soc = Society{ instance = ag, quantity = 50 } groups = soc:split(\"gender\") print(#groups.male) -- can be zero because it comes from an instance print(#groups.female) -- also groups2 = soc:split(function(ag) if ag.age > 60 then return \"old\" else return \"notold\" end end) if groups2.old then -- might not exist as it does not come from an instance print(#groups2.old) end","title":"Usage"},{"location":"base/types/society/#synchronize","text":"Deliver asynchronous messages sent by Agents belonging to the Society.","title":"synchronize"},{"location":"base/types/society/#arguments_7","text":"#1 : A number indicating the current delay to be delivered. Messages with delay less or equal this value are sent, while the others have their delays reduced by this value. The default value is one.","title":"Arguments"},{"location":"base/types/society/#usage_9","text":"nonFooAgent = Agent{ received = 0, on_message = function(self) self.received = self.received + 1 end } soc = Society{ instance = nonFooAgent, quantity = 15 } soc:createSocialNetwork{quantity = 5} forEachAgent(soc, function(agent) forEachConnection(agent, function(friend) agent:message{receiver = friend, delay = 5} end) end) otheragent = soc:sample() print(otheragent.received) soc:synchronize(4) print(otheragent.received) soc:synchronize(2) print(otheragent.received)","title":"Usage"},{"location":"base/types/society/#_1","text":"Return the number of Agents in the Society.","title":"#"},{"location":"base/types/society/#usage_10","text":"ag = Agent{} soc = Society{ instance = ag, quantity = 2 } print(#soc)","title":"Usage"},{"location":"base/types/state/","text":"State A container of Jumps and Flows . Every State also has an id to identify itself in the Jumps of other States within the same Agent or Automaton . Arguments id : A string with the unique identifier of the State. Usage State{ id = \"working\" }","title":"State"},{"location":"base/types/state/#state","text":"A container of Jumps and Flows . Every State also has an id to identify itself in the Jumps of other States within the same Agent or Automaton .","title":"State"},{"location":"base/types/state/#arguments","text":"id : A string with the unique identifier of the State.","title":"Arguments"},{"location":"base/types/state/#usage","text":"State{ id = \"working\" }","title":"Usage"},{"location":"base/types/textScreen/","text":"TextScreen A window with a table to show the attributes of an object along the simulation. Each call to notify() add one more line to the content of the window. Arguments select : A vector of strings with the name of the attributes to be observed. If it is only a single value then it can also be described as a string. As default, it selects all the user-defined attributes of an object. In the case of Society , if it does not have any numeric attributes then it will use the number of agents in the Society as attribute. target : An Agent , Cell , CellularSpace , Society. Usage agent = Agent{ size = 5, age = 1 } TextScreen{ target = agent, select = {\"size\" , \"age\"} } Functions save Save a TextScreen into a file. update Update the TextScreen with the latest values of its target. save Save a TextScreen into a file. Supported extensions are bmp, jpg, png, and tiff. Arguments #1 : A string with the file name. Usage agent = Agent{ size = 5, age = 1 } ts = TextScreen{ target = agent, select = {\"size\" , \"age\"} } ts:save(\"file.bmp\") File(\"file.bmp\"):delete() update Update the TextScreen with the latest values of its target. It is usually recommended to use the TextScreen as action of an Event instead of calling this function explicitly. Arguments #1 : An optional argument that can be a number with the current time or an Event. Usage agent = Agent{ size = 5, age = 1 } ts = TextScreen{ target = agent, select = {\"size\" , \"age\"} } ts:update()","title":"TextScreen"},{"location":"base/types/textScreen/#textscreen","text":"A window with a table to show the attributes of an object along the simulation. Each call to notify() add one more line to the content of the window.","title":"TextScreen"},{"location":"base/types/textScreen/#arguments","text":"select : A vector of strings with the name of the attributes to be observed. If it is only a single value then it can also be described as a string. As default, it selects all the user-defined attributes of an object. In the case of Society , if it does not have any numeric attributes then it will use the number of agents in the Society as attribute. target : An Agent , Cell , CellularSpace , Society.","title":"Arguments"},{"location":"base/types/textScreen/#usage","text":"agent = Agent{ size = 5, age = 1 } TextScreen{ target = agent, select = {\"size\" , \"age\"} }","title":"Usage"},{"location":"base/types/textScreen/#functions","text":"save Save a TextScreen into a file. update Update the TextScreen with the latest values of its target.","title":"Functions"},{"location":"base/types/textScreen/#save","text":"Save a TextScreen into a file. Supported extensions are bmp, jpg, png, and tiff.","title":"save"},{"location":"base/types/textScreen/#arguments_1","text":"#1 : A string with the file name.","title":"Arguments"},{"location":"base/types/textScreen/#usage_1","text":"agent = Agent{ size = 5, age = 1 } ts = TextScreen{ target = agent, select = {\"size\" , \"age\"} } ts:save(\"file.bmp\") File(\"file.bmp\"):delete()","title":"Usage"},{"location":"base/types/textScreen/#update","text":"Update the TextScreen with the latest values of its target. It is usually recommended to use the TextScreen as action of an Event instead of calling this function explicitly.","title":"update"},{"location":"base/types/textScreen/#arguments_2","text":"#1 : An optional argument that can be a number with the current time or an Event.","title":"Arguments"},{"location":"base/types/textScreen/#usage_2","text":"agent = Agent{ size = 5, age = 1 } ts = TextScreen{ target = agent, select = {\"size\" , \"age\"} } ts:update()","title":"Usage"},{"location":"base/types/timer/","text":"Timer A Timer is an event-based scheduler that runs the simulation. It contains a set of Events , allowing the simulation to work with processes that start independently and act in different periodicities. As default, it execute the Events in the order they were declared, but the arguments of Event (start, priority, and period) can change this order. Once a Timer has a given simulation time, it ensures that all the Events before that time were already executed. See run() for more details. Arguments ... : A set of Events. Attributes Some attributes of Timer have internal semantics. They can be used as read-only by the modeler. cObj_ : A pointer to a C++ representation of the Timer. Never use this object. events : An ordered vector with the Events. time : The current simulation time. Usage timer = Timer{ Event{action = function() print(\"each time step\") end}, Event{period = 2, action = function() print(\"each two time steps\") end}, Event{priority = \"high\", period = 4, action = function() print(\"each four time steps\") end} } timer:run(10) Functions add Add a new Event to the timer. clear Remove all the Events from the Timer. getEvents Return a vector with the Events of the Timer. getTime Return the current simulation time. notify Notify every Observer connected to the Timer. reset Reset the Timer to time minus infinite, keeping the same Event queue. run Run the Timer until a given final time. # Return the number of Events in the Timer. add Add a new Event to the timer. If the Event has a start time less than the current simulation time then add() will prompt a warning (but the Event will be added). Arguments #1 : An Event or table. When adding a table, this function converts the table into an Event. Usage timer = Timer{} timer:add(Event{action = function() end}) clear Remove all the Events from the Timer. Note that, when this function is called within an action of an Event, if such function does not return false, it will be added to the Timer again after the end of its execution. This means that the simulation will continue with a single Event until its final time. Usage timer = Timer{ Event{action = function() print(\"step\") end} } timer:clear() getEvents Return a vector with the Events of the Timer. Usage timer = Timer{ Event{action = function() print(\"step\") end} } print(timer:getEvents()[1]:getTime()) getTime Return the current simulation time. Usage timer = Timer{ Event{action = function() print(\"step\") end} } timer:run(10) print(timer:getTime()) notify Notify every Observer connected to the Timer. Usage timer = Timer{ Event{action = function() print(\"step\") end} } Clock{target = timer} timer:run(10) timer:notify() reset Reset the Timer to time minus infinite, keeping the same Event queue. Usage timer = Timer{ Event{action = function() print(\"step\") end} } Clock{target = timer} timer:run(10) timer:reset() print(timer:getTime()) run Run the Timer until a given final time. It manages the Event queue according to their execution times and priorities. The Event with lower time will be executed in each step. If there are two Events to be executed at the same time, it executes the one with lower priority. If both have the same priority, it executes the one that was scheuled first for that time. In order to activate an Event, the Timer executes its action, passing the Event itself as argument. If the action of the Event does not return false, the Event is scheduled to execute again according to its period. The Timer then repeats its execution again and again. It stops only when all its Events are scheduled to execute after the final time, or when there are no remaining Events. Arguments #1 : A number representing the final time of the simulation. This argument is mandatory. Usage timer = Timer{ Event{action = function() print(\"step\") end} } timer:run(10) # Return the number of Events in the Timer. Usage timer = Timer{ Event{action = function() print(\"each time step\") end}, Event{period = 2, action = function() print(\"each two time steps\") end} } print(#timer)","title":"Timer"},{"location":"base/types/timer/#timer","text":"A Timer is an event-based scheduler that runs the simulation. It contains a set of Events , allowing the simulation to work with processes that start independently and act in different periodicities. As default, it execute the Events in the order they were declared, but the arguments of Event (start, priority, and period) can change this order. Once a Timer has a given simulation time, it ensures that all the Events before that time were already executed. See run() for more details.","title":"Timer"},{"location":"base/types/timer/#arguments","text":"... : A set of Events.","title":"Arguments"},{"location":"base/types/timer/#attributes","text":"Some attributes of Timer have internal semantics. They can be used as read-only by the modeler. cObj_ : A pointer to a C++ representation of the Timer. Never use this object. events : An ordered vector with the Events. time : The current simulation time.","title":"Attributes"},{"location":"base/types/timer/#usage","text":"timer = Timer{ Event{action = function() print(\"each time step\") end}, Event{period = 2, action = function() print(\"each two time steps\") end}, Event{priority = \"high\", period = 4, action = function() print(\"each four time steps\") end} } timer:run(10)","title":"Usage"},{"location":"base/types/timer/#functions","text":"add Add a new Event to the timer. clear Remove all the Events from the Timer. getEvents Return a vector with the Events of the Timer. getTime Return the current simulation time. notify Notify every Observer connected to the Timer. reset Reset the Timer to time minus infinite, keeping the same Event queue. run Run the Timer until a given final time. # Return the number of Events in the Timer.","title":"Functions"},{"location":"base/types/timer/#add","text":"Add a new Event to the timer. If the Event has a start time less than the current simulation time then add() will prompt a warning (but the Event will be added).","title":"add"},{"location":"base/types/timer/#arguments_1","text":"#1 : An Event or table. When adding a table, this function converts the table into an Event.","title":"Arguments"},{"location":"base/types/timer/#usage_1","text":"timer = Timer{} timer:add(Event{action = function() end})","title":"Usage"},{"location":"base/types/timer/#clear","text":"Remove all the Events from the Timer. Note that, when this function is called within an action of an Event, if such function does not return false, it will be added to the Timer again after the end of its execution. This means that the simulation will continue with a single Event until its final time.","title":"clear"},{"location":"base/types/timer/#usage_2","text":"timer = Timer{ Event{action = function() print(\"step\") end} } timer:clear()","title":"Usage"},{"location":"base/types/timer/#getevents","text":"Return a vector with the Events of the Timer.","title":"getEvents"},{"location":"base/types/timer/#usage_3","text":"timer = Timer{ Event{action = function() print(\"step\") end} } print(timer:getEvents()[1]:getTime())","title":"Usage"},{"location":"base/types/timer/#gettime","text":"Return the current simulation time.","title":"getTime"},{"location":"base/types/timer/#usage_4","text":"timer = Timer{ Event{action = function() print(\"step\") end} } timer:run(10) print(timer:getTime())","title":"Usage"},{"location":"base/types/timer/#notify","text":"Notify every Observer connected to the Timer.","title":"notify"},{"location":"base/types/timer/#usage_5","text":"timer = Timer{ Event{action = function() print(\"step\") end} } Clock{target = timer} timer:run(10) timer:notify()","title":"Usage"},{"location":"base/types/timer/#reset","text":"Reset the Timer to time minus infinite, keeping the same Event queue.","title":"reset"},{"location":"base/types/timer/#usage_6","text":"timer = Timer{ Event{action = function() print(\"step\") end} } Clock{target = timer} timer:run(10) timer:reset() print(timer:getTime())","title":"Usage"},{"location":"base/types/timer/#run","text":"Run the Timer until a given final time. It manages the Event queue according to their execution times and priorities. The Event with lower time will be executed in each step. If there are two Events to be executed at the same time, it executes the one with lower priority. If both have the same priority, it executes the one that was scheuled first for that time. In order to activate an Event, the Timer executes its action, passing the Event itself as argument. If the action of the Event does not return false, the Event is scheduled to execute again according to its period. The Timer then repeats its execution again and again. It stops only when all its Events are scheduled to execute after the final time, or when there are no remaining Events.","title":"run"},{"location":"base/types/timer/#arguments_2","text":"#1 : A number representing the final time of the simulation. This argument is mandatory.","title":"Arguments"},{"location":"base/types/timer/#usage_7","text":"","title":"Usage"},{"location":"base/types/timer/#timer-timer-eventaction-function-printstep-end-timerrun10","text":"","title":"timer = Timer{ Event{action = function() print(&quot;step&quot;) end} } timer:run(10)"},{"location":"base/types/timer/#_1","text":"Return the number of Events in the Timer.","title":"#"},{"location":"base/types/timer/#usage_8","text":"timer = Timer{ Event{action = function() print(\"each time step\") end}, Event{period = 2, action = function() print(\"each two time steps\") end} } print(#timer)","title":"Usage"},{"location":"base/types/trajectory/","text":"Trajectory (inherits CellularSpace ) Type that defines an ordered selection over a CellularSpace . It inherits CellularSpace; therefore it is possible to apply all functions of such type to a Trajectory. For instance, calling forEachCell() also traverses Trajectories. Arguments build : A boolean value indicating whether the Trajectory should be computed when created. The default value is true. greater : A function ( Cell , Cell)->boolean to sort the Trajectory. Such function must return true if the first Cell has priority over the second one. When using this argument, Trajectory compares each pair of Cells to establish an execution order to be used by forEachCell() . As default, the Trajectory will not be ordered and so forEachCell() will run in the order the Cells were pushed into the CellularSpace. See greaterByAttribute() for predefined options for this argument. random : A boolean value indicating that the Trajectory must be shuffled. The Trajectory will be shuffled every time one calls rebuild() or when the Trajectory is an action of an Event . This argument cannot be combined with argument greater. select : A function (Cell)->boolean indicating whether an Cell of the CellularSpace should belong to the Trajectory. If this function returns anything but false or nil for a given Cell, it will be added to the Trajectory. If this argument is missing, all Cells will be included in the Trajectory. target : The CellularSpace over which the Trajectory will take place. Attributes Some attributes of Trajectory have internal semantics. They can be used as read-only by the modeler. cells : A vector of Cells pointed by the Trajectory. cObj_ : A pointer to a C++ representation of the Trajectory. Never use this object. greater : The last function used to sort the Trajectory. parent : The CellularSpace where the Trajectory takes place. select : The last function used to filter the Trajectory. Usage cell = Cell{ cover = Random{\"forest\", \"deforested\"}, dist = Random{min = 0, max = 50} } cs = CellularSpace{ xdim = 10, instance = cell } traj = Trajectory{ target = cs, select = function(c) return c.cover == \"forest\" end, greater = function(c, d) return c.dist < d.dist end } traj = Trajectory{ target = cs, greater = function(c, d) return c.dist < d.dist end } traj = Trajectory{ target = cs, build = false } Functions add Add a new Cell to the Trajectory. clear Remove all Cells from the Trajectory. clone Return a copy of the Trajectory. filter Apply the filter over the Cells of the Trajectory. get Return a Cell from the Trajectory given its x and y locations. randomize Randomize the Cells of the Trajectory. rebuild Rebuild the Trajectory. save Save a subset from the target CellularSpace into a file. sort Sort the current CellularSpace subset. # Retrieve the number of Cells in the Trajectory. add Add a new Cell to the Trajectory. It will be added to the end of the list of Cells. Arguments #1 : A Cell. Usage cs = CellularSpace{ xdim = 10 } traj = Trajectory{ target = cs, select = function(c) return c.x > 3 end } traj:add(cs:get(1, 1)) clear Remove all Cells from the Trajectory. Usage cs = CellularSpace{ xdim = 10 } traj = Trajectory{ target = cs } traj:clear() print(#traj) clone Return a copy of the Trajectory. It has the same parent, select, greater and Cells . Any change in the cloned Trajectory will not affect the original one. Usage cell = Cell{ cover = Random{\"forest\", \"deforested\"} } cs = CellularSpace{ xdim = 10, instance = cell } traj = Trajectory{ target = cs, select = function(c) return c.cover == \"forest\" end } copy = traj:clone() print(#copy) print(#traj) filter Apply the filter over the Cells of the Trajectory. Cells that belong to the CellularSpace but do not belong to the Trajectory are ignored. This way, this function creates a subset over the subset of the CellularSpace. Usage cell = Cell{ dist = Random{min = 0, max = 50}, increase = function(self) self.dist = self.dist + 2 end } cs = CellularSpace{ xdim = 10, instance = cell } traj = Trajectory{target = cs, select = function(c) return c.dist > 20 end} traj:increase() traj:filter() get Return a Cell from the Trajectory given its x and y locations. If the Cell does not belong to the Trajectory then it will return nil. Arguments #1 : The x location. #2 : The y location. Usage cs = CellularSpace{xdim = 10} traj = Trajectory{target = cs} traj:get(1, 1) randomize Randomize the Cells of the Trajectory. It will change the traversing order used by forEachCell() . Usage cs = CellularSpace{xdim = 10} traj = Trajectory{target = cs} traj:randomize() rebuild Rebuild the Trajectory. It works as if the Trajectory was declared again with the same arguments. Usage cell = Cell{ dist = Random{min = 0, max = 50} } cs = CellularSpace{ xdim = 10, instance = cell } traj = Trajectory{ target = cs, select = function(cell) return cell.dist < 20 end, greater = function(c1, c2) return c1.dist < c2.dist end } print(#traj) forEachCell(cs, function(cell) cell.dist = cell.dist + 10 end) traj:rebuild() print(#traj) save Save a subset from the target CellularSpace into a file. Arguments #1 : A File which can be a .shp or .geojson extension. #2 : A vector with the names of the attributes to be saved. If attrs is nil, all attributes will be saved. Usage cs = CellularSpace{ file = filePath(\"test/sampa.shp\", \"gis\") } t = Trajectory{ target = cs, select = function(cell) return cell.ID % 2 == 0 end } t:save(\"odd.shp\") sort Sort the current CellularSpace subset. It updates the traversing order of the Trajectory. Usage cell = Cell{ dist = Random{min = 0, max = 50}, increase = function(self) self.dist = self.dist + Random{min = 0, max = 3}:sample() end } cs = CellularSpace{ xdim = 10, instance = cell } traj = Trajectory{target = cs, greater = function(c, d) return c.dist < d.dist end} traj:increase() traj:sort() # Retrieve the number of Cells in the Trajectory. Usage cs = CellularSpace{ xdim = 10 } traj = Trajectory{ target = cs } print(#traj)","title":"Trajectory"},{"location":"base/types/trajectory/#trajectory-inherits-cellularspace","text":"Type that defines an ordered selection over a CellularSpace . It inherits CellularSpace; therefore it is possible to apply all functions of such type to a Trajectory. For instance, calling forEachCell() also traverses Trajectories.","title":"Trajectory (inherits CellularSpace)"},{"location":"base/types/trajectory/#arguments","text":"build : A boolean value indicating whether the Trajectory should be computed when created. The default value is true. greater : A function ( Cell , Cell)->boolean to sort the Trajectory. Such function must return true if the first Cell has priority over the second one. When using this argument, Trajectory compares each pair of Cells to establish an execution order to be used by forEachCell() . As default, the Trajectory will not be ordered and so forEachCell() will run in the order the Cells were pushed into the CellularSpace. See greaterByAttribute() for predefined options for this argument. random : A boolean value indicating that the Trajectory must be shuffled. The Trajectory will be shuffled every time one calls rebuild() or when the Trajectory is an action of an Event . This argument cannot be combined with argument greater. select : A function (Cell)->boolean indicating whether an Cell of the CellularSpace should belong to the Trajectory. If this function returns anything but false or nil for a given Cell, it will be added to the Trajectory. If this argument is missing, all Cells will be included in the Trajectory. target : The CellularSpace over which the Trajectory will take place.","title":"Arguments"},{"location":"base/types/trajectory/#attributes","text":"Some attributes of Trajectory have internal semantics. They can be used as read-only by the modeler. cells : A vector of Cells pointed by the Trajectory. cObj_ : A pointer to a C++ representation of the Trajectory. Never use this object. greater : The last function used to sort the Trajectory. parent : The CellularSpace where the Trajectory takes place. select : The last function used to filter the Trajectory.","title":"Attributes"},{"location":"base/types/trajectory/#usage","text":"cell = Cell{ cover = Random{\"forest\", \"deforested\"}, dist = Random{min = 0, max = 50} } cs = CellularSpace{ xdim = 10, instance = cell } traj = Trajectory{ target = cs, select = function(c) return c.cover == \"forest\" end, greater = function(c, d) return c.dist < d.dist end } traj = Trajectory{ target = cs, greater = function(c, d) return c.dist < d.dist end } traj = Trajectory{ target = cs, build = false }","title":"Usage"},{"location":"base/types/trajectory/#functions","text":"add Add a new Cell to the Trajectory. clear Remove all Cells from the Trajectory. clone Return a copy of the Trajectory. filter Apply the filter over the Cells of the Trajectory. get Return a Cell from the Trajectory given its x and y locations. randomize Randomize the Cells of the Trajectory. rebuild Rebuild the Trajectory. save Save a subset from the target CellularSpace into a file. sort Sort the current CellularSpace subset. # Retrieve the number of Cells in the Trajectory.","title":"Functions"},{"location":"base/types/trajectory/#add","text":"Add a new Cell to the Trajectory. It will be added to the end of the list of Cells.","title":"add"},{"location":"base/types/trajectory/#arguments_1","text":"#1 : A Cell.","title":"Arguments"},{"location":"base/types/trajectory/#usage_1","text":"cs = CellularSpace{ xdim = 10 } traj = Trajectory{ target = cs, select = function(c) return c.x > 3 end } traj:add(cs:get(1, 1))","title":"Usage"},{"location":"base/types/trajectory/#clear","text":"Remove all Cells from the Trajectory.","title":"clear"},{"location":"base/types/trajectory/#usage_2","text":"cs = CellularSpace{ xdim = 10 } traj = Trajectory{ target = cs } traj:clear() print(#traj)","title":"Usage"},{"location":"base/types/trajectory/#clone","text":"Return a copy of the Trajectory. It has the same parent, select, greater and Cells . Any change in the cloned Trajectory will not affect the original one.","title":"clone"},{"location":"base/types/trajectory/#usage_3","text":"cell = Cell{ cover = Random{\"forest\", \"deforested\"} } cs = CellularSpace{ xdim = 10, instance = cell } traj = Trajectory{ target = cs, select = function(c) return c.cover == \"forest\" end } copy = traj:clone() print(#copy) print(#traj)","title":"Usage"},{"location":"base/types/trajectory/#filter","text":"Apply the filter over the Cells of the Trajectory. Cells that belong to the CellularSpace but do not belong to the Trajectory are ignored. This way, this function creates a subset over the subset of the CellularSpace.","title":"filter"},{"location":"base/types/trajectory/#usage_4","text":"cell = Cell{ dist = Random{min = 0, max = 50}, increase = function(self) self.dist = self.dist + 2 end } cs = CellularSpace{ xdim = 10, instance = cell } traj = Trajectory{target = cs, select = function(c) return c.dist > 20 end} traj:increase() traj:filter()","title":"Usage"},{"location":"base/types/trajectory/#get","text":"Return a Cell from the Trajectory given its x and y locations. If the Cell does not belong to the Trajectory then it will return nil.","title":"get"},{"location":"base/types/trajectory/#arguments_2","text":"#1 : The x location. #2 : The y location.","title":"Arguments"},{"location":"base/types/trajectory/#usage_5","text":"cs = CellularSpace{xdim = 10} traj = Trajectory{target = cs} traj:get(1, 1)","title":"Usage"},{"location":"base/types/trajectory/#randomize","text":"Randomize the Cells of the Trajectory. It will change the traversing order used by forEachCell() .","title":"randomize"},{"location":"base/types/trajectory/#usage_6","text":"cs = CellularSpace{xdim = 10} traj = Trajectory{target = cs} traj:randomize()","title":"Usage"},{"location":"base/types/trajectory/#rebuild","text":"Rebuild the Trajectory. It works as if the Trajectory was declared again with the same arguments.","title":"rebuild"},{"location":"base/types/trajectory/#usage_7","text":"cell = Cell{ dist = Random{min = 0, max = 50} } cs = CellularSpace{ xdim = 10, instance = cell } traj = Trajectory{ target = cs, select = function(cell) return cell.dist < 20 end, greater = function(c1, c2) return c1.dist < c2.dist end } print(#traj) forEachCell(cs, function(cell) cell.dist = cell.dist + 10 end) traj:rebuild() print(#traj)","title":"Usage"},{"location":"base/types/trajectory/#save","text":"Save a subset from the target CellularSpace into a file.","title":"save"},{"location":"base/types/trajectory/#arguments_3","text":"#1 : A File which can be a .shp or .geojson extension. #2 : A vector with the names of the attributes to be saved. If attrs is nil, all attributes will be saved.","title":"Arguments"},{"location":"base/types/trajectory/#usage_8","text":"cs = CellularSpace{ file = filePath(\"test/sampa.shp\", \"gis\") } t = Trajectory{ target = cs, select = function(cell) return cell.ID % 2 == 0 end } t:save(\"odd.shp\")","title":"Usage"},{"location":"base/types/trajectory/#sort","text":"Sort the current CellularSpace subset. It updates the traversing order of the Trajectory.","title":"sort"},{"location":"base/types/trajectory/#usage_9","text":"cell = Cell{ dist = Random{min = 0, max = 50}, increase = function(self) self.dist = self.dist + Random{min = 0, max = 3}:sample() end } cs = CellularSpace{ xdim = 10, instance = cell } traj = Trajectory{target = cs, greater = function(c, d) return c.dist < d.dist end} traj:increase() traj:sort()","title":"Usage"},{"location":"base/types/trajectory/#_1","text":"Retrieve the number of Cells in the Trajectory.","title":"#"},{"location":"base/types/trajectory/#usage_10","text":"cs = CellularSpace{ xdim = 10 } traj = Trajectory{ target = cs } print(#traj)","title":"Usage"},{"location":"base/types/unitTest/","text":"UnitTest Type for testing packages. All its arguments are necessary only when the tests work with database access. Arguments host : Name of the host. See CellularSpace . password : A password. See CellularSpace. port : Number of the port. See CellularSpace. source : Name of the data source. See CellularSpace. user : A user name. See CellularSpace. Usage unitTest = UnitTest{} Functions assert Check if a given value is true or if a given function works properly. assertEquals Check if two values are equal. assertError Verify if a function produces an error. assertFile Check if a given file exists and remove it. assertNil Check if a given value is nil. assertNotNil Check if a given value is not nil. assertSnapshot Verify whether a Chart or a Map has a plot similar to the one defined in the log directory. assertType Check if a value belongs to a given type. assertWarning Verify if a function produces a warning. printError Internal function to print error messages along the tests. assert Check if a given value is true or if a given function works properly. When using any other value as argument (number, string, false, nil, etc.), it shows an error. it generates an error. Arguments #1 : Any value. Usage unitTest = UnitTest{} unitTest:assert(2 < 3) assertEquals Check if two values are equal. In this function, two tables are equal only when they are the same object (if not, they would not be equal even if they share the same internal content). Arguments #1 : Any value. #2 : Any value. #3 : A number indicating a maximum error tolerance. This argument is optional and can be used with numbers or strings. When using string, the tolerance is measured according to the levenshtein() distance. The default tolerance is zero. #4 : A boolean to ignore path between /'s, when comparing two strings. It automatically converts a string such as \"directory/sub1/sub2/file\" into \"directory/file\". This argument is optional and can be used only with strings. The default value is false. Usage unitTest = UnitTest{} unitTest:assertEquals(3, 3) unitTest:assertEquals(2, 2.1, 0.2) unitTest:assertEquals(\"string [gis/data/biomassa-manaus.asc]\", \"string [gis/biomassa-manaus.asc]\", 0, true) assertError Verify if a function produces an error. If there is no error in the function or the error found is not the expected error then it generates an error. Arguments #1 : A function to be tested. #2 : A string describing the error message that the function should produce. This string should contain only the error message, without the description of the file name where the error was produced. #3 : A number indicating the maximum number of characters that can be different between the error produced by the error function and the expected error message. This argument might be necessary in error messages that include information that can change from machine to machine, such as an username. The default value is zero (no discrepancy). #4 : A boolean to ignore path between /'s, when comparing two strings. It automatically converts a string such as \"directory/sub1/sub2/file\" into \"directory/file\". The default value is false. Usage unitTest = UnitTest{} error_func = function() verify(2 > 3, \"wrong operator\") end unitTest:assertError(error_func, \"wrong operator\") assertFile Check if a given file exists and remove it. Repeating: The file is removed when calling this assert. If the file is a directory or does not exist then it shows an error. Arguments #1 : A File or a string with the file name. #2 : An optional number indicating the percentage of characters in the line that can be different. The tolerance is applied to each line of the files. The default tolerance is zero. Usage unitTest = UnitTest{} os.execute(\"touch file.txt\") -- create a file (only works in Linux and Mac) unitTest:assertFile(\"file.txt\") assertNil Check if a given value is nil. Otherwise it generates an error. Arguments #1 : Any value. Usage unitTest = UnitTest{} unitTest:assertNil() assertNotNil Check if a given value is not nil. Otherwise it generates an error. Arguments #1 : Any value. Usage unitTest = UnitTest{} unitTest:assertNotNil(2) assertSnapshot Verify whether a Chart or a Map has a plot similar to the one defined in the log directory. Note that this function cannot be used for the same file twice in the tests of a given package. Arguments #1 : A Chart or a Map. #2 : A string with the file name in the snapshot directory. If the file does not exist then it will save the file in the snapshot directory. #3 : A number between 0 and 1 with the maximum difference in percentage of pixels allowed. The default value is 0. Usage unitTest = UnitTest{} cell = Cell{value = 2} chart = Chart{target = cell} unitTest:assertSnapshot(chart, \"test_chart.bmp\") assertType Check if a value belongs to a given type. If not, it generates an error. Arguments #1 : Any value. #2 : A string with the name of a type. Usage unitTest = UnitTest{} unitTest:assertType(2, \"number\") assertWarning Verify if a function produces a warning. If there is no warning in the function or the warning found is not the expected value then it generates an error. Arguments #1 : A function to be tested. #2 : A string describing the warning message that the function is expected to produce. This string should contain only the warning message, without the description of the file name where the warning was produced. #3 : A number indicating the maximum number of characters that can be different between the warning produced by the warning function and the expected warning. This argument might be necessary in warnings that include information that can change from machine to machine, such as an username. The default value is zero (no discrepancy). #4 : A boolean to ignore path between /'s, when comparing two strings. It automatically converts a string such as \"c:/directory/sub1/sub2/file.txt\" into \"file.txt\". The default value is false. Usage unitTest = UnitTest{} error_func = function() customWarning(\"Did you forget something?\") end unitTest:assertWarning(error_func, \"Did you forget something?\") printError Internal function to print error messages along the tests. Arguments #1 : A string with the error message. Usage unitTest = UnitTest{} unitTest:printError(\"msg\")","title":"UnitTest"},{"location":"base/types/unitTest/#unittest","text":"Type for testing packages. All its arguments are necessary only when the tests work with database access.","title":"UnitTest"},{"location":"base/types/unitTest/#arguments","text":"host : Name of the host. See CellularSpace . password : A password. See CellularSpace. port : Number of the port. See CellularSpace. source : Name of the data source. See CellularSpace. user : A user name. See CellularSpace.","title":"Arguments"},{"location":"base/types/unitTest/#usage","text":"unitTest = UnitTest{}","title":"Usage"},{"location":"base/types/unitTest/#functions","text":"assert Check if a given value is true or if a given function works properly. assertEquals Check if two values are equal. assertError Verify if a function produces an error. assertFile Check if a given file exists and remove it. assertNil Check if a given value is nil. assertNotNil Check if a given value is not nil. assertSnapshot Verify whether a Chart or a Map has a plot similar to the one defined in the log directory. assertType Check if a value belongs to a given type. assertWarning Verify if a function produces a warning. printError Internal function to print error messages along the tests.","title":"Functions"},{"location":"base/types/unitTest/#assert","text":"Check if a given value is true or if a given function works properly. When using any other value as argument (number, string, false, nil, etc.), it shows an error. it generates an error.","title":"assert"},{"location":"base/types/unitTest/#arguments_1","text":"#1 : Any value.","title":"Arguments"},{"location":"base/types/unitTest/#usage_1","text":"unitTest = UnitTest{} unitTest:assert(2 < 3)","title":"Usage"},{"location":"base/types/unitTest/#assertequals","text":"Check if two values are equal. In this function, two tables are equal only when they are the same object (if not, they would not be equal even if they share the same internal content).","title":"assertEquals"},{"location":"base/types/unitTest/#arguments_2","text":"#1 : Any value. #2 : Any value. #3 : A number indicating a maximum error tolerance. This argument is optional and can be used with numbers or strings. When using string, the tolerance is measured according to the levenshtein() distance. The default tolerance is zero. #4 : A boolean to ignore path between /'s, when comparing two strings. It automatically converts a string such as \"directory/sub1/sub2/file\" into \"directory/file\". This argument is optional and can be used only with strings. The default value is false.","title":"Arguments"},{"location":"base/types/unitTest/#usage_2","text":"unitTest = UnitTest{} unitTest:assertEquals(3, 3) unitTest:assertEquals(2, 2.1, 0.2) unitTest:assertEquals(\"string [gis/data/biomassa-manaus.asc]\", \"string [gis/biomassa-manaus.asc]\", 0, true)","title":"Usage"},{"location":"base/types/unitTest/#asserterror","text":"Verify if a function produces an error. If there is no error in the function or the error found is not the expected error then it generates an error.","title":"assertError"},{"location":"base/types/unitTest/#arguments_3","text":"#1 : A function to be tested. #2 : A string describing the error message that the function should produce. This string should contain only the error message, without the description of the file name where the error was produced. #3 : A number indicating the maximum number of characters that can be different between the error produced by the error function and the expected error message. This argument might be necessary in error messages that include information that can change from machine to machine, such as an username. The default value is zero (no discrepancy). #4 : A boolean to ignore path between /'s, when comparing two strings. It automatically converts a string such as \"directory/sub1/sub2/file\" into \"directory/file\". The default value is false.","title":"Arguments"},{"location":"base/types/unitTest/#usage_3","text":"unitTest = UnitTest{} error_func = function() verify(2 > 3, \"wrong operator\") end unitTest:assertError(error_func, \"wrong operator\")","title":"Usage"},{"location":"base/types/unitTest/#assertfile","text":"Check if a given file exists and remove it. Repeating: The file is removed when calling this assert. If the file is a directory or does not exist then it shows an error.","title":"assertFile"},{"location":"base/types/unitTest/#arguments_4","text":"#1 : A File or a string with the file name. #2 : An optional number indicating the percentage of characters in the line that can be different. The tolerance is applied to each line of the files. The default tolerance is zero.","title":"Arguments"},{"location":"base/types/unitTest/#usage_4","text":"unitTest = UnitTest{} os.execute(\"touch file.txt\") -- create a file (only works in Linux and Mac) unitTest:assertFile(\"file.txt\")","title":"Usage"},{"location":"base/types/unitTest/#assertnil","text":"Check if a given value is nil. Otherwise it generates an error.","title":"assertNil"},{"location":"base/types/unitTest/#arguments_5","text":"#1 : Any value.","title":"Arguments"},{"location":"base/types/unitTest/#usage_5","text":"unitTest = UnitTest{} unitTest:assertNil()","title":"Usage"},{"location":"base/types/unitTest/#assertnotnil","text":"Check if a given value is not nil. Otherwise it generates an error.","title":"assertNotNil"},{"location":"base/types/unitTest/#arguments_6","text":"#1 : Any value.","title":"Arguments"},{"location":"base/types/unitTest/#usage_6","text":"unitTest = UnitTest{} unitTest:assertNotNil(2)","title":"Usage"},{"location":"base/types/unitTest/#assertsnapshot","text":"Verify whether a Chart or a Map has a plot similar to the one defined in the log directory. Note that this function cannot be used for the same file twice in the tests of a given package.","title":"assertSnapshot"},{"location":"base/types/unitTest/#arguments_7","text":"#1 : A Chart or a Map. #2 : A string with the file name in the snapshot directory. If the file does not exist then it will save the file in the snapshot directory. #3 : A number between 0 and 1 with the maximum difference in percentage of pixels allowed. The default value is 0.","title":"Arguments"},{"location":"base/types/unitTest/#usage_7","text":"unitTest = UnitTest{} cell = Cell{value = 2} chart = Chart{target = cell} unitTest:assertSnapshot(chart, \"test_chart.bmp\")","title":"Usage"},{"location":"base/types/unitTest/#asserttype","text":"Check if a value belongs to a given type. If not, it generates an error.","title":"assertType"},{"location":"base/types/unitTest/#arguments_8","text":"#1 : Any value. #2 : A string with the name of a type.","title":"Arguments"},{"location":"base/types/unitTest/#usage_8","text":"unitTest = UnitTest{} unitTest:assertType(2, \"number\")","title":"Usage"},{"location":"base/types/unitTest/#assertwarning","text":"Verify if a function produces a warning. If there is no warning in the function or the warning found is not the expected value then it generates an error.","title":"assertWarning"},{"location":"base/types/unitTest/#arguments_9","text":"#1 : A function to be tested. #2 : A string describing the warning message that the function is expected to produce. This string should contain only the warning message, without the description of the file name where the warning was produced. #3 : A number indicating the maximum number of characters that can be different between the warning produced by the warning function and the expected warning. This argument might be necessary in warnings that include information that can change from machine to machine, such as an username. The default value is zero (no discrepancy). #4 : A boolean to ignore path between /'s, when comparing two strings. It automatically converts a string such as \"c:/directory/sub1/sub2/file.txt\" into \"file.txt\". The default value is false.","title":"Arguments"},{"location":"base/types/unitTest/#usage_9","text":"unitTest = UnitTest{} error_func = function() customWarning(\"Did you forget something?\") end unitTest:assertWarning(error_func, \"Did you forget something?\")","title":"Usage"},{"location":"base/types/unitTest/#printerror","text":"Internal function to print error messages along the tests.","title":"printError"},{"location":"base/types/unitTest/#arguments_10","text":"#1 : A string with the error message.","title":"Arguments"},{"location":"base/types/unitTest/#usage_10","text":"unitTest = UnitTest{} unitTest:printError(\"msg\")","title":"Usage"},{"location":"base/types/visualTable/","text":"VisualTable A window with a table to show the current attributes of an object along the simulation. Each notify() overwrites the previous values shown in the table. Arguments select : A vector of strings with the name of the attributes to be observed. If it is only a single value then it can also be described as a string. As default, it selects all the user-defined attributes of an object. In the case of Society , if it does not have any numeric attributes then it will use the number of agents in the Society as attribute. target : An Agent , Cell , CellularSpace , or Society. Usage cell = Cell{ temperature = 20, humidity = 0.4 } VisualTable{ target = cell, select = {\"temperature\", \"humidity\"} } Functions save Save a VisualTable into a file. update Update the VisualTable with the latest values of its target. save Save a VisualTable into a file. Supported extensions are bmp, jpg, png, and tiff. Arguments #1 : A string with the file name. Usage cell = Cell{ temperature = 20, humidity = 0.4 } vt = VisualTable{ target = cell, select = {\"temperature\", \"humidity\"} } vt:save(\"file.bmp\") File(\"file.bmp\"):delete() update Update the VisualTable with the latest values of its target. It is usually recommended to use the VisualTable as action of an Event instead of calling this function explicitly. Usage cell = Cell{ temperature = 20, humidity = 0.4 } vt = VisualTable{ target = cell, select = {\"temperature\", \"humidity\"} } vt:update()","title":"VisualTable"},{"location":"base/types/visualTable/#visualtable","text":"A window with a table to show the current attributes of an object along the simulation. Each notify() overwrites the previous values shown in the table.","title":"VisualTable"},{"location":"base/types/visualTable/#arguments","text":"select : A vector of strings with the name of the attributes to be observed. If it is only a single value then it can also be described as a string. As default, it selects all the user-defined attributes of an object. In the case of Society , if it does not have any numeric attributes then it will use the number of agents in the Society as attribute. target : An Agent , Cell , CellularSpace , or Society.","title":"Arguments"},{"location":"base/types/visualTable/#usage","text":"cell = Cell{ temperature = 20, humidity = 0.4 } VisualTable{ target = cell, select = {\"temperature\", \"humidity\"} }","title":"Usage"},{"location":"base/types/visualTable/#functions","text":"save Save a VisualTable into a file. update Update the VisualTable with the latest values of its target.","title":"Functions"},{"location":"base/types/visualTable/#save","text":"Save a VisualTable into a file. Supported extensions are bmp, jpg, png, and tiff.","title":"save"},{"location":"base/types/visualTable/#arguments_1","text":"#1 : A string with the file name.","title":"Arguments"},{"location":"base/types/visualTable/#usage_1","text":"cell = Cell{ temperature = 20, humidity = 0.4 } vt = VisualTable{ target = cell, select = {\"temperature\", \"humidity\"} } vt:save(\"file.bmp\") File(\"file.bmp\"):delete()","title":"Usage"},{"location":"base/types/visualTable/#update","text":"Update the VisualTable with the latest values of its target. It is usually recommended to use the VisualTable as action of an Event instead of calling this function explicitly.","title":"update"},{"location":"base/types/visualTable/#usage_2","text":"cell = Cell{ temperature = 20, humidity = 0.4 } vt = VisualTable{ target = cell, select = {\"temperature\", \"humidity\"} } vt:update()","title":"Usage"}]}